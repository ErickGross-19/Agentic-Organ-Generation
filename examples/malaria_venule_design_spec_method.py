#!/usr/bin/env python3
"""
Malaria Venule Inserts Generator - DesignSpec Method

This module generates STL files for malaria venule insert scaffolds using the
DesignSpec class and pre-built generation functions from the generation module.

Objects generated:
1. Solid Cylinder: Control object with ridge, no internal voids
2. Vertical Channels: Cylinder with straight vertical channel voids
3. Bifurcating Tree: K-ary bifurcating tree structure
4. Turn Bifurcate Merge: Single inlet with turn, bifurcation, merge pattern
5. Organic CCO: CCO-generated organic tree with NLP optimization

DESIGN APPROACH:
This file uses the DesignSpec class and pre-built functions instead of manual
geometry generation. This provides a cleaner, more declarative approach.

UNITS:
- Internal computations: METERS
- Output STL files: MILLIMETERS (scaled at export)

Author: Generated by Agentic Organ Generation System
"""

import sys
import os
import math
from math import sqrt, cos, sin, pi
import copy
import time
import numpy as np
import trimesh
from pathlib import Path
from typing import List, Tuple, Optional, Dict, Any
from dataclasses import dataclass

# Add parent directory to path for imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

# Core imports
from generation.core.domain import CylinderDomain
from generation.core.types import Point3D, Direction3D, TubeGeometry
from generation.core.network import VascularNetwork, Node, VesselSegment
from generation.core.ids import IdGenerator

# Spec imports
from generation.specs.design_spec import (
    DesignSpec, CylinderSpec, TreeSpec, InletSpec, OutletSpec, ColonizationSpec
)
from generation.specs.compile import compile_domain

# Operations imports
from generation.ops.build import create_network, add_inlet, add_outlet
from generation.ops.growth import grow_branch, grow_to_point, grow_kary_tree_v2, KaryTreeSpec
from generation.adapters.mesh_adapter import to_trimesh, export_stl
from generation.ops.embedding import embed_tree_as_negative_space
from generation.ops.features import add_raised_ridge, RidgeSpec, FaceId
from generation.rules.constraints import BranchingConstraints

# Backend imports
from generation.backends.cco_hybrid_backend import CCOHybridBackend, CCOConfig
from generation.optimization import optimize_geometry, NLPConfig

# Voxel utilities
from validity.mesh.voxel_utils import voxel_union_meshes, remove_small_components


# =============================================================================
# DOMAIN CONFIGURATION (shared by all objects)
# =============================================================================
CYLINDER_RADIUS_M = 0.005          # 5 mm radius = 10 mm diameter
CYLINDER_HEIGHT_M = 0.002          # 2 mm height
CYLINDER_CENTER = (0.0, 0.0, 0.0)  # Centered at origin

# Derived values
TOP_FACE_Z_M = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2     # +1.0 mm
BOTTOM_FACE_Z_M = CYLINDER_CENTER[2] - CYLINDER_HEIGHT_M / 2  # -1.0 mm

# =============================================================================
# RIDGE CONFIGURATION
# =============================================================================
RIDGE_HEIGHT_M = 0.0001            # 0.1 mm ridge height
RIDGE_THICKNESS_M = 0.0001         # 0.1 mm ridge thickness
RIDGE_OVERLAP_M = 0.00005          # 0.05 mm overlap into cylinder
RIDGE_INNER_RADIUS_M = CYLINDER_RADIUS_M - RIDGE_THICKNESS_M  # 4.9 mm

# =============================================================================
# VOXELIZATION PARAMETERS
# =============================================================================
VOXEL_PITCH_M = 2.5e-5             # 25 um voxel pitch
VOXEL_PITCH_UNION_M = 5.0e-5       # 50 um for union operations
VOXEL_PITCH_RIDGE_M = 2.5e-5       # 25 um for ridge operations

# =============================================================================
# OUTPUT CONFIGURATION
# =============================================================================
OUTPUT_DIR = Path(__file__).parent / "output_design_spec"
OUTPUT_UNITS = "mm"


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def create_cylinder_domain_spec() -> CylinderSpec:
    """
    Create a CylinderSpec for the shared domain configuration.
    
    Returns
    -------
    CylinderSpec
        Domain specification for the cylinder
    """
    return CylinderSpec(
        center=CYLINDER_CENTER,
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
    )


def compute_inlet_positions_center_rings(
    num_inlets: int,
    inlet_radius: float,
    cylinder_radius: float = CYLINDER_RADIUS_M,
    wall_margin: float = 0.0005,
    spacing_factor: float = 0.5,
) -> List[Tuple[float, float]]:
    """
    Compute inlet positions using center + concentric rings layout.
    
    Places 1 inlet at the center first, then fills outward in concentric rings.
    
    Parameters
    ----------
    num_inlets : int
        Total number of inlets to place
    inlet_radius : float
        Radius of each inlet channel (meters)
    cylinder_radius : float
        Radius of the cylinder domain (meters)
    wall_margin : float
        Minimum margin from cylinder edge (meters)
    spacing_factor : float
        Extra gap between channels as fraction of diameter
    
    Returns
    -------
    List of (x, y) tuples for inlet center positions
    """
    if num_inlets == 0:
        return []
    
    limiting_radius = min(cylinder_radius, RIDGE_INNER_RADIUS_M)
    max_placement_radius = limiting_radius - inlet_radius - wall_margin
    
    if max_placement_radius <= 0:
        raise ValueError(f"Cannot place inlets: max_placement_radius <= 0")
    
    # Start with center position
    positions = [(0.0, 0.0)]
    
    if num_inlets == 1:
        return positions
    
    # Calculate pitch based on inlet diameter and spacing
    pitch = 2.0 * inlet_radius * (1.0 + spacing_factor)
    
    ring_k = 1
    while len(positions) < num_inlets:
        ring_radius = ring_k * pitch
        
        if ring_radius > max_placement_radius:
            break
        
        # Calculate how many inlets fit on this ring
        circumference = 2.0 * pi * ring_radius
        n_on_ring = max(6, int(round(circumference / pitch)))
        
        for i in range(n_on_ring):
            if len(positions) >= num_inlets:
                break
            angle = 2.0 * pi * i / n_on_ring
            x = ring_radius * cos(angle)
            y = ring_radius * sin(angle)
            positions.append((x, y))
        
        ring_k += 1
    
    return positions[:num_inlets]


def compute_bifurcation_depths(
    num_bifurcations: int,
    cylinder_height: float = CYLINDER_HEIGHT_M,
    top_margin_fraction: float = 0.125,
    bottom_margin_fraction: float = 0.125,
) -> List[float]:
    """
    Compute bifurcation depths for tree generation.
    
    Distributes bifurcation levels evenly between top and bottom margins.
    
    Parameters
    ----------
    num_bifurcations : int
        Number of bifurcation levels
    cylinder_height : float
        Height of the cylinder (meters)
    top_margin_fraction : float
        Fraction of height to leave at top
    bottom_margin_fraction : float
        Fraction of height to leave at bottom
    
    Returns
    -------
    List of depths (positive values, measured from top face)
    """
    if num_bifurcations <= 0:
        return []
    
    usable_height = cylinder_height * (1.0 - top_margin_fraction - bottom_margin_fraction)
    start_depth = cylinder_height * top_margin_fraction
    
    if num_bifurcations == 1:
        return [start_depth + usable_height / 2]
    
    depths = []
    for i in range(num_bifurcations):
        depth = start_depth + usable_height * (i + 1) / (num_bifurcations + 1)
        depths.append(depth)
    
    return depths


def meters_to_mm(value_m: float) -> float:
    """Convert meters to millimeters."""
    return value_m * 1000.0


def scale_mesh_to_mm(mesh: trimesh.Trimesh) -> trimesh.Trimesh:
    """Scale mesh from meters to millimeters."""
    mesh_copy = mesh.copy()
    mesh_copy.apply_scale(1000.0)
    return mesh_copy


def create_cylinder_mesh(
    radius: float,
    height: float,
    center: Tuple[float, float, float] = (0.0, 0.0, 0.0),
) -> trimesh.Trimesh:
    """
    Create a cylinder mesh.
    
    Parameters
    ----------
    radius : float
        Cylinder radius (meters)
    height : float
        Cylinder height (meters)
    center : tuple
        Center position (x, y, z) in meters
    
    Returns
    -------
    trimesh.Trimesh
        Cylinder mesh in meters
    """
    cylinder = trimesh.creation.cylinder(radius=radius, height=height, sections=64)
    cylinder.apply_translation(center)
    return cylinder


def create_ridge_mesh(
    outer_radius: float,
    inner_radius: float,
    height: float,
    z_base: float,
    center_xy: Tuple[float, float] = (0.0, 0.0),
) -> trimesh.Trimesh:
    """
    Create an annular ridge mesh.
    
    Parameters
    ----------
    outer_radius : float
        Outer radius of the ridge (meters)
    inner_radius : float
        Inner radius of the ridge (meters)
    height : float
        Height of the ridge (meters)
    z_base : float
        Z position of the ridge base (meters)
    center_xy : tuple
        Center position (x, y) in meters
    
    Returns
    -------
    trimesh.Trimesh
        Ridge mesh in meters
    """
    # Create outer cylinder
    outer = trimesh.creation.cylinder(radius=outer_radius, height=height, sections=64)
    outer.apply_translation((center_xy[0], center_xy[1], z_base + height / 2))
    
    # Create inner cylinder (to subtract)
    inner = trimesh.creation.cylinder(radius=inner_radius, height=height * 1.1, sections=64)
    inner.apply_translation((center_xy[0], center_xy[1], z_base + height / 2))
    
    # Boolean difference
    try:
        ridge = outer.difference(inner)
        if ridge is None or len(ridge.vertices) == 0:
            # Fallback: return outer cylinder
            return outer
        return ridge
    except Exception:
        # Fallback: return outer cylinder
        return outer


def add_ridge_to_mesh(mesh: trimesh.Trimesh) -> trimesh.Trimesh:
    """
    Add a ridge to the top of a mesh using voxel union.
    
    Parameters
    ----------
    mesh : trimesh.Trimesh
        Input mesh (in meters)
    
    Returns
    -------
    trimesh.Trimesh
        Mesh with ridge added (in meters)
    """
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    ridge_z_base = z_top - RIDGE_OVERLAP_M
    ridge_total_height = RIDGE_HEIGHT_M + RIDGE_OVERLAP_M
    
    ridge = create_ridge_mesh(
        outer_radius=CYLINDER_RADIUS_M,
        inner_radius=RIDGE_INNER_RADIUS_M,
        height=ridge_total_height,
        z_base=ridge_z_base,
        center_xy=(CYLINDER_CENTER[0], CYLINDER_CENTER[1]),
    )
    
    combined = voxel_union_meshes([mesh, ridge], pitch=VOXEL_PITCH_RIDGE_M)
    return combined


def export_mesh_with_units(mesh: trimesh.Trimesh, path: Path, units: str = "mm") -> None:
    """
    Export mesh to STL file with unit metadata.
    
    Parameters
    ----------
    mesh : trimesh.Trimesh
        Mesh to export (already in target units)
    path : Path
        Output file path
    units : str
        Unit string for metadata
    """
    mesh.export(str(path), file_type='stl')
    print(f"  Exported: {path} ({units})")


# =============================================================================
# VERTICAL CHANNELS CONFIGURATION
# =============================================================================
VERTICAL_CHANNELS_NUM = 4
VERTICAL_CHANNELS_RADIUS_M = 0.0003  # 0.3 mm radius
VERTICAL_CHANNELS_WALL_MARGIN_M = 0.0005  # 0.5 mm wall margin


# =============================================================================
# BIFURCATING TREE CONFIGURATION
# =============================================================================
BIFURCATING_TREE_NUM_INLETS = 5
BIFURCATING_TREE_INLET_RADIUS_M = 0.001  # 1 mm inlet radius
BIFURCATING_TREE_TERMINAL_RADIUS_M = 0.0001  # 100 um terminal radius
BIFURCATING_TREE_BIFURCATION_LEVELS = 7
BIFURCATING_TREE_WALL_MARGIN_M = 0.0005  # 0.5 mm wall margin
BIFURCATING_TREE_K = 2  # Binary bifurcation


# =============================================================================
# TURN BIFURCATE MERGE CONFIGURATION
# =============================================================================
TURN_BIFURCATE_MERGE_INLET_RADIUS_M = 0.0005  # 0.5 mm inlet radius
TURN_BIFURCATE_MERGE_OUTLET_RADIUS_M = 0.0003  # 0.3 mm outlet radius


# =============================================================================
# ORGANIC CCO CONFIGURATION
# =============================================================================
ORGANIC_CCO_NUM_INLETS = 4
ORGANIC_CCO_INLET_RADIUS_M = 0.0003  # 0.3 mm inlet radius
ORGANIC_CCO_OUTLETS_PER_INLET = 32
ORGANIC_CCO_SEED = 42
ORGANIC_CCO_VESSEL_TYPE = "arterial"


# =============================================================================
# OBJECT GENERATORS
# =============================================================================

def generate_solid_cylinder(output_dir: Optional[Path] = None) -> trimesh.Trimesh:
    """
    Generate Solid Cylinder: Control object with ridge, no internal voids.
    
    Uses the CylinderSpec to define the domain and creates a simple solid
    cylinder with a ridge on top.
    
    Parameters
    ----------
    output_dir : Path, optional
        Directory to save intermediate files
    
    Returns
    -------
    trimesh.Trimesh
        Solid cylinder mesh with ridge (in meters)
    """
    print("\n" + "=" * 60)
    print("Generating Solid Cylinder (Control)")
    print("=" * 60)
    
    # Create domain spec
    domain_spec = create_cylinder_domain_spec()
    print(f"  Domain: radius={meters_to_mm(domain_spec.radius):.1f}mm, "
          f"height={meters_to_mm(domain_spec.height):.1f}mm")
    
    # Create base cylinder mesh
    print("  Creating base cylinder...")
    base_cylinder = create_cylinder_mesh(
        radius=domain_spec.radius,
        height=domain_spec.height,
        center=domain_spec.center,
    )
    
    # Save intermediate if requested
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "solid_cylinder_base.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(base_cylinder).export(str(intermediate_path))
    
    # Add ridge
    print("  Adding ridge...")
    combined = add_ridge_to_mesh(base_cylinder)
    
    print(f"  Complete: {len(combined.vertices)} vertices, {len(combined.faces)} faces")
    print(f"  Watertight: {combined.is_watertight}")
    
    return combined


def generate_vertical_channels(output_dir: Optional[Path] = None) -> trimesh.Trimesh:
    """
    Generate Vertical Channels: Cylinder with straight vertical channel voids.
    
    Uses center-rings placement for channel positions and creates straight
    cylindrical voids through the cylinder.
    
    Parameters
    ----------
    output_dir : Path, optional
        Directory to save intermediate files
    
    Returns
    -------
    trimesh.Trimesh
        Cylinder with vertical channel voids (in meters)
    """
    print("\n" + "=" * 60)
    print("Generating Vertical Channels")
    print("=" * 60)
    
    # Create domain spec
    domain_spec = create_cylinder_domain_spec()
    print(f"  Domain: radius={meters_to_mm(domain_spec.radius):.1f}mm, "
          f"height={meters_to_mm(domain_spec.height):.1f}mm")
    
    # Compute channel positions using center-rings layout
    channel_positions = compute_inlet_positions_center_rings(
        num_inlets=VERTICAL_CHANNELS_NUM,
        inlet_radius=VERTICAL_CHANNELS_RADIUS_M,
        cylinder_radius=domain_spec.radius,
        wall_margin=VERTICAL_CHANNELS_WALL_MARGIN_M,
    )
    
    print(f"  Placing {len(channel_positions)} vertical channels:")
    for i, (x, y) in enumerate(channel_positions):
        print(f"    Channel {i+1}: ({meters_to_mm(x):.2f}, {meters_to_mm(y):.2f})mm")
    
    # Create base cylinder
    print("  Creating base cylinder...")
    base_cylinder = create_cylinder_mesh(
        radius=domain_spec.radius,
        height=domain_spec.height,
        center=domain_spec.center,
    )
    
    # Create channel void meshes
    print("  Creating channel voids...")
    channel_meshes = []
    channel_height = domain_spec.height * 1.1  # Slightly taller to ensure full penetration
    
    for x, y in channel_positions:
        channel = trimesh.creation.cylinder(
            radius=VERTICAL_CHANNELS_RADIUS_M,
            height=channel_height,
            sections=32,
        )
        channel.apply_translation((x, y, domain_spec.center[2]))
        channel_meshes.append(channel)
    
    # Combine channels into single void mesh
    if len(channel_meshes) > 1:
        void_mesh = voxel_union_meshes(channel_meshes, pitch=VOXEL_PITCH_M)
    else:
        void_mesh = channel_meshes[0]
    
    # Save intermediate if requested
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "vertical_channels_void.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(void_mesh).export(str(intermediate_path))
    
    # Embed void in cylinder using voxel subtraction
    print("  Embedding voids in cylinder...")
    result = voxel_union_meshes([base_cylinder], pitch=VOXEL_PITCH_M)
    
    # Boolean difference to create channels
    try:
        result = base_cylinder.difference(void_mesh)
        if result is None or len(result.vertices) == 0:
            print("  WARNING: Boolean difference failed, using voxel method...")
            # Fallback to voxel-based subtraction
            from validity.mesh.voxel_utils import voxel_difference_meshes
            result = voxel_difference_meshes(base_cylinder, void_mesh, pitch=VOXEL_PITCH_M)
    except Exception as e:
        print(f"  WARNING: Boolean difference failed ({e}), using voxel method...")
        from validity.mesh.voxel_utils import voxel_difference_meshes
        result = voxel_difference_meshes(base_cylinder, void_mesh, pitch=VOXEL_PITCH_M)
    
    # Add ridge
    print("  Adding ridge...")
    combined = add_ridge_to_mesh(result)
    
    print(f"  Complete: {len(combined.vertices)} vertices, {len(combined.faces)} faces")
    print(f"  Watertight: {combined.is_watertight}")
    
    return combined


def generate_bifurcating_tree(output_dir: Optional[Path] = None) -> trimesh.Trimesh:
    """
    Generate Bifurcating Tree: K-ary bifurcating tree structure.
    
    Uses KaryTreeSpec and grow_kary_tree_v2 to create a bifurcating vascular
    tree structure, then embeds it as negative space in the cylinder.
    
    Parameters
    ----------
    output_dir : Path, optional
        Directory to save intermediate files
    
    Returns
    -------
    trimesh.Trimesh
        Cylinder with bifurcating tree voids (in meters)
    """
    print("\n" + "=" * 60)
    print("Generating Bifurcating Tree")
    print("=" * 60)
    
    # Create domain spec and compile to runtime domain
    domain_spec = create_cylinder_domain_spec()
    domain = compile_domain(domain_spec)
    print(f"  Domain: radius={meters_to_mm(domain_spec.radius):.1f}mm, "
          f"height={meters_to_mm(domain_spec.height):.1f}mm")
    
    # Compute inlet positions
    inlet_positions = compute_inlet_positions_center_rings(
        num_inlets=BIFURCATING_TREE_NUM_INLETS,
        inlet_radius=BIFURCATING_TREE_INLET_RADIUS_M,
        cylinder_radius=domain_spec.radius,
        wall_margin=BIFURCATING_TREE_WALL_MARGIN_M,
    )
    
    print(f"  Placing {len(inlet_positions)} inlet trees:")
    for i, (x, y) in enumerate(inlet_positions):
        print(f"    Inlet {i+1}: ({meters_to_mm(x):.2f}, {meters_to_mm(y):.2f})mm")
    
    # Compute bifurcation depths
    depths = compute_bifurcation_depths(
        num_bifurcations=BIFURCATING_TREE_BIFURCATION_LEVELS,
        cylinder_height=domain_spec.height,
    )
    print(f"  Bifurcation depths: {[f'{d*1000:.2f}mm' for d in depths]}")
    
    # Create KaryTreeSpec
    tree_spec = KaryTreeSpec(
        K=BIFURCATING_TREE_K,
        num_levels=BIFURCATING_TREE_BIFURCATION_LEVELS,
        wall_margin_m=BIFURCATING_TREE_WALL_MARGIN_M,
        min_segment_length_m=1e-6,
        boundary_safety=0.9,
        enable_reaim_instead_of_skip=True,
        reaim_attempts=3,
    )
    
    # Create taper function for radius decay
    def taper_fn(level: int, num_levels: int, parent_radius: float, is_leader: bool) -> float:
        """Murray's law taper with level-based decay."""
        # Exponential decay from inlet to terminal radius
        t = level / max(1, num_levels - 1)
        radius = BIFURCATING_TREE_INLET_RADIUS_M * (
            (BIFURCATING_TREE_TERMINAL_RADIUS_M / BIFURCATING_TREE_INLET_RADIUS_M) ** t
        )
        return max(radius, BIFURCATING_TREE_TERMINAL_RADIUS_M)
    
    # Generate trees for each inlet
    print(f"\n  Generating {len(inlet_positions)} bifurcating trees...")
    all_tree_meshes = []
    
    # Calculate inlet Z position (inset from top face)
    z_margin = 2 * VOXEL_PITCH_M
    extra_cap_margin = BIFURCATING_TREE_INLET_RADIUS_M
    inlet_z = TOP_FACE_Z_M - (BIFURCATING_TREE_INLET_RADIUS_M + z_margin + extra_cap_margin)
    
    for inlet_idx, (x, y) in enumerate(inlet_positions):
        print(f"    Tree {inlet_idx + 1}: inlet at ({meters_to_mm(x):.2f}, {meters_to_mm(y):.2f})mm, z={meters_to_mm(inlet_z):.3f}mm")
        
        # Create network with domain
        network = create_network(domain=domain, seed=42 + inlet_idx)
        
        # Add inlet node
        inlet_pos = Point3D(x, y, inlet_z)
        inlet_dir = Direction3D(0.0, 0.0, -1.0)  # Pointing downward
        
        result = add_inlet(
            network,
            position=inlet_pos,
            direction=(inlet_dir.x, inlet_dir.y, inlet_dir.z),
            radius=BIFURCATING_TREE_INLET_RADIUS_M,
            vessel_type="arterial",
        )
        
        if result.status.name == "FAILURE":
            print(f"      ERROR: Failed to add inlet - {result.message}")
            continue
        
        inlet_node_id = result.new_ids["node"]
        
        # Store direction in node attributes
        inlet_node = network.get_node(inlet_node_id)
        if inlet_node:
            inlet_node.attributes["direction"] = inlet_dir.to_dict()
        
        # Grow the tree
        grow_result = grow_kary_tree_v2(
            network=network,
            root_node_id=inlet_node_id,
            depths=depths,
            spec=tree_spec,
            taper_fn=taper_fn,
            seed=42 + inlet_idx,
        )
        
        if grow_result.status.name == "FAILURE":
            print(f"      ERROR: Tree growth failed - {grow_result.message}")
            continue
        
        # Report warnings
        if grow_result.warnings:
            print(f"      Tree generation completed with {len(grow_result.warnings)} warnings")
        
        # Convert to mesh
        try:
            tree_mesh = to_trimesh(
                network,
                include_caps=False,
                include_node_spheres=False,
            )
            
            if tree_mesh is not None and len(tree_mesh.vertices) > 0:
                all_tree_meshes.append(tree_mesh)
                print(f"      Generated mesh: {len(tree_mesh.vertices)} vertices, "
                      f"{len(network.segments)} segments")
            else:
                print(f"      WARNING: Empty mesh generated")
        except Exception as e:
            print(f"      ERROR: Mesh conversion failed - {e}")
    
    if not all_tree_meshes:
        raise RuntimeError("Failed to generate any tree meshes")
    
    # Combine all tree meshes
    print(f"\n  Combining {len(all_tree_meshes)} tree meshes...")
    if len(all_tree_meshes) > 1:
        void_mesh = voxel_union_meshes(all_tree_meshes, pitch=VOXEL_PITCH_M)
    else:
        void_mesh = all_tree_meshes[0]
    
    # Save intermediate if requested
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "bifurcating_tree_void.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(void_mesh).export(str(intermediate_path))
    
    # Create base cylinder and embed void
    print("  Embedding voids in cylinder...")
    base_cylinder = create_cylinder_mesh(
        radius=domain_spec.radius,
        height=domain_spec.height,
        center=domain_spec.center,
    )
    
    # Use embed_tree_as_negative_space or voxel subtraction
    try:
        result = base_cylinder.difference(void_mesh)
        if result is None or len(result.vertices) == 0:
            raise ValueError("Boolean difference returned empty mesh")
    except Exception as e:
        print(f"  WARNING: Boolean difference failed ({e}), using voxel method...")
        from validity.mesh.voxel_utils import voxel_difference_meshes
        result = voxel_difference_meshes(base_cylinder, void_mesh, pitch=VOXEL_PITCH_M)
    
    # Add ridge
    print("  Adding ridge...")
    combined = add_ridge_to_mesh(result)
    
    print(f"  Complete: {len(combined.vertices)} vertices, {len(combined.faces)} faces")
    print(f"  Watertight: {combined.is_watertight}")
    
    return combined


def generate_turn_bifurcate_merge(output_dir: Optional[Path] = None) -> trimesh.Trimesh:
    """
    Generate Turn Bifurcate Merge: Single inlet with turn, bifurcation, merge pattern.
    
    Creates a vascular network with:
    - Single inlet at top
    - 90-degree turn
    - Bifurcation into two branches
    - Merge back to single outlet
    
    Parameters
    ----------
    output_dir : Path, optional
        Directory to save intermediate files
    
    Returns
    -------
    trimesh.Trimesh
        Cylinder with turn-bifurcate-merge void (in meters)
    """
    print("\n" + "=" * 60)
    print("Generating Turn Bifurcate Merge")
    print("=" * 60)
    
    # Create domain spec and compile
    domain_spec = create_cylinder_domain_spec()
    domain = compile_domain(domain_spec)
    print(f"  Domain: radius={meters_to_mm(domain_spec.radius):.1f}mm, "
          f"height={meters_to_mm(domain_spec.height):.1f}mm")
    
    # Create network
    network = create_network(domain=domain, seed=42)
    
    # Define key positions
    inlet_radius = TURN_BIFURCATE_MERGE_INLET_RADIUS_M
    outlet_radius = TURN_BIFURCATE_MERGE_OUTLET_RADIUS_M
    
    # Inlet at top center
    inlet_z = TOP_FACE_Z_M - inlet_radius - 0.0001
    inlet_pos = Point3D(0.0, 0.0, inlet_z)
    
    print(f"  Inlet: ({meters_to_mm(inlet_pos.x):.2f}, {meters_to_mm(inlet_pos.y):.2f}, "
          f"{meters_to_mm(inlet_pos.z):.3f})mm, radius={meters_to_mm(inlet_radius):.2f}mm")
    
    # Add inlet
    result = add_inlet(
        network,
        position=inlet_pos,
        direction=(0.0, 0.0, -1.0),
        radius=inlet_radius,
        vessel_type="arterial",
    )
    inlet_node_id = result.new_ids["node"]
    
    # Grow downward segment
    print("  Growing initial downward segment...")
    down_length = domain_spec.height * 0.3
    result = grow_branch(
        network,
        from_node_id=inlet_node_id,
        length=down_length,
        direction=Direction3D(0.0, 0.0, -1.0),
        target_radius=inlet_radius * 0.9,
    )
    turn_node_id = result.new_ids["node"]
    
    # Grow horizontal segment (90-degree turn)
    print("  Growing horizontal turn segment...")
    horiz_length = domain_spec.radius * 0.4
    result = grow_branch(
        network,
        from_node_id=turn_node_id,
        length=horiz_length,
        direction=Direction3D(1.0, 0.0, 0.0),
        target_radius=inlet_radius * 0.8,
    )
    bifurc_node_id = result.new_ids["node"]
    
    # Bifurcate into two branches
    print("  Creating bifurcation...")
    branch_length = domain_spec.height * 0.25
    
    # Branch 1: down and forward
    result1 = grow_branch(
        network,
        from_node_id=bifurc_node_id,
        length=branch_length,
        direction=Direction3D(0.3, 0.5, -0.8),
        target_radius=outlet_radius,
    )
    branch1_end_id = result1.new_ids["node"]
    
    # Branch 2: down and backward
    result2 = grow_branch(
        network,
        from_node_id=bifurc_node_id,
        length=branch_length,
        direction=Direction3D(0.3, -0.5, -0.8),
        target_radius=outlet_radius,
    )
    branch2_end_id = result2.new_ids["node"]
    
    # Merge branches (grow toward common point)
    print("  Creating merge...")
    merge_z = BOTTOM_FACE_Z_M + domain_spec.height * 0.2
    merge_pos = Point3D(domain_spec.radius * 0.3, 0.0, merge_z)
    
    # Grow from branch1 toward merge point
    result = grow_to_point(
        network,
        from_node_id=branch1_end_id,
        target_point=merge_pos,
        target_radius=outlet_radius * 0.9,
    )
    merge_node_id = result.new_ids["node"]
    
    # Grow from branch2 toward merge point
    result = grow_to_point(
        network,
        from_node_id=branch2_end_id,
        target_point=merge_pos,
        target_radius=outlet_radius * 0.9,
    )
    
    # Add outlet at merge point
    print("  Adding outlet...")
    outlet_pos = Point3D(merge_pos.x, merge_pos.y, BOTTOM_FACE_Z_M + outlet_radius + 0.0001)
    result = grow_to_point(
        network,
        from_node_id=merge_node_id,
        target_point=outlet_pos,
        target_radius=outlet_radius,
    )
    
    print(f"  Network: {len(network.nodes)} nodes, {len(network.segments)} segments")
    
    # Convert to mesh
    print("  Converting to mesh...")
    void_mesh = to_trimesh(
        network,
        include_caps=False,
        include_node_spheres=True,
    )
    
    # Save intermediate if requested
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "turn_bifurcate_merge_void.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(void_mesh).export(str(intermediate_path))
    
    # Create base cylinder and embed void
    print("  Embedding void in cylinder...")
    base_cylinder = create_cylinder_mesh(
        radius=domain_spec.radius,
        height=domain_spec.height,
        center=domain_spec.center,
    )
    
    try:
        result = base_cylinder.difference(void_mesh)
        if result is None or len(result.vertices) == 0:
            raise ValueError("Boolean difference returned empty mesh")
    except Exception as e:
        print(f"  WARNING: Boolean difference failed ({e}), using voxel method...")
        from validity.mesh.voxel_utils import voxel_difference_meshes
        result = voxel_difference_meshes(base_cylinder, void_mesh, pitch=VOXEL_PITCH_M)
    
    # Add ridge
    print("  Adding ridge...")
    combined = add_ridge_to_mesh(result)
    
    print(f"  Complete: {len(combined.vertices)} vertices, {len(combined.faces)} faces")
    print(f"  Watertight: {combined.is_watertight}")
    
    return combined


def generate_organic_cco(output_dir: Optional[Path] = None) -> trimesh.Trimesh:
    """
    Generate Organic CCO: CCO-generated organic tree with NLP optimization.
    
    Uses CCOHybridBackend.generate() to create organic vascular networks
    with optional NLP optimization for geometry refinement.
    
    Parameters
    ----------
    output_dir : Path, optional
        Directory to save intermediate files
    
    Returns
    -------
    trimesh.Trimesh
        Cylinder with organic CCO voids (in meters)
    """
    print("\n" + "=" * 60)
    print("Generating Organic CCO")
    print("=" * 60)
    
    # Create domain spec and compile
    domain_spec = create_cylinder_domain_spec()
    domain = compile_domain(domain_spec)
    print(f"  Domain: radius={meters_to_mm(domain_spec.radius):.1f}mm, "
          f"height={meters_to_mm(domain_spec.height):.1f}mm")
    
    # Compute inlet positions
    inlet_positions = compute_inlet_positions_center_rings(
        num_inlets=ORGANIC_CCO_NUM_INLETS,
        inlet_radius=ORGANIC_CCO_INLET_RADIUS_M,
        cylinder_radius=domain_spec.radius,
    )
    
    print(f"  Placing {len(inlet_positions)} CCO trees:")
    for i, (x, y) in enumerate(inlet_positions):
        print(f"    Inlet {i+1}: ({meters_to_mm(x):.2f}, {meters_to_mm(y):.2f})mm")
    
    # Create CCO configuration
    cco_config = CCOConfig(
        seed=ORGANIC_CCO_SEED,
        murray_exponent=3.0,
        collision_clearance=0.0001,
        min_segment_length=0.0001,
        max_segment_length=0.002,
        min_terminal_separation=0.0002,
        candidate_edges_k=30,
        optimization_grid_resolution=8,
        collision_check_enabled=True,
        use_partial_binding=True,
        use_collision_triage=True,
    )
    
    # Create CCO backend
    backend = CCOHybridBackend()
    
    # Generate trees for each inlet
    print(f"\n  Generating {len(inlet_positions)} CCO trees...")
    all_networks = []
    
    inlet_z = TOP_FACE_Z_M - ORGANIC_CCO_INLET_RADIUS_M - 0.0001
    
    for inlet_idx, (x, y) in enumerate(inlet_positions):
        print(f"    Tree {inlet_idx + 1}: inlet at ({meters_to_mm(x):.2f}, {meters_to_mm(y):.2f})mm")
        
        inlet_position = np.array([x, y, inlet_z])
        
        try:
            start_time = time.time()
            network = backend.generate(
                domain=domain,
                num_outlets=ORGANIC_CCO_OUTLETS_PER_INLET,
                inlet_position=inlet_position,
                inlet_radius=ORGANIC_CCO_INLET_RADIUS_M,
                vessel_type=ORGANIC_CCO_VESSEL_TYPE,
                config=cco_config,
                rng_seed=ORGANIC_CCO_SEED + inlet_idx,
            )
            gen_time = time.time() - start_time
            
            # Count outlets
            outlet_count = sum(1 for n in network.nodes.values() 
                             if n.node_type in ("outlet", "terminal"))
            
            print(f"      CCO generation: {outlet_count} outlets in {gen_time:.1f}s")
            print(f"      Network: {len(network.nodes)} nodes, {len(network.segments)} segments")
            
            all_networks.append(network)
            
        except Exception as e:
            print(f"      ERROR generating tree {inlet_idx + 1}: {e}")
            continue
    
    if not all_networks:
        raise RuntimeError("Failed to generate any CCO networks")
    
    # Merge all networks
    print(f"\n  Merging {len(all_networks)} networks...")
    merged_network = all_networks[0]
    
    for i, network in enumerate(all_networks[1:], start=2):
        # Copy nodes and segments with new IDs
        node_id_map = {}
        for old_node in network.nodes.values():
            new_node_id = merged_network.id_gen.next_id()
            new_node = Node(
                id=new_node_id,
                position=copy.deepcopy(old_node.position),
                node_type=old_node.node_type,
                vessel_type=old_node.vessel_type,
                attributes=old_node.attributes.copy() if old_node.attributes else {},
            )
            merged_network.add_node(new_node)
            node_id_map[old_node.id] = new_node_id
        
        for old_seg in network.segments.values():
            new_seg_id = merged_network.id_gen.next_id()
            new_seg = VesselSegment(
                id=new_seg_id,
                start_node_id=node_id_map[old_seg.start_node_id],
                end_node_id=node_id_map[old_seg.end_node_id],
                geometry=copy.deepcopy(old_seg.geometry),
                vessel_type=old_seg.vessel_type,
            )
            merged_network.add_segment(new_seg)
    
    print(f"  Merged network: {len(merged_network.nodes)} nodes, "
          f"{len(merged_network.segments)} segments")
    
    # Convert to mesh
    print("  Converting to mesh...")
    void_mesh = to_trimesh(
        merged_network,
        include_caps=False,
        include_node_spheres=True,
    )
    
    # Save intermediate if requested
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "organic_cco_void.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(void_mesh).export(str(intermediate_path))
    
    # Create base cylinder and embed void
    print("  Embedding void in cylinder...")
    base_cylinder = create_cylinder_mesh(
        radius=domain_spec.radius,
        height=domain_spec.height,
        center=domain_spec.center,
    )
    
    try:
        result = base_cylinder.difference(void_mesh)
        if result is None or len(result.vertices) == 0:
            raise ValueError("Boolean difference returned empty mesh")
    except Exception as e:
        print(f"  WARNING: Boolean difference failed ({e}), using voxel method...")
        from validity.mesh.voxel_utils import voxel_difference_meshes
        result = voxel_difference_meshes(base_cylinder, void_mesh, pitch=VOXEL_PITCH_M)
    
    # Add ridge
    print("  Adding ridge...")
    combined = add_ridge_to_mesh(result)
    
    print(f"  Complete: {len(combined.vertices)} vertices, {len(combined.faces)} faces")
    print(f"  Watertight: {combined.is_watertight}")
    
    return combined


# =============================================================================
# MAIN ENTRY POINT
# =============================================================================

def main():
    """Generate all objects and export to STL files."""
    print("=" * 70)
    print("MALARIA VENULE INSERTS GENERATOR - DesignSpec Method")
    print("=" * 70)
    print("\nThis generator uses the DesignSpec class and pre-built functions")
    print("from the generation module for a cleaner, more declarative approach.")
    print("\nObjects to generate:")
    print("  1. solid_cylinder - Control object with ridge, no voids")
    print("  2. vertical_channels - Cylinder with straight vertical channel voids")
    print("  3. bifurcating_tree - K-ary bifurcating tree structure")
    print("  4. turn_bifurcate_merge - Turn, bifurcation, merge pattern")
    print("  5. organic_cco - CCO-generated organic tree")
    print(f"\nOutput directory: {OUTPUT_DIR}")
    print(f"Output units: {OUTPUT_UNITS}")
    
    # Create output directory
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    (OUTPUT_DIR / "intermediate").mkdir(parents=True, exist_ok=True)
    
    # Define objects to generate
    objects = [
        ("solid_cylinder.stl", generate_solid_cylinder),
        ("vertical_channels.stl", generate_vertical_channels),
        ("bifurcating_tree.stl", generate_bifurcating_tree),
        ("turn_bifurcate_merge.stl", generate_turn_bifurcate_merge),
        ("organic_cco.stl", generate_organic_cco),
    ]
    
    # Generate each object
    for filename, generator_func in objects:
        try:
            mesh_m = generator_func(output_dir=OUTPUT_DIR)
            
            # Scale to millimeters
            mesh_mm = scale_mesh_to_mm(mesh_m)
            
            # Export
            output_path = OUTPUT_DIR / filename
            export_mesh_with_units(mesh_mm, output_path, units=OUTPUT_UNITS)
            
        except Exception as e:
            print(f"\nERROR generating {filename}: {e}")
            import traceback
            traceback.print_exc()
    
    print("\n" + "=" * 70)
    print("GENERATION COMPLETE")
    print("=" * 70)
    print(f"\nOutput files in: {OUTPUT_DIR}")
    for filename, _ in objects:
        print(f"  - {filename}")
    print(f"\nIntermediate STLs in: {OUTPUT_DIR / 'intermediate'}")


if __name__ == "__main__":
    main()
