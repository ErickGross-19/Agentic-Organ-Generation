#!/usr/bin/env python3
"""
Terminal-Venule Insert Generator for 48-Well Plate Compatible Scaffolds

This module generates single-well inserts with vascular channel architecture
designed for hepatocyte culture experiments. The design uses CCO (Constrained
Constructive Optimization) to generate diverging vascular trees from inlet points
to randomly distributed terminal nodes within the domain.

DESIGN BRIEF
------------
The insert combines:
1. Vascular channel architecture: diverging trees from inlets to terminal nodes
   - CCO algorithm generates physiologically realistic branching patterns
   - Murray's law-based radius scaling for optimal flow
   - Scaled for printability while preserving topology

2. Open porous scaffold domain around/among channels for:
   - Cell invasion ("dig into")
   - Cell seeding onto scaffold surface
   - Hepatocyte embedding
   - Matrix remodeling

TWO DESIGN VARIANTS
-------------------
1. Single-Input Design:
   - One inlet at the perimeter
   - Diverging tree to terminal nodes distributed within the domain
   - Simple branching vascular network

2. Multi-Input Design:
   - 4-6 inlets distributed around the perimeter/top
   - Each inlet generates its own diverging tree
   - Trees are merged with collision-based connections

EXPERIMENT PLAN (Comparison)
----------------------------
- Seed/embed hepatocytes in the porous domain
- Compare to organoids and to 2D monolayer
- Readouts: viability, function, infection-related metrics

USAGE
-----
    # Generate single-input variant
    python terminal_venule_insert.py --variant single --output-dir ./output

    # Generate multi-input variant with 6 inlets
    python terminal_venule_insert.py --variant multi --num-inlets 6 --output-dir ./output

    # Generate both variants
    python terminal_venule_insert.py --variant both --output-dir ./output

OUTPUT FILES
------------
For each variant, the following files are generated:
- {variant}_vascular_network.stl: The vascular channel network mesh
- {variant}_scaffold_with_voids.stl: Porous scaffold with channels carved as voids
- {variant}_design_spec.json: The design specification used
- {variant}_generation_report.json: Detailed generation metrics and validation results

Author: Generated by Agentic Organ Generation System
"""

import sys
import os
import json
import time
import math
import copy
import argparse
import logging
from pathlib import Path
from typing import Dict, Any, Optional, List, Tuple
from dataclasses import dataclass, asdict

# Add parent directory to path for imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from generation import VascularNetwork
from generation.specs.design_spec import (
    DesignSpec,
    EllipsoidSpec,
    TreeSpec,
    InletSpec,
)
from generation.specs.compile import compile_domain
from generation.adapters.mesh_adapter import to_trimesh
from generation.ops.embedding import embed_tree_as_negative_space
from generation.backends.cco_hybrid_backend import CCOHybridBackend, CCOConfig
from generation.core.types import Point3D, TubeGeometry
from generation.core.result import OperationStatus
from generation.core.network import Node, VesselSegment as Segment
from generation.spatial.grid_index import segment_segment_distance_exact
from generation.optimization import optimize_geometry, NLPConfig, NLPResult
import numpy as np

# Configure logging for verbose output
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)


# =============================================================================
# TUNABLE CONSTRAINTS AND PARAMETERS
# =============================================================================
# All geometric values are in METERS (internal unit system).
# Output STL files are converted to millimeters by default.
#
# These parameters can be adjusted to customize the insert design for different
# experimental requirements, printing capabilities, or biological constraints.
# =============================================================================

@dataclass
class InsertGeometry:
    """
    Geometric parameters for the 48-well compatible insert.
    
    These define the overall shape and size of the scaffold domain.
    Standard 48-well plates have ~11.3mm diameter wells.
    A typical insert should be 6-8mm diameter to fit with clearance.
    
    Attributes
    ----------
    radius : float
        Insert radius in meters. Default: 0.004m (4mm) for 8mm diameter insert.
        Adjust based on well plate specifications and desired clearance.
        
    height : float
        Insert height in meters. Default: 0.003m (3mm).
        Should be tall enough for adequate channel length but short enough
        to fit in well without interfering with imaging.
        
    wall_margin : float
        Margin from insert edge where channels should not extend, in meters.
        Default: 0.0003m (0.3mm). Ensures structural integrity at edges.
    """
    radius: float = 0.004          # 4mm radius = 8mm diameter insert
    height: float = 0.003          # 3mm height
    wall_margin: float = 0.0003    # 0.3mm margin from walls


@dataclass
class VesselDimensions:
    """
    Vessel radius parameters scaled for printability.
    
    Human liver reference values:
    - Sinusoids: 7-15 µm diameter
    - Scaled up significantly for bioprinting compatibility
    
    Attributes
    ----------
    inlet_radius : float
        Radius of inlet vessels in meters.
        Default: 0.0004m (400µm). Root vessel size.
        
    sinusoid_min_radius : float
        Minimum radius for terminal branches in meters.
        Default: 0.0003m (300µm). Smallest printable vessel.
        Scaled from human ~10µm to ~300µm for printability.
        
    taper_factor : float
        Radius reduction factor per generation (Murray's law approximation).
        Default: 0.9. Each child branch is 90% of parent radius.
        Range: 0.7-0.95. Lower = faster tapering, more generations.
    """
    inlet_radius: float = 0.0004            # 400µm - peripheral inlets (must be > BranchingConstraints.min_radius=0.3mm)
    sinusoid_min_radius: float = 0.0003     # 300µm - minimum branch radius (must be >= BranchingConstraints.min_radius)
    taper_factor: float = 0.9               # Radius decay per generation (higher to avoid hitting min_radius too fast)


@dataclass
class CCOParameters:
    """
    CCO (Constrained Constructive Optimization) algorithm parameters for network growth.
    
    These control how the vascular network grows using the CCO hybrid backend,
    which implements Sexton et al.'s accelerated CCO algorithm with:
    - Partial binding optimization
    - Collision avoidance triage
    - Murray's law-based radius scaling
    
    Attributes
    ----------
    num_outlets : int
        Target number of terminal outlets (branch endpoints).
        Default: 20. More outlets = denser network.
        
    murray_exponent : float
        Exponent for Murray's law radius scaling (r_parent^gamma = sum(r_child^gamma)).
        Default: 3.0 (physiological value for blood vessels).
        
    collision_clearance : float
        Minimum clearance between vessel surfaces, in meters.
        Default: 0.0001m (0.1mm). Prevents vessel overlap.
        
    min_segment_length : float
        Minimum allowed segment length, in meters.
        Default: 0.0005m (0.5mm).
        
    max_segment_length : float
        Maximum allowed segment length, in meters.
        Default: 0.010m (10mm).
        
    min_terminal_separation : float
        Minimum distance between terminal outlets, in meters.
        Default: 0.0005m (0.5mm). Prevents clustering.
        
    candidate_edges_k : int
        Number of candidate edges to consider for each insertion.
        Default: 50. Higher = better optimization, slower.
        
    optimization_grid_resolution : int
        Resolution of grid for bifurcation point optimization.
        Default: 10. Higher = finer optimization.
    """
    num_outlets: int = 20                   # Target number of terminal outlets
    murray_exponent: float = 3.0            # Murray's law exponent
    collision_clearance: float = 0.0001     # 0.1mm minimum clearance
    min_segment_length: float = 0.0005      # 0.5mm minimum segment
    max_segment_length: float = 0.010       # 10mm maximum segment
    min_terminal_separation: float = 0.0005 # 0.5mm between terminals
    candidate_edges_k: int = 50             # Candidate edges for optimization
    optimization_grid_resolution: int = 10  # Grid resolution for optimization


@dataclass
class EmbeddingParameters:
    """
    Parameters for embedding vascular network into scaffold domain.
    
    These control the voxelization and boolean operations that create
    the porous scaffold with channels carved as negative space (voids).
    
    Attributes
    ----------
    voxel_pitch : float
        Voxel size for domain discretization, in meters.
        Default: 0.0001m (100µm). Smaller = higher resolution, slower.
        Should be smaller than smallest vessel radius.
        
    shell_thickness : float
        Wall thickness around channels, in meters.
        Default: 0.0003m (300µm). Minimum for structural integrity.
        
    smoothing_iterations : int
        Number of smoothing passes to reduce voxel artifacts.
        Default: 3. Higher = smoother surfaces, slower.
        
    dilation_voxels : int
        Number of voxels to dilate channel volumes.
        Default: 1. Ensures channels are fully open after boolean ops.
    """
    voxel_pitch: float = 0.0001             # 100µm voxel resolution
    shell_thickness: float = 0.0003         # 300µm wall thickness
    smoothing_iterations: int = 3           # Surface smoothing passes
    dilation_voxels: int = 1                # Channel dilation


@dataclass
class MultiInputConfig:
    """
    Configuration for multi-input variant.
    
    Attributes
    ----------
    num_inlets : int
        Number of inlet ports distributed around perimeter.
        Default: 6. Range: 4-8 recommended.
        
    inlet_z_offset : float
        Vertical offset of inlets from top of insert, in meters.
        Default: 0.0005m (0.5mm). Inlets slightly below top surface.
        
    radial_position_fraction : float
        Fraction of radius where inlets are positioned.
        Default: 0.85. Inlets at 85% of radius from center.
        Range: 0.7-0.95. Higher = closer to edge.
    """
    num_inlets: int = 6                     # Number of peripheral inlets
    inlet_z_offset: float = 0.0005          # 0.5mm below top
    radial_position_fraction: float = 0.85  # 85% of radius from center


@dataclass
class NLPParameters:
    """
    NLP (Non-Linear Programming) global geometry optimization parameters.
    
    After CCO generates the initial network topology, NLP optimization refines
    the geometry by optimizing node positions, radii, and pressures to minimize
    total vessel volume while satisfying physiological constraints.
    
    This implements Jessen-style optimization with:
    - Murray's law at bifurcations
    - Poiseuille pressure drop per segment
    - Kirchhoff flow conservation
    - Homogeneous terminal flow distribution
    
    Attributes
    ----------
    enabled : bool
        Whether to apply NLP optimization after CCO generation.
        Default: True. Set to False to skip optimization.
        
    murray_exponent : float
        Exponent for Murray's law radius scaling (r_parent^gamma = sum(r_child^gamma)).
        Default: 3.0 (physiological value for blood vessels).
        
    target_pressure_drop : float
        Target pressure drop across the network, in Pascals.
        Default: 13332.0 Pa (~100 mmHg, typical arterial-venous drop).
        
    viscosity : float
        Blood viscosity in Pa*s.
        Default: 0.0035 Pa*s (typical blood viscosity).
        
    fix_terminal_positions : bool
        Whether to fix terminal node positions during optimization.
        Default: True. Keeps outlet positions fixed.
        
    fix_root_position : bool
        Whether to fix inlet (root) node position during optimization.
        Default: True. Keeps inlet position fixed.
        
    max_iterations : int
        Maximum number of optimization iterations.
        Default: 500. Increase for better convergence on complex networks.
        
    solver_tolerance : float
        Convergence tolerance for the NLP solver.
        Default: 1e-6. Smaller = more precise but slower.
        
    cleanup_degenerate_segments : bool
        Whether to remove degenerate segments (length < diameter) after optimization.
        Default: True. May create trifurcations.
    """
    enabled: bool = True                        # Enable NLP optimization
    murray_exponent: float = 3.0                # Murray's law exponent
    target_pressure_drop: float = 13332.0       # ~100 mmHg pressure drop
    viscosity: float = 0.0035                   # Blood viscosity (Pa*s)
    fix_terminal_positions: bool = True         # Fix terminal positions
    fix_root_position: bool = True              # Fix inlet position
    max_iterations: int = 500                   # Max optimization iterations
    solver_tolerance: float = 1e-6              # Solver convergence tolerance
    cleanup_degenerate_segments: bool = True    # Remove degenerate segments


# =============================================================================
# DEFAULT PARAMETER INSTANCES
# =============================================================================

DEFAULT_INSERT_GEOMETRY = InsertGeometry()
DEFAULT_VESSEL_DIMENSIONS = VesselDimensions()
DEFAULT_CCO_PARAMS = CCOParameters()
DEFAULT_EMBEDDING_PARAMS = EmbeddingParameters()
DEFAULT_MULTI_INPUT_CONFIG = MultiInputConfig()
DEFAULT_NLP_PARAMS = NLPParameters()


# =============================================================================
# VALIDATION FUNCTIONS
# =============================================================================

def validate_parameters(
    geometry: InsertGeometry,
    vessels: VesselDimensions,
    cco_params: CCOParameters,
    embedding: EmbeddingParameters,
) -> List[str]:
    """
    Validate parameter combinations and return list of warnings/errors.
    
    Parameters
    ----------
    geometry : InsertGeometry
        Insert geometry parameters
    vessels : VesselDimensions
        Vessel dimension parameters
    cco_params : CCOParameters
        CCO generation parameters
    embedding : EmbeddingParameters
        Embedding parameters
        
    Returns
    -------
    List[str]
        List of validation warnings/errors. Empty if all valid.
    """
    issues = []
    
    # Check vessel radii relationships
    if vessels.sinusoid_min_radius >= vessels.inlet_radius:
        issues.append(
            f"WARNING: sinusoid_min_radius ({vessels.sinusoid_min_radius*1000:.2f}mm) "
            f">= inlet_radius ({vessels.inlet_radius*1000:.2f}mm). "
            "Terminal branches should be smaller than inlets."
        )
    
    # Check voxel pitch vs vessel radii
    if embedding.voxel_pitch >= vessels.sinusoid_min_radius:
        issues.append(
            f"WARNING: voxel_pitch ({embedding.voxel_pitch*1000:.3f}mm) "
            f">= sinusoid_min_radius ({vessels.sinusoid_min_radius*1000:.3f}mm). "
            "Voxel resolution may be too coarse to capture small vessels."
        )
    
    # Check CCO parameters
    if cco_params.min_segment_length >= cco_params.max_segment_length:
        issues.append(
            f"ERROR: min_segment_length ({cco_params.min_segment_length*1000:.2f}mm) "
            f">= max_segment_length ({cco_params.max_segment_length*1000:.2f}mm). "
            "Minimum segment length must be smaller than maximum."
        )
    
    if cco_params.num_outlets < 1:
        issues.append(
            f"ERROR: num_outlets ({cco_params.num_outlets}) must be at least 1."
        )
    
    # Check geometry constraints
    if geometry.wall_margin >= geometry.radius * 0.5:
        issues.append(
            f"WARNING: wall_margin ({geometry.wall_margin*1000:.2f}mm) "
            f">= 50% of radius ({geometry.radius*1000:.2f}mm). "
            "Wall margin is too large, leaving little space for channels."
        )
    
    return issues


def validate_network(
    network: VascularNetwork,
    variant_name: str,
) -> Dict[str, Any]:
    """
    Validate generated vascular network and return detailed metrics.
    
    Parameters
    ----------
    network : VascularNetwork
        Generated vascular network
    variant_name : str
        Name of the variant for logging
        
    Returns
    -------
    Dict[str, Any]
        Validation results including metrics and any issues found
    """
    logger.info(f"Validating {variant_name} network...")
    
    results = {
        "variant": variant_name,
        "valid": True,
        "issues": [],
        "metrics": {},
    }
    
    # Count node types
    node_counts = {
        "inlet": 0,
        "outlet": 0,
        "terminal": 0,
        "junction": 0,
    }
    for node in network.nodes.values():
        node_type = node.node_type
        if node_type in node_counts:
            node_counts[node_type] += 1
    
    results["metrics"]["node_counts"] = node_counts
    results["metrics"]["total_nodes"] = len(network.nodes)
    results["metrics"]["total_segments"] = len(network.segments)
    
    logger.info(f"  Total nodes: {len(network.nodes)}")
    logger.info(f"  Total segments: {len(network.segments)}")
    logger.info(f"  Node breakdown: {node_counts}")
    
    # Check for minimum network complexity
    if len(network.segments) < 5:
        results["issues"].append(
            f"WARNING: Network has only {len(network.segments)} segments. "
            "Expected more complex branching structure."
        )
        results["valid"] = False
    
    # Check for inlets and outlets/terminals
    # Note: CCO backend creates 'terminal' nodes instead of 'outlet' nodes
    # For CCO-based generation, terminals serve as the effective outlets
    if node_counts["inlet"] == 0:
        results["issues"].append("ERROR: No inlet nodes found in network.")
        results["valid"] = False
    
    if node_counts["outlet"] == 0 and node_counts["terminal"] == 0:
        results["issues"].append("ERROR: No outlet or terminal nodes found in network.")
        results["valid"] = False
    
    # Compute segment length statistics
    segment_lengths = []
    segment_radii = []
    for segment in network.segments.values():
        length = segment.geometry.length()
        segment_lengths.append(length)
        segment_radii.append(segment.geometry.mean_radius())
    
    if segment_lengths:
        results["metrics"]["segment_length_stats"] = {
            "min_mm": min(segment_lengths) * 1000,
            "max_mm": max(segment_lengths) * 1000,
            "mean_mm": sum(segment_lengths) / len(segment_lengths) * 1000,
        }
        results["metrics"]["segment_radius_stats"] = {
            "min_mm": min(segment_radii) * 1000,
            "max_mm": max(segment_radii) * 1000,
            "mean_mm": sum(segment_radii) / len(segment_radii) * 1000,
        }
        
        logger.info(f"  Segment lengths: min={min(segment_lengths)*1000:.3f}mm, "
                   f"max={max(segment_lengths)*1000:.3f}mm, "
                   f"mean={sum(segment_lengths)/len(segment_lengths)*1000:.3f}mm")
        logger.info(f"  Segment radii: min={min(segment_radii)*1000:.3f}mm, "
                   f"max={max(segment_radii)*1000:.3f}mm, "
                   f"mean={sum(segment_radii)/len(segment_radii)*1000:.3f}mm")
    
    # Log any issues
    for issue in results["issues"]:
        if issue.startswith("ERROR"):
            logger.error(f"  {issue}")
        else:
            logger.warning(f"  {issue}")
    
    if results["valid"]:
        logger.info(f"  Validation PASSED for {variant_name}")
    else:
        logger.warning(f"  Validation FAILED for {variant_name}")
    
    return results


# =============================================================================
# DESIGN SPECIFICATION CREATION
# =============================================================================

def create_single_input_spec(
    geometry: InsertGeometry = DEFAULT_INSERT_GEOMETRY,
    vessels: VesselDimensions = DEFAULT_VESSEL_DIMENSIONS,
    cco_params: CCOParameters = DEFAULT_CCO_PARAMS,
    seed: int = 42,
) -> DesignSpec:
    """
    Create design specification for single-input vascular insert.
    
    The CCO backend generates a DIVERGING tree from the inlet to randomly
    sampled terminal points within the domain.
    
    This creates a diverging tree topology with:
    - One inlet at the perimeter (top edge) - root of the tree
    - Terminal nodes randomly distributed within the domain
    
    Parameters
    ----------
    geometry : InsertGeometry
        Insert geometry parameters
    vessels : VesselDimensions
        Vessel dimension parameters
    cco_params : CCOParameters
        CCO generation parameters
    seed : int
        Random seed for reproducibility
        
    Returns
    -------
    DesignSpec
        Complete design specification for generation
    """
    logger.info("Creating single-input design specification...")
    
    domain = EllipsoidSpec(
        type="ellipsoid",
        center=(0.0, 0.0, geometry.height / 2),
        semi_axes=(geometry.radius, geometry.radius, geometry.height / 2),
    )
    
    logger.info(f"  Domain: ellipsoid with semi-axes ({geometry.radius*1000:.1f}mm, "
               f"{geometry.radius*1000:.1f}mm, {geometry.height/2*1000:.1f}mm)")
    
    domain_center_z = geometry.height / 2
    inlet_x = geometry.radius * 0.7
    inlet_z = domain_center_z + (geometry.height / 2) * 0.5
    inlet = InletSpec(
        position=(inlet_x, 0.0, inlet_z),
        radius=vessels.inlet_radius,
        vessel_type="venous",
    )
    
    logger.info(f"  Inlet: position=({inlet_x*1000:.2f}, 0, {inlet_z*1000:.2f})mm, "
               f"radius={vessels.inlet_radius*1000:.2f}mm")
    
    logger.info(f"  CCO params: num_outlets={cco_params.num_outlets}, "
               f"murray_exponent={cco_params.murray_exponent}")
    
    tree = TreeSpec(
        inlets=[inlet],
        outlets=[],
        colonization=None,
    )
    
    spec = DesignSpec(
        domain=domain,
        tree=tree,
        seed=seed,
        metadata={
            "design_type": "vascular_insert",
            "variant": "single_input",
            "description": "Single-input diverging vascular tree for 48-well insert (CCO)",
            "generation_method": "cco_hybrid",
        },
        output_units="mm",
    )
    
    logger.info("  Single-input design specification created successfully")
    
    return spec


def create_multi_input_spec(
    geometry: InsertGeometry = DEFAULT_INSERT_GEOMETRY,
    vessels: VesselDimensions = DEFAULT_VESSEL_DIMENSIONS,
    cco_params: CCOParameters = DEFAULT_CCO_PARAMS,
    multi_config: MultiInputConfig = DEFAULT_MULTI_INPUT_CONFIG,
    seed: int = 42,
) -> DesignSpec:
    """
    Create design specification for multi-input vascular insert.
    
    The CCO backend generates DIVERGING trees from each inlet to randomly
    sampled terminal points within the domain. Each inlet generates its own
    tree, and trees are merged with collision-based connections.
    
    This creates multiple diverging trees with:
    - Multiple inlets (4-6) distributed radially around the perimeter - each is a tree root
    - Terminal nodes randomly distributed within the domain for each tree
    - Inter-tree connections created at collision points
    
    Parameters
    ----------
    geometry : InsertGeometry
        Insert geometry parameters
    vessels : VesselDimensions
        Vessel dimension parameters
    cco_params : CCOParameters
        CCO generation parameters
    multi_config : MultiInputConfig
        Multi-input specific configuration
    seed : int
        Random seed for reproducibility
        
    Returns
    -------
    DesignSpec
        Complete design specification for generation
    """
    logger.info(f"Creating multi-input design specification ({multi_config.num_inlets} inlets)...")
    
    domain = EllipsoidSpec(
        type="ellipsoid",
        center=(0.0, 0.0, geometry.height / 2),
        semi_axes=(geometry.radius, geometry.radius, geometry.height / 2),
    )
    
    logger.info(f"  Domain: ellipsoid with semi-axes ({geometry.radius*1000:.1f}mm, "
               f"{geometry.radius*1000:.1f}mm, {geometry.height/2*1000:.1f}mm)")
    
    inlets = []
    domain_center_z = geometry.height / 2
    inlet_radial_pos = geometry.radius * 0.6
    inlet_z = domain_center_z + (geometry.height / 2) * 0.4
    
    for i in range(multi_config.num_inlets):
        angle = 2 * math.pi * i / multi_config.num_inlets
        inlet_x = inlet_radial_pos * math.cos(angle)
        inlet_y = inlet_radial_pos * math.sin(angle)
        
        inlet = InletSpec(
            position=(inlet_x, inlet_y, inlet_z),
            radius=vessels.inlet_radius,
            vessel_type="venous",
        )
        inlets.append(inlet)
        
        logger.info(f"  Inlet {i+1}: position=({inlet_x*1000:.2f}, {inlet_y*1000:.2f}, "
                   f"{inlet_z*1000:.2f})mm, radius={vessels.inlet_radius*1000:.2f}mm")
    
    logger.info(f"  CCO params: num_outlets={cco_params.num_outlets}, "
               f"murray_exponent={cco_params.murray_exponent}")
    
    tree = TreeSpec(
        inlets=inlets,
        outlets=[],
        colonization=None,
    )
    
    spec = DesignSpec(
        domain=domain,
        tree=tree,
        seed=seed,
        metadata={
            "design_type": "vascular_insert",
            "variant": "multi_input",
            "num_inlets": multi_config.num_inlets,
            "description": f"Multi-input ({multi_config.num_inlets} inlets) diverging vascular trees (CCO)",
            "generation_method": "cco_hybrid",
        },
        output_units="mm",
    )
    
    logger.info("  Multi-input design specification created successfully")
    
    return spec


# =============================================================================
# INTER-TREE COLLISION DETECTION AND MERGING
# =============================================================================

def detect_inter_tree_collisions(
    main_network: VascularNetwork,
    new_tree: VascularNetwork,
    min_clearance: float = 0.0005,
) -> List[Dict[str, Any]]:
    """
    Detect collisions between segments of two separate networks.
    
    This function finds all segment pairs where a segment from the new tree
    is too close to a segment from the main network.
    
    Parameters
    ----------
    main_network : VascularNetwork
        The existing network to check against
    new_tree : VascularNetwork
        The new tree being merged
    min_clearance : float
        Minimum required clearance between segment surfaces (meters)
        
    Returns
    -------
    List[Dict[str, Any]]
        List of collision records containing:
        - main_seg_id: segment ID in main network
        - new_seg_id: segment ID in new tree
        - clearance: actual clearance (negative = overlapping)
        - closest_point_main: closest point on main segment
        - closest_point_new: closest point on new segment
    """
    collisions = []
    
    for main_seg in main_network.segments.values():
        main_start_node = main_network.get_node(main_seg.start_node_id)
        main_end_node = main_network.get_node(main_seg.end_node_id)
        if main_start_node is None or main_end_node is None:
            continue
        
        main_p1 = main_start_node.position.to_array()
        main_p2 = main_end_node.position.to_array()
        main_radius = main_seg.geometry.mean_radius()
        
        for new_seg in new_tree.segments.values():
            new_start_node = new_tree.get_node(new_seg.start_node_id)
            new_end_node = new_tree.get_node(new_seg.end_node_id)
            if new_start_node is None or new_end_node is None:
                continue
            
            new_p1 = new_start_node.position.to_array()
            new_p2 = new_end_node.position.to_array()
            new_radius = new_seg.geometry.mean_radius()
            
            # Compute centerline distance
            centerline_dist = segment_segment_distance_exact(main_p1, main_p2, new_p1, new_p2)
            
            # Compute clearance (surface-to-surface distance)
            clearance = centerline_dist - main_radius - new_radius
            
            if clearance < min_clearance:
                # Find closest points on each segment for connection
                closest_main, closest_new = _find_closest_points_on_segments(
                    main_p1, main_p2, new_p1, new_p2
                )
                
                collisions.append({
                    "main_seg_id": main_seg.id,
                    "new_seg_id": new_seg.id,
                    "clearance": clearance,
                    "centerline_distance": centerline_dist,
                    "closest_point_main": closest_main,
                    "closest_point_new": closest_new,
                    "main_radius": main_radius,
                    "new_radius": new_radius,
                })
    
    return collisions


def _find_closest_points_on_segments(
    p1: np.ndarray, p2: np.ndarray,
    q1: np.ndarray, q2: np.ndarray,
) -> Tuple[np.ndarray, np.ndarray]:
    """
    Find the closest points on two line segments.
    
    Returns the points on each segment that are closest to each other.
    """
    d1 = p2 - p1  # Direction of segment 1
    d2 = q2 - q1  # Direction of segment 2
    r = p1 - q1
    
    a = np.dot(d1, d1)  # |d1|^2
    e = np.dot(d2, d2)  # |d2|^2
    f = np.dot(d2, r)
    
    EPSILON = 1e-10
    
    # Check if both segments are degenerate (points)
    if a < EPSILON and e < EPSILON:
        return p1.copy(), q1.copy()
    
    # Check if segment 1 is degenerate (point)
    if a < EPSILON:
        s = 0.0
        t = np.clip(f / e, 0.0, 1.0)
    else:
        c = np.dot(d1, r)
        
        # Check if segment 2 is degenerate (point)
        if e < EPSILON:
            t = 0.0
            s = np.clip(-c / a, 0.0, 1.0)
        else:
            # General non-degenerate case
            b = np.dot(d1, d2)
            denom = a * e - b * b  # Always >= 0
            
            # If segments are not parallel, compute closest point on line 1 to line 2
            if denom > EPSILON:
                s = np.clip((b * f - c * e) / denom, 0.0, 1.0)
            else:
                # Segments are parallel, pick arbitrary s
                s = 0.0
            
            # Compute point on line 2 closest to S1(s)
            t = (b * s + f) / e
            
            # If t is outside [0,1], clamp and recompute s
            if t < 0.0:
                t = 0.0
                s = np.clip(-c / a, 0.0, 1.0)
            elif t > 1.0:
                t = 1.0
                s = np.clip((b - c) / a, 0.0, 1.0)
    
    # Compute closest points
    closest_p = p1 + s * d1
    closest_q = q1 + t * d2
    
    return closest_p, closest_q


def merge_trees_with_collision_connections(
    main_network: VascularNetwork,
    new_tree: VascularNetwork,
    collisions: List[Dict[str, Any]],
    connection_radius: float = 0.0003,
    max_connections: int = 3,
) -> Dict[str, Any]:
    """
    Merge a new tree into the main network, creating connections at collision points.
    
    This function:
    1. Copies all nodes and segments from new_tree to main_network
    2. For each collision, creates a connection segment between the closest points
    
    Parameters
    ----------
    main_network : VascularNetwork
        The main network to merge into (modified in place)
    new_tree : VascularNetwork
        The new tree to merge
    collisions : List[Dict[str, Any]]
        Collision records from detect_inter_tree_collisions
    connection_radius : float
        Radius for connection segments (meters)
    max_connections : int
        Maximum number of connections to create
        
    Returns
    -------
    Dict[str, Any]
        Merge results containing:
        - node_id_map: mapping from old to new node IDs
        - nodes_added: number of nodes added
        - segments_added: number of segments added
        - connections_created: number of connection segments created
    """
    # First, copy all nodes from new_tree to main_network
    node_id_map = {}
    for old_node in new_tree.nodes.values():
        new_node_id = main_network.id_gen.next_id()
        new_node = Node(
            id=new_node_id,
            position=copy.deepcopy(old_node.position),
            node_type=old_node.node_type,
            vessel_type=old_node.vessel_type,
            attributes=old_node.attributes.copy(),
        )
        main_network.add_node(new_node)
        node_id_map[old_node.id] = new_node_id
    
    # Copy all segments from new_tree to main_network
    seg_id_map = {}
    for old_seg in new_tree.segments.values():
        new_seg_id = main_network.id_gen.next_id()
        new_seg = Segment(
            id=new_seg_id,
            start_node_id=node_id_map[old_seg.start_node_id],
            end_node_id=node_id_map[old_seg.end_node_id],
            geometry=copy.deepcopy(old_seg.geometry),
            vessel_type=old_seg.vessel_type,
            attributes=old_seg.attributes.copy(),
        )
        main_network.add_segment(new_seg)
        seg_id_map[old_seg.id] = new_seg_id
    
    # Sort collisions by clearance (most severe first) and limit connections
    sorted_collisions = sorted(collisions, key=lambda c: c["clearance"])
    collisions_to_connect = sorted_collisions[:max_connections]
    
    connections_created = 0
    used_main_segs = set()
    used_new_segs = set()
    
    for collision in collisions_to_connect:
        main_seg_id = collision["main_seg_id"]
        new_seg_id = collision["new_seg_id"]
        
        # Avoid creating multiple connections to the same segment
        if main_seg_id in used_main_segs or new_seg_id in used_new_segs:
            continue
        
        # Get the closest points
        closest_main = collision["closest_point_main"]
        closest_new = collision["closest_point_new"]
        
        # Create junction nodes at the closest points
        main_junction_id = main_network.id_gen.next_id()
        main_junction = Node(
            id=main_junction_id,
            position=Point3D.from_array(closest_main),
            node_type="junction",
            vessel_type=main_network.segments[main_seg_id].vessel_type,
            attributes={"connection_point": True},
        )
        main_network.add_node(main_junction)
        
        new_junction_id = main_network.id_gen.next_id()
        new_junction = Node(
            id=new_junction_id,
            position=Point3D.from_array(closest_new),
            node_type="junction",
            vessel_type=main_network.segments[seg_id_map[new_seg_id]].vessel_type,
            attributes={"connection_point": True},
        )
        main_network.add_node(new_junction)
        
        # Split the main segment at the junction point
        _split_segment_at_node(main_network, main_seg_id, main_junction_id)
        
        # Split the new segment (now in main_network) at the junction point
        _split_segment_at_node(main_network, seg_id_map[new_seg_id], new_junction_id)
        
        # Create connection segment between the two junction nodes
        connection_id = main_network.id_gen.next_id()
        connection_geometry = TubeGeometry(
            start=main_junction.position,
            end=new_junction.position,
            radius_start=connection_radius,
            radius_end=connection_radius,
        )
        connection_seg = Segment(
            id=connection_id,
            start_node_id=main_junction_id,
            end_node_id=new_junction_id,
            geometry=connection_geometry,
            vessel_type="connection",
            attributes={"segment_kind": "inter_tree_connection"},
        )
        main_network.add_segment(connection_seg)
        
        connections_created += 1
        used_main_segs.add(main_seg_id)
        used_new_segs.add(new_seg_id)
        
        logger.info(f"    Created connection between trees at collision point "
                   f"(clearance={collision['clearance']*1000:.3f}mm)")
    
    return {
        "node_id_map": node_id_map,
        "seg_id_map": seg_id_map,
        "nodes_added": len(node_id_map),
        "segments_added": len(seg_id_map),
        "connections_created": connections_created,
    }


def _split_segment_at_node(
    network: VascularNetwork,
    segment_id: int,
    junction_node_id: int,
) -> Tuple[int, int]:
    """
    Split a segment at a junction node, creating two new segments.
    
    The original segment is removed and replaced with two segments:
    - start_node -> junction_node
    - junction_node -> end_node
    
    Parameters
    ----------
    network : VascularNetwork
        Network containing the segment
    segment_id : int
        ID of segment to split
    junction_node_id : int
        ID of junction node to split at
        
    Returns
    -------
    Tuple[int, int]
        IDs of the two new segments
    """
    segment = network.segments.get(segment_id)
    if segment is None:
        return (-1, -1)
    
    junction_node = network.get_node(junction_node_id)
    start_node = network.get_node(segment.start_node_id)
    end_node = network.get_node(segment.end_node_id)
    
    if junction_node is None or start_node is None or end_node is None:
        return (-1, -1)
    
    # Compute interpolation parameter t for radius interpolation
    total_length = start_node.position.distance_to(end_node.position)
    if total_length < 1e-10:
        t = 0.5
    else:
        dist_to_junction = start_node.position.distance_to(junction_node.position)
        t = dist_to_junction / total_length
    
    # Interpolate radius at junction point
    r_start = segment.geometry.radius_start
    r_end = segment.geometry.radius_end
    r_junction = r_start + t * (r_end - r_start)
    
    # Create first segment: start -> junction
    seg1_id = network.id_gen.next_id()
    seg1_geometry = TubeGeometry(
        start=start_node.position,
        end=junction_node.position,
        radius_start=r_start,
        radius_end=r_junction,
    )
    seg1 = Segment(
        id=seg1_id,
        start_node_id=segment.start_node_id,
        end_node_id=junction_node_id,
        geometry=seg1_geometry,
        vessel_type=segment.vessel_type,
        attributes=segment.attributes.copy(),
    )
    
    # Create second segment: junction -> end
    seg2_id = network.id_gen.next_id()
    seg2_geometry = TubeGeometry(
        start=junction_node.position,
        end=end_node.position,
        radius_start=r_junction,
        radius_end=r_end,
    )
    seg2 = Segment(
        id=seg2_id,
        start_node_id=junction_node_id,
        end_node_id=segment.end_node_id,
        geometry=seg2_geometry,
        vessel_type=segment.vessel_type,
        attributes=segment.attributes.copy(),
    )
    
    # Remove original segment and add new segments
    network.remove_segment(segment_id)
    network.add_segment(seg1)
    network.add_segment(seg2)
    
    return (seg1_id, seg2_id)


# =============================================================================
# CUSTOM NETWORK GENERATION (using CCO hybrid backend)
# =============================================================================

def generate_network_from_spec(
    spec: DesignSpec,
    vessels: VesselDimensions = DEFAULT_VESSEL_DIMENSIONS,
    cco_params: CCOParameters = DEFAULT_CCO_PARAMS,
    nlp_params: NLPParameters = DEFAULT_NLP_PARAMS,
) -> VascularNetwork:
    """
    Generate vascular network from design specification using CCO hybrid backend
    with optional global NLP geometry optimization.
    
    This function uses a two-stage approach:
    
    Stage 1 - CCO Generation:
    Uses the CCOHybridBackend which implements Sexton et al.'s accelerated CCO
    algorithm with:
    - Partial binding optimization for fast bifurcation optimization
    - Collision avoidance triage (cheap filter then expensive test)
    - Murray's law-based radius scaling with demand-based splitting
    - Local radius-at-split interpolation for correct bifurcation behavior
    
    Stage 2 - Global NLP Optimization (optional):
    Applies Jessen-style NLP optimization to refine the network geometry by
    optimizing node positions, radii, and pressures to minimize total vessel
    volume while satisfying physiological constraints:
    - Murray's law at bifurcations
    - Poiseuille pressure drop per segment
    - Kirchhoff flow conservation
    - Homogeneous terminal flow distribution
    
    For multi-inlet specifications, this generates a separate CCO tree for each
    inlet and merges them into a single network. Each inlet gets an equal share
    of the total target outlets.
    
    Parameters
    ----------
    spec : DesignSpec
        Design specification with domain, tree, and inlet/outlet settings
    vessels : VesselDimensions
        Vessel dimension parameters (in meters)
    cco_params : CCOParameters
        CCO algorithm parameters
    nlp_params : NLPParameters
        NLP global geometry optimization parameters
        
    Returns
    -------
    VascularNetwork
        Generated vascular network (optimized if nlp_params.enabled is True)
    """
    logger.info("Generating network using CCO hybrid backend...")
    
    # Compile domain from spec
    domain = compile_domain(spec.domain)
    
    # Get tree spec
    tree = spec.tree
    if tree is None:
        raise ValueError("DesignSpec must have a tree specification")
    
    if not tree.inlets:
        raise ValueError("DesignSpec must have at least one inlet")
    
    # Create CCO configuration
    config = CCOConfig(
        seed=spec.seed,
        murray_exponent=cco_params.murray_exponent,
        collision_clearance=cco_params.collision_clearance,
        min_segment_length=cco_params.min_segment_length,
        max_segment_length=cco_params.max_segment_length,
        min_terminal_separation=cco_params.min_terminal_separation,
        candidate_edges_k=cco_params.candidate_edges_k,
        optimization_grid_resolution=cco_params.optimization_grid_resolution,
        collision_check_enabled=True,
        use_partial_binding=True,
        use_collision_triage=True,
    )
    
    logger.info(f"  CCO config: murray_exponent={config.murray_exponent}, "
               f"collision_clearance={config.collision_clearance*1000:.3f}mm")
    
    # Create CCO backend
    backend = CCOHybridBackend()
    
    num_inlets = len(tree.inlets)
    
    if num_inlets == 1:
        # Single inlet case - generate one tree
        inlet_spec = tree.inlets[0]
        inlet_position = np.array(inlet_spec.position)
        inlet_radius = inlet_spec.radius
        vessel_type = inlet_spec.vessel_type
        
        logger.info(f"  Single inlet: position=({inlet_position[0]*1000:.2f}, "
                   f"{inlet_position[1]*1000:.2f}, {inlet_position[2]*1000:.2f})mm, "
                   f"radius={inlet_radius*1000:.2f}mm")
        logger.info(f"  Target outlets: {cco_params.num_outlets}")
        
        # Generate network using CCO backend
        logger.info(f"  Running CCO generation (num_outlets={cco_params.num_outlets})...")
        network = backend.generate(
            domain=domain,
            num_outlets=cco_params.num_outlets,
            inlet_position=inlet_position,
            inlet_radius=inlet_radius,
            vessel_type=vessel_type,
            config=config,
            rng_seed=spec.seed,
        )
    else:
        # Multi-inlet case - generate separate trees and merge
        logger.info(f"  Multi-inlet mode: {num_inlets} inlets")
        
        # Distribute outlets evenly among inlets
        outlets_per_inlet = max(1, cco_params.num_outlets // num_inlets)
        logger.info(f"  Target outlets per inlet: {outlets_per_inlet}")
        
        # Generate first tree (this becomes the base network)
        inlet_spec = tree.inlets[0]
        inlet_position = np.array(inlet_spec.position)
        inlet_radius = inlet_spec.radius
        vessel_type = inlet_spec.vessel_type
        
        logger.info(f"  Inlet 1: position=({inlet_position[0]*1000:.2f}, "
                   f"{inlet_position[1]*1000:.2f}, {inlet_position[2]*1000:.2f})mm")
        
        network = backend.generate(
            domain=domain,
            num_outlets=outlets_per_inlet,
            inlet_position=inlet_position,
            inlet_radius=inlet_radius,
            vessel_type=vessel_type,
            config=config,
            rng_seed=spec.seed,
        )
        
        # Track total connections created across all tree merges
        total_connections = 0
        
        # Generate additional trees for remaining inlets and merge with collision handling
        for i, inlet_spec in enumerate(tree.inlets[1:], start=2):
            inlet_position = np.array(inlet_spec.position)
            inlet_radius = inlet_spec.radius
            vessel_type = inlet_spec.vessel_type
            
            logger.info(f"  Inlet {i}: position=({inlet_position[0]*1000:.2f}, "
                       f"{inlet_position[1]*1000:.2f}, {inlet_position[2]*1000:.2f})mm")
            
            # Generate tree for this inlet with different seed
            tree_network = backend.generate(
                domain=domain,
                num_outlets=outlets_per_inlet,
                inlet_position=inlet_position,
                inlet_radius=inlet_radius,
                vessel_type=vessel_type,
                config=config,
                rng_seed=(spec.seed + i) if spec.seed else None,
            )
            
            # Detect collisions between the new tree and existing network
            collisions = detect_inter_tree_collisions(
                main_network=network,
                new_tree=tree_network,
                min_clearance=cco_params.collision_clearance,
            )
            
            if collisions:
                logger.info(f"    Detected {len(collisions)} collisions with existing network")
                
                # Merge with collision connections
                merge_result = merge_trees_with_collision_connections(
                    main_network=network,
                    new_tree=tree_network,
                    collisions=collisions,
                    connection_radius=vessels.sinusoid_min_radius,
                    max_connections=min(3, len(collisions)),  # Limit connections per tree
                )
                
                total_connections += merge_result["connections_created"]
                logger.info(f"    Merged tree {i}: {merge_result['nodes_added']} nodes, "
                           f"{merge_result['segments_added']} segments, "
                           f"{merge_result['connections_created']} connections")
            else:
                # No collisions - simple merge without connections
                logger.info(f"    No collisions detected - merging without connections")
                
                # Simple merge: copy nodes and segments
                node_id_map = {}
                for old_node in tree_network.nodes.values():
                    new_node_id = network.id_gen.next_id()
                    new_node = Node(
                        id=new_node_id,
                        position=copy.deepcopy(old_node.position),
                        node_type=old_node.node_type,
                        vessel_type=old_node.vessel_type,
                        attributes=old_node.attributes.copy(),
                    )
                    network.add_node(new_node)
                    node_id_map[old_node.id] = new_node_id
                
                for old_seg in tree_network.segments.values():
                    new_seg_id = network.id_gen.next_id()
                    new_seg = Segment(
                        id=new_seg_id,
                        start_node_id=node_id_map[old_seg.start_node_id],
                        end_node_id=node_id_map[old_seg.end_node_id],
                        geometry=copy.deepcopy(old_seg.geometry),
                        vessel_type=old_seg.vessel_type,
                        attributes=old_seg.attributes.copy(),
                    )
                    network.add_segment(new_seg)
                
                logger.info(f"    Merged tree {i}: {len(tree_network.nodes)} nodes, "
                           f"{len(tree_network.segments)} segments")
        
        if total_connections > 0:
            logger.info(f"  Total inter-tree connections created: {total_connections}")
    
    # Log network statistics
    logger.info(f"  CCO generation complete!")
    logger.info(f"  Network: {len(network.nodes)} nodes, {len(network.segments)} segments")
    
    # Count node types
    node_counts = {"inlet": 0, "outlet": 0, "terminal": 0, "junction": 0}
    for node in network.nodes.values():
        if node.node_type in node_counts:
            node_counts[node.node_type] += 1
    logger.info(f"  Node types: {node_counts}")
    
    # Stage 2: Apply global NLP geometry optimization (if enabled)
    if nlp_params.enabled:
        logger.info("-" * 50)
        logger.info("STAGE 2: Applying global NLP geometry optimization...")
        logger.info("-" * 50)
        
        # Create NLP configuration from parameters
        nlp_config = NLPConfig(
            murray_exponent=nlp_params.murray_exponent,
            target_pressure_drop=nlp_params.target_pressure_drop,
            viscosity=nlp_params.viscosity,
            fix_terminal_positions=nlp_params.fix_terminal_positions,
            fix_root_position=nlp_params.fix_root_position,
            max_iterations=nlp_params.max_iterations,
            solver_tolerance=nlp_params.solver_tolerance,
            cleanup_degenerate_segments=nlp_params.cleanup_degenerate_segments,
        )
        
        logger.info(f"  NLP config: murray_exponent={nlp_config.murray_exponent}, "
                   f"target_pressure_drop={nlp_config.target_pressure_drop:.0f}Pa, "
                   f"max_iterations={nlp_config.max_iterations}")
        
        # Run NLP optimization
        nlp_start = time.time()
        nlp_result = optimize_geometry(network, nlp_config)
        nlp_time = time.time() - nlp_start
        
        if nlp_result.success:
            logger.info(f"  NLP optimization successful!")
            logger.info(f"  Volume reduction: {nlp_result.volume_reduction*100:.1f}%")
            logger.info(f"  Initial volume: {nlp_result.initial_volume*1e9:.3f} mm^3")
            logger.info(f"  Final volume: {nlp_result.final_volume*1e9:.3f} mm^3")
            logger.info(f"  Iterations: {nlp_result.iterations}")
            logger.info(f"  Optimization time: {nlp_time:.2f}s")
            
            if nlp_result.segments_removed > 0:
                logger.info(f"  Degenerate segments removed: {nlp_result.segments_removed}")
            if nlp_result.trifurcations_created > 0:
                logger.info(f"  Trifurcations created: {nlp_result.trifurcations_created}")
            
            for warning in nlp_result.warnings:
                logger.warning(f"  NLP warning: {warning}")
        else:
            logger.warning(f"  NLP optimization did not converge")
            for error in nlp_result.errors:
                logger.error(f"  NLP error: {error}")
            for warning in nlp_result.warnings:
                logger.warning(f"  NLP warning: {warning}")
        
        # Log updated network statistics
        logger.info(f"  Post-NLP network: {len(network.nodes)} nodes, {len(network.segments)} segments")
    else:
        logger.info("  NLP optimization disabled, skipping Stage 2")
    
    return network


# =============================================================================
# GENERATION FUNCTIONS
# =============================================================================

def generate_insert(
    spec: DesignSpec,
    variant_name: str,
    output_dir: str,
    embedding_params: EmbeddingParameters = DEFAULT_EMBEDDING_PARAMS,
    skip_embedding: bool = False,
    geometry: InsertGeometry = DEFAULT_INSERT_GEOMETRY,
    vessels: VesselDimensions = DEFAULT_VESSEL_DIMENSIONS,
    cco_params: CCOParameters = DEFAULT_CCO_PARAMS,
) -> Dict[str, Any]:
    """
    Generate terminal-venule insert from design specification.
    
    This function:
    1. Validates input parameters
    2. Generates vascular network via CCO hybrid backend with optional NLP optimization
    3. Validates the generated network
    4. Exports vascular mesh to STL
    5. Creates scaffold with channels as voids (optional)
    6. Saves all artifacts and reports
    
    Parameters
    ----------
    spec : DesignSpec
        Design specification
    variant_name : str
        Name for output files (e.g., "single_input", "multi_input")
    output_dir : str
        Output directory path
    embedding_params : EmbeddingParameters
        Parameters for scaffold embedding
    skip_embedding : bool
        If True, skip the embedding step (faster for testing)
    geometry : InsertGeometry
        Insert geometry parameters (for report recording)
    vessels : VesselDimensions
        Vessel dimension parameters (for report recording)
    cco_params : CCOParameters
        CCO algorithm parameters (for report recording)
        
    Returns
    -------
    Dict[str, Any]
        Results dictionary containing:
        - success: bool
        - network: VascularNetwork
        - validation: validation results
        - paths: dict of output file paths
        - timing: dict of timing information
        - errors: list of any errors encountered
    """
    logger.info("=" * 70)
    logger.info(f"GENERATING {variant_name.upper()} TERMINAL-VENULE INSERT")
    logger.info("=" * 70)
    
    results = {
        "success": False,
        "variant": variant_name,
        "network": None,
        "validation": None,
        "paths": {},
        "timing": {},
        "errors": [],
    }
    
    # Create output directory
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    logger.info(f"Output directory: {output_path.absolute()}")
    
    # Save design spec
    spec_path = output_path / f"{variant_name}_design_spec.json"
    spec.to_json(str(spec_path))
    results["paths"]["design_spec"] = str(spec_path)
    logger.info(f"Saved design specification to: {spec_path}")
    
    # Step 1: Generate vascular network
    # Using custom generate_network_from_spec to handle unit mismatch
    # (BranchingConstraints uses mm but network operations use meters)
    logger.info("-" * 50)
    logger.info("STEP 1: Generating vascular network...")
    logger.info("-" * 50)
    
    gen_start = time.time()
    try:
        # Use custom generation function with proper constraints in meters
        network = generate_network_from_spec(spec)
        results["network"] = network
        gen_time = time.time() - gen_start
        results["timing"]["network_generation"] = gen_time
        logger.info(f"Network generation completed in {gen_time:.2f} seconds")
    except Exception as e:
        error_msg = f"Network generation failed: {e}"
        logger.error(error_msg)
        results["errors"].append(error_msg)
        return results
    
    # Step 2: Validate network
    logger.info("-" * 50)
    logger.info("STEP 2: Validating generated network...")
    logger.info("-" * 50)
    
    validation = validate_network(network, variant_name)
    results["validation"] = validation
    
    if not validation["valid"]:
        logger.warning("Network validation found issues (see above)")
    
    # Step 3: Export vascular mesh
    logger.info("-" * 50)
    logger.info("STEP 3: Exporting vascular network mesh...")
    logger.info("-" * 50)
    
    mesh_start = time.time()
    try:
        mesh_result = to_trimesh(
            network,
            mode="fast",
            radial_resolution=12,
            include_caps=True,
            include_node_spheres=True,
        )
        
        if mesh_result.is_success():
            mesh = mesh_result.metadata["mesh"]
            mesh_path = output_path / f"{variant_name}_vascular_network.stl"
            mesh.export(str(mesh_path))
            results["paths"]["vascular_mesh"] = str(mesh_path)
            
            mesh_time = time.time() - mesh_start
            results["timing"]["mesh_export"] = mesh_time
            
            logger.info(f"Vascular mesh exported to: {mesh_path}")
            logger.info(f"  Vertices: {len(mesh.vertices)}")
            logger.info(f"  Faces: {len(mesh.faces)}")
            logger.info(f"  Watertight: {mesh.is_watertight}")
            logger.info(f"  Export time: {mesh_time:.2f} seconds")
        else:
            error_msg = f"Mesh export failed: {mesh_result.message}"
            logger.error(error_msg)
            results["errors"].append(error_msg)
    except Exception as e:
        error_msg = f"Mesh export error: {e}"
        logger.error(error_msg)
        results["errors"].append(error_msg)
    
    # Step 4: Create scaffold with voids (optional)
    if not skip_embedding and "vascular_mesh" in results["paths"]:
        logger.info("-" * 50)
        logger.info("STEP 4: Creating porous scaffold with channel voids...")
        logger.info("-" * 50)
        
        embed_start = time.time()
        try:
            # Create runtime domain for embedding
            from generation.specs.compile import compile_domain
            runtime_domain = compile_domain(spec.domain)
            
            logger.info(f"  Voxel pitch: {embedding_params.voxel_pitch*1000:.3f}mm")
            logger.info(f"  Shell thickness: {embedding_params.shell_thickness*1000:.3f}mm")
            logger.info(f"  Smoothing iterations: {embedding_params.smoothing_iterations}")
            
            embed_result = embed_tree_as_negative_space(
                tree_stl_path=results["paths"]["vascular_mesh"],
                domain=runtime_domain,
                voxel_pitch=embedding_params.voxel_pitch,
                dilation_voxels=embedding_params.dilation_voxels,
                smoothing_iters=embedding_params.smoothing_iterations,
                output_void=False,
                output_shell=False,
                shell_thickness=embedding_params.shell_thickness,
                stl_units="m",
                output_units="mm",
            )
            
            if embed_result.get("domain_with_void") is not None:
                scaffold_mesh = embed_result["domain_with_void"]
                scaffold_path = output_path / f"{variant_name}_scaffold_with_voids.stl"
                scaffold_mesh.export(str(scaffold_path))
                results["paths"]["scaffold_mesh"] = str(scaffold_path)
                
                embed_time = time.time() - embed_start
                results["timing"]["embedding"] = embed_time
                
                logger.info(f"Scaffold mesh exported to: {scaffold_path}")
                logger.info(f"  Vertices: {len(scaffold_mesh.vertices)}")
                logger.info(f"  Faces: {len(scaffold_mesh.faces)}")
                logger.info(f"  Watertight: {scaffold_mesh.is_watertight}")
                logger.info(f"  Embedding time: {embed_time:.2f} seconds")
            else:
                logger.warning("Embedding produced no domain_with_void mesh")
                
        except Exception as e:
            error_msg = f"Scaffold embedding error: {e}"
            logger.error(error_msg)
            results["errors"].append(error_msg)
    elif skip_embedding:
        logger.info("-" * 50)
        logger.info("STEP 4: Skipping scaffold embedding (skip_embedding=True)")
        logger.info("-" * 50)
    
    # Step 5: Save generation report
    logger.info("-" * 50)
    logger.info("STEP 5: Saving generation report...")
    logger.info("-" * 50)
    
    report = {
        "variant": variant_name,
        "success": len(results["errors"]) == 0,
        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
        "validation": validation,
        "timing": results["timing"],
        "output_files": results["paths"],
        "errors": results["errors"],
        "parameters": {
            "geometry": asdict(geometry),
            "vessels": asdict(vessels),
            "cco_params": asdict(cco_params),
            "embedding": asdict(embedding_params),
        },
    }
    
    report_path = output_path / f"{variant_name}_generation_report.json"
    with open(report_path, "w") as f:
        json.dump(report, f, indent=2)
    results["paths"]["report"] = str(report_path)
    logger.info(f"Generation report saved to: {report_path}")
    
    # Final summary
    total_time = sum(results["timing"].values())
    results["timing"]["total"] = total_time
    results["success"] = len(results["errors"]) == 0
    
    logger.info("=" * 70)
    logger.info(f"GENERATION {'COMPLETED' if results['success'] else 'COMPLETED WITH ERRORS'}")
    logger.info(f"  Total time: {total_time:.2f} seconds")
    logger.info(f"  Output files: {len(results['paths'])}")
    if results["errors"]:
        logger.warning(f"  Errors: {len(results['errors'])}")
        for err in results["errors"]:
            logger.warning(f"    - {err}")
    logger.info("=" * 70)
    
    return results


def generate_single_input_insert(
    output_dir: str,
    seed: int = 42,
    skip_embedding: bool = False,
) -> Dict[str, Any]:
    """
    Generate single-input terminal-venule insert.
    
    Convenience function that creates the spec and generates the insert.
    
    Parameters
    ----------
    output_dir : str
        Output directory path
    seed : int
        Random seed for reproducibility
    skip_embedding : bool
        If True, skip scaffold embedding step
        
    Returns
    -------
    Dict[str, Any]
        Generation results
    """
    logger.info("\n" + "=" * 70)
    logger.info("SINGLE-INPUT TERMINAL-VENULE INSERT GENERATION")
    logger.info("=" * 70 + "\n")
    
    # Validate parameters
    issues = validate_parameters(
        DEFAULT_INSERT_GEOMETRY,
        DEFAULT_VESSEL_DIMENSIONS,
        DEFAULT_CCO_PARAMS,
        DEFAULT_EMBEDDING_PARAMS,
    )
    
    if issues:
        logger.warning("Parameter validation issues:")
        for issue in issues:
            logger.warning(f"  {issue}")
    
    # Create spec
    spec = create_single_input_spec(seed=seed)
    
    # Generate
    return generate_insert(
        spec=spec,
        variant_name="single_input",
        output_dir=output_dir,
        skip_embedding=skip_embedding,
    )


def generate_multi_input_insert(
    output_dir: str,
    num_inlets: int = 6,
    seed: int = 42,
    skip_embedding: bool = False,
) -> Dict[str, Any]:
    """
    Generate multi-input terminal-venule insert.
    
    Convenience function that creates the spec and generates the insert.
    
    Parameters
    ----------
    output_dir : str
        Output directory path
    num_inlets : int
        Number of inlet ports (4-8 recommended)
    seed : int
        Random seed for reproducibility
    skip_embedding : bool
        If True, skip scaffold embedding step
        
    Returns
    -------
    Dict[str, Any]
        Generation results
    """
    logger.info("\n" + "=" * 70)
    logger.info(f"MULTI-INPUT ({num_inlets} INLETS) TERMINAL-VENULE INSERT GENERATION")
    logger.info("=" * 70 + "\n")
    
    # Validate parameters
    issues = validate_parameters(
        DEFAULT_INSERT_GEOMETRY,
        DEFAULT_VESSEL_DIMENSIONS,
        DEFAULT_CCO_PARAMS,
        DEFAULT_EMBEDDING_PARAMS,
    )
    
    if issues:
        logger.warning("Parameter validation issues:")
        for issue in issues:
            logger.warning(f"  {issue}")
    
    # Create multi-input config
    multi_config = MultiInputConfig(num_inlets=num_inlets)
    
    # Create spec
    spec = create_multi_input_spec(multi_config=multi_config, seed=seed)
    
    # Generate
    return generate_insert(
        spec=spec,
        variant_name="multi_input",
        output_dir=output_dir,
        skip_embedding=skip_embedding,
    )


# =============================================================================
# COMMAND LINE INTERFACE
# =============================================================================

def main():
    """
    Command-line interface for terminal-venule insert generation.
    
    Usage examples:
        # Generate single-input variant
        python terminal_venule_insert.py --variant single --output-dir ./output
        
        # Generate multi-input variant with 6 inlets
        python terminal_venule_insert.py --variant multi --num-inlets 6 --output-dir ./output
        
        # Generate both variants
        python terminal_venule_insert.py --variant both --output-dir ./output
        
        # Quick test without embedding (faster)
        python terminal_venule_insert.py --variant single --skip-embedding --output-dir ./output
    """
    parser = argparse.ArgumentParser(
        description="Generate terminal-venule insert scaffolds for 48-well plates",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --variant single --output-dir ./output
  %(prog)s --variant multi --num-inlets 6 --output-dir ./output
  %(prog)s --variant both --output-dir ./output
  %(prog)s --variant single --skip-embedding --output-dir ./output

Output files:
  {variant}_vascular_network.stl    - Vascular channel mesh
  {variant}_scaffold_with_voids.stl - Porous scaffold with channels as voids
  {variant}_design_spec.json        - Design specification
  {variant}_generation_report.json  - Generation metrics and validation
        """,
    )
    
    parser.add_argument(
        "--variant", "-v",
        type=str,
        choices=["single", "multi", "both"],
        default="single",
        help="Design variant to generate (default: single)",
    )
    
    parser.add_argument(
        "--num-inlets", "-n",
        type=int,
        default=6,
        help="Number of inlets for multi-input variant (default: 6)",
    )
    
    parser.add_argument(
        "--output-dir", "-o",
        type=str,
        default="./terminal_venule_output",
        help="Output directory (default: ./terminal_venule_output)",
    )
    
    parser.add_argument(
        "--seed", "-s",
        type=int,
        default=42,
        help="Random seed for reproducibility (default: 42)",
    )
    
    parser.add_argument(
        "--skip-embedding",
        action="store_true",
        help="Skip scaffold embedding step (faster for testing)",
    )
    
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable debug-level logging",
    )
    
    args = parser.parse_args()
    
    # Configure logging level
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Print header
    print("\n" + "=" * 70)
    print("TERMINAL-VENULE INSERT GENERATOR")
    print("48-Well Compatible Scaffold with Converging Channel Architecture")
    print("=" * 70)
    print(f"\nVariant: {args.variant}")
    print(f"Output directory: {args.output_dir}")
    print(f"Random seed: {args.seed}")
    print(f"Skip embedding: {args.skip_embedding}")
    if args.variant in ["multi", "both"]:
        print(f"Number of inlets: {args.num_inlets}")
    print()
    
    results = {}
    
    # Generate requested variant(s)
    if args.variant in ["single", "both"]:
        results["single"] = generate_single_input_insert(
            output_dir=args.output_dir,
            seed=args.seed,
            skip_embedding=args.skip_embedding,
        )
    
    if args.variant in ["multi", "both"]:
        results["multi"] = generate_multi_input_insert(
            output_dir=args.output_dir,
            num_inlets=args.num_inlets,
            seed=args.seed,
            skip_embedding=args.skip_embedding,
        )
    
    # Print final summary
    print("\n" + "=" * 70)
    print("GENERATION SUMMARY")
    print("=" * 70)
    
    for variant, result in results.items():
        status = "SUCCESS" if result["success"] else "FAILED"
        print(f"\n{variant.upper()} variant: {status}")
        print("  Output files:")
        for name, path in result["paths"].items():
            print(f"    - {name}: {path}")
        if result["errors"]:
            print("  Errors:")
            for err in result["errors"]:
                print(f"    - {err}")
    
    print("\n" + "=" * 70)
    print("Generation complete!")
    print("=" * 70 + "\n")
    
    # Return exit code based on success
    all_success = all(r["success"] for r in results.values())
    return 0 if all_success else 1


if __name__ == "__main__":
    sys.exit(main())
