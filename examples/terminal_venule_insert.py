#!/usr/bin/env python3
"""
Terminal-Venule Insert Generator for 48-Well Plate Compatible Scaffolds

This module generates single-well inserts with terminal-venule-like channel architecture
designed for hepatocyte culture experiments. The design mimics liver sinusoidal topology
where many small tributaries (sinusoid-like channels) converge into a central collecting
venule.

DESIGN BRIEF
------------
Physical Form Factor (48-well compatible insert):
- Overall footprint: Insert sized for one 48-well (~11.3mm diameter wells)
- Planform shape: Elliptical/capsule-like cross-section with FLAT TOP FACE
- Top face features: All ports (inlets + outlet) on the flat top face
- Vertical extent: Channels grow DOWNWARD from top face into the volume

Vascular Channel Architecture:
- Space colonization growth from top face downward
- Converging topology: inlets feed branching trees that merge toward central outlet
- Parameterized diameter ladder: inlet trunk > intermediate branches > fine branches
- Tunable minimum radius for printer compatibility

TWO DESIGN VARIANTS
-------------------
1. Single-Inlet Variant:
   - 1 inlet + 1 central outlet on top face
   - Inlet feeds a tree that expands into fine branches converging to outlet

2. Multi-Inlet Variant:
   - 4-6 inlets around perimeter of top face + 1 central outlet
   - Outlet is LARGER than inlets (2-4x) to reflect collecting venule behavior
   - Each inlet grows its own branching tree; trees merge approaching center

CHANNEL DIAMETER TARGETS
------------------------
Biological reference (scaled for printability):
- Sinusoids: ~7-15 um (human) -> scaled to min_printable_radius
- Central venule: ~25-150 um (human) -> scaled to outlet_radius
- Parameterized diameter ladder preserves topology while matching printer limits

OUTPUT FILES
------------
For each variant, the following files are generated:
- {variant}_vascular_network.stl: Vascular channel network as solid tubes (A)
- {variant}_void_volume.stl: Channels as void/negative space (B)
- {variant}_scaffold_with_voids.stl: Print-ready scaffold with channel voids (C)
- {variant}_design_spec.json: Design specification used
- {variant}_generation_report.json: Validation summary with units, min diameters, connectivity
- {variant}_parameter_sheet.json: Complete parameter documentation

USAGE
-----
    # Generate with default (medium) density
    python terminal_venule_insert.py --variant single --output-dir ./output

    # Generate with high branch density
    python terminal_venule_insert.py --variant multi --density high --output-dir ./output

    # Generate both variants with custom inlet count
    python terminal_venule_insert.py --variant both --num-inlets 4 --output-dir ./output

    # Quick test without embedding
    python terminal_venule_insert.py --variant single --skip-embedding --output-dir ./output

Author: Generated by Agentic Organ Generation System
"""

import sys
import os
import json
import time
import math
import argparse
import logging
from pathlib import Path
from typing import Dict, Any, Optional, List, Tuple
from dataclasses import dataclass, asdict, field
from enum import Enum

# Add parent directory to path for imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from generation import (
    create_network,
    add_inlet,
    add_outlet,
    space_colonization_step,
    VascularNetwork,
)
from generation.specs.design_spec import (
    DesignSpec,
    EllipsoidSpec,
    TreeSpec,
    InletSpec,
    OutletSpec,
    ColonizationSpec,
)
from generation.specs.compile import compile_domain
from generation.adapters.mesh_adapter import to_trimesh
from generation.ops.embedding import embed_tree_as_negative_space
from generation.ops.space_colonization import SpaceColonizationParams
from generation.rules.constraints import BranchingConstraints
from generation.core.types import Point3D
from generation.core.result import OperationStatus
import numpy as np

# Configure logging for verbose output
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)


# =============================================================================
# TUNABLE CONSTRAINTS AND PARAMETERS
# =============================================================================
# All geometric values are in METERS (internal unit system).
# Output STL files are converted to millimeters by default.
#
# KEY DESIGN DECISIONS:
# 1. All ports on TOP FACE - flat interface for tubing/needle access
# 2. Channels grow DOWNWARD from top face into volume
# 3. Outlet is LARGER than inlets (collecting venule behavior)
# 4. Parameterized diameter ladder for printability
# =============================================================================


class DensityPreset(Enum):
    """
    Branch density presets for quick iteration.
    
    LOW: Sparse network, faster generation, larger minimum features
    MEDIUM: Balanced density and generation time (default)
    HIGH: Dense arborization, slower generation, finer features
    """
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"


@dataclass
class InsertGeometry:
    """
    Geometric parameters for the 48-well compatible insert.
    
    The insert has an elliptical/capsule-like cross-section with a FLAT TOP FACE
    where all ports are located. This provides:
    - Stable seating in the well
    - Flat interface for port connections (tubing, needles)
    - Smooth body for easy insertion/removal
    
    Coordinate System:
    - Origin at center of top face
    - X/Y: horizontal plane (elliptical cross-section)
    - Z: vertical axis, NEGATIVE Z goes DOWN into the insert
    
    Attributes
    ----------
    major_radius : float
        Major radius of elliptical cross-section in meters.
        Default: 0.004m (4mm) for ~8mm major diameter.
        Must fit within 48-well (~11.3mm diameter) with clearance.
        
    minor_radius : float
        Minor radius of elliptical cross-section in meters.
        Default: 0.003m (3mm) for ~6mm minor diameter.
        Set equal to major_radius for circular cross-section.
        
    depth : float
        Vertical depth of insert (how far channels can grow down) in meters.
        Default: 0.004m (4mm). Channels grow from z=0 (top) to z=-depth.
        
    wall_thickness : float
        Minimum wall thickness at insert edges in meters.
        Default: 0.0005m (0.5mm). Ensures structural integrity.
        
    top_face_margin : float
        Margin from edge of top face where ports should not be placed, in meters.
        Default: 0.0005m (0.5mm). Ensures ports are accessible.
    """
    major_radius: float = 0.004          # 4mm major radius
    minor_radius: float = 0.003          # 3mm minor radius (capsule shape)
    depth: float = 0.004                 # 4mm depth for channel growth
    wall_thickness: float = 0.0005       # 0.5mm wall thickness
    top_face_margin: float = 0.0005      # 0.5mm margin from edge for ports


@dataclass
class VesselDimensions:
    """
    Vessel diameter parameters with parameterized diameter ladder.
    
    The diameter ladder ensures proper flow hierarchy:
    outlet_radius > inlet_radius > intermediate_radius > min_printable_radius
    
    Biological Reference (scaled for printability):
    - Central venule: 25-150 um -> outlet_radius
    - Sinusoids: 7-15 um -> min_printable_radius
    
    Attributes
    ----------
    outlet_radius : float
        Radius of central collecting venule (outlet) in meters.
        Default: 0.0006m (600um). Largest vessel in the network.
        Should be 2-4x larger than inlet_radius.
        
    inlet_radius : float
        Radius of inlet vessels in meters.
        Default: 0.0002m (200um). 
        outlet_to_inlet_ratio controls the relationship.
        
    intermediate_radius : float
        Radius of intermediate branch vessels in meters.
        Default: 0.00015m (150um). Between inlet and fine branches.
        
    min_printable_radius : float
        Minimum printable vessel radius in meters.
        Default: 0.0001m (100um). Set based on fabrication method.
        Two-photon: ~10um, SLA: ~50-100um, FDM: ~200um+
        
    outlet_to_inlet_ratio : float
        Ratio of outlet radius to inlet radius.
        Default: 3.0 (outlet is 3x larger than inlet).
        Range: 2.0-4.0 recommended for collecting venule behavior.
        
    taper_factor : float
        Radius reduction factor per generation (Murray's law approximation).
        Default: 0.85. Each child branch is 85% of parent radius.
        Range: 0.7-0.95. Lower = faster tapering.
    """
    outlet_radius: float = 0.0006           # 600um - central collecting venule
    inlet_radius: float = 0.0002            # 200um - peripheral inlets
    intermediate_radius: float = 0.00015    # 150um - intermediate branches
    min_printable_radius: float = 0.0001    # 100um - finest printable branches
    outlet_to_inlet_ratio: float = 3.0      # Outlet is 3x larger than inlet
    taper_factor: float = 0.85              # Radius decay per generation


@dataclass
class ColonizationParameters:
    """
    Space colonization algorithm parameters for network growth.
    
    Growth Direction: DOWNWARD from top face (negative Z direction)
    
    These control how the vascular network grows from inlets on the top face
    downward into the volume, creating converging tree topology.
    
    Attributes
    ----------
    influence_radius : float
        Radius within which tissue points attract growing tips, in meters.
        Default: 0.002m (2mm). Larger = longer-range attraction, sparser network.
        
    kill_radius : float
        Radius within which tissue points are considered "perfused" and removed.
        Default: 0.0005m (0.5mm). Smaller = denser network coverage.
        
    step_size : float
        Growth step size per iteration, in meters.
        Default: 0.0005m (0.5mm). Smaller = smoother curves, more iterations.
        
    max_steps : int
        Maximum number of growth iterations.
        Default: 100. Increase for denser networks.
        
    directional_bias : float
        Weight for preferred direction (downward) vs pure attraction.
        Range: 0.0-1.0. Default: 0.4.
        Higher = more vertical growth, lower = more organic branching.
        
    smoothing_weight : float
        Weight for smoothing growth direction with previous direction.
        Range: 0.0-1.0. Default: 0.3.
        Higher = smoother, more gradual curves.
        
    encourage_bifurcation : bool
        Whether to encourage branching at nodes with multiple attractions.
        Default: True. Creates more realistic tree topology.
        
    bifurcation_probability : float
        Probability of bifurcating when conditions are met.
        Range: 0.0-1.0. Default: 0.5.
        
    bifurcation_angle_threshold_deg : float
        Minimum angle spread (degrees) between attractions to trigger bifurcation.
        Default: 30.0 degrees.
    """
    influence_radius: float = 0.002         # 2mm attraction range
    kill_radius: float = 0.0005             # 0.5mm perfusion radius
    step_size: float = 0.0005               # 0.5mm growth step
    max_steps: int = 100                    # Maximum iterations
    directional_bias: float = 0.4           # Bias toward downward growth
    smoothing_weight: float = 0.3           # Direction smoothing
    encourage_bifurcation: bool = True      # Enable branching
    bifurcation_probability: float = 0.5    # Branching probability
    bifurcation_angle_threshold_deg: float = 30.0  # Min angle for bifurcation


@dataclass
class EmbeddingParameters:
    """
    Parameters for embedding vascular network into scaffold domain.
    
    These control the voxelization and boolean operations that create:
    (A) Vascular network STL - channels as solid tubes
    (B) Void volume STL - channels as negative space
    (C) Scaffold-with-voids STL - print-ready scaffold
    
    Attributes
    ----------
    voxel_pitch : float
        Voxel size for domain discretization, in meters.
        Default: 0.00005m (50um). Smaller = higher resolution, slower.
        Should be smaller than min_printable_radius.
        
    shell_thickness : float
        Wall thickness around channels, in meters.
        Default: 0.0003m (300um). Minimum for structural integrity.
        
    smoothing_iterations : int
        Number of smoothing passes to reduce voxel artifacts.
        Default: 3. Higher = smoother surfaces, slower.
        
    dilation_voxels : int
        Number of voxels to dilate channel volumes.
        Default: 1. Ensures channels are fully open after boolean ops.
        
    output_void_stl : bool
        Whether to output the void/negative-space STL.
        Default: True.
        
    output_scaffold_stl : bool
        Whether to output the scaffold-with-voids STL.
        Default: True.
    """
    voxel_pitch: float = 0.00005            # 50um voxel resolution
    shell_thickness: float = 0.0003         # 300um wall thickness
    smoothing_iterations: int = 3           # Surface smoothing passes
    dilation_voxels: int = 1                # Channel dilation
    output_void_stl: bool = True            # Output void volume STL
    output_scaffold_stl: bool = True        # Output scaffold with voids STL


@dataclass
class MultiInputConfig:
    """
    Configuration for multi-input variant.
    
    In the multi-input design:
    - Inlets are distributed around the perimeter of the TOP FACE
    - Central outlet is at the CENTER of the top face
    - Outlet is LARGER than inlets (collecting venule behavior)
    
    Attributes
    ----------
    num_inlets : int
        Number of inlet ports distributed around perimeter of top face.
        Default: 6. Range: 4-8 recommended.
        
    inlet_radial_fraction : float
        Fraction of major_radius where inlets are positioned.
        Default: 0.7. Inlets at 70% of radius from center.
        Range: 0.5-0.85. Higher = closer to edge.
        
    inlet_angular_offset_deg : float
        Angular offset for first inlet position in degrees.
        Default: 0.0. Set to 30.0 for 6 inlets to avoid axis alignment.
    """
    num_inlets: int = 6                         # Number of peripheral inlets
    inlet_radial_fraction: float = 0.7          # 70% of radius from center
    inlet_angular_offset_deg: float = 0.0       # Angular offset for first inlet


# =============================================================================
# DENSITY PRESETS
# =============================================================================

def get_colonization_params_for_density(density: DensityPreset) -> ColonizationParameters:
    """
    Get colonization parameters for a given density preset.
    
    Parameters
    ----------
    density : DensityPreset
        Desired branch density level
        
    Returns
    -------
    ColonizationParameters
        Tuned parameters for the density level
    """
    if density == DensityPreset.LOW:
        return ColonizationParameters(
            influence_radius=0.003,         # 3mm - longer range, sparser
            kill_radius=0.001,              # 1mm - larger kill radius
            step_size=0.0008,               # 0.8mm - larger steps
            max_steps=50,                   # Fewer iterations
            directional_bias=0.5,           # More directional
            bifurcation_probability=0.3,    # Less branching
        )
    elif density == DensityPreset.HIGH:
        return ColonizationParameters(
            influence_radius=0.0015,        # 1.5mm - shorter range, denser
            kill_radius=0.0003,             # 0.3mm - smaller kill radius
            step_size=0.0003,               # 0.3mm - smaller steps
            max_steps=200,                  # More iterations
            directional_bias=0.3,           # More organic
            bifurcation_probability=0.7,    # More branching
        )
    else:  # MEDIUM (default)
        return ColonizationParameters()


def get_vessel_dimensions_for_density(
    density: DensityPreset,
    min_printable: float = 0.0001
) -> VesselDimensions:
    """
    Get vessel dimensions for a given density preset.
    
    Parameters
    ----------
    density : DensityPreset
        Desired branch density level
    min_printable : float
        Minimum printable radius in meters (based on fabrication method)
        
    Returns
    -------
    VesselDimensions
        Tuned dimensions for the density level
    """
    if density == DensityPreset.LOW:
        return VesselDimensions(
            outlet_radius=0.0008,           # 800um outlet
            inlet_radius=0.0003,            # 300um inlet
            intermediate_radius=0.0002,     # 200um intermediate
            min_printable_radius=max(min_printable, 0.00015),  # 150um min
            outlet_to_inlet_ratio=2.67,
            taper_factor=0.9,               # Slower taper
        )
    elif density == DensityPreset.HIGH:
        return VesselDimensions(
            outlet_radius=0.0005,           # 500um outlet
            inlet_radius=0.00015,           # 150um inlet
            intermediate_radius=0.0001,     # 100um intermediate
            min_printable_radius=min_printable,  # Use provided min
            outlet_to_inlet_ratio=3.33,
            taper_factor=0.8,               # Faster taper
        )
    else:  # MEDIUM (default)
        return VesselDimensions(
            min_printable_radius=min_printable
        )


# =============================================================================
# DEFAULT PARAMETER INSTANCES
# =============================================================================

DEFAULT_INSERT_GEOMETRY = InsertGeometry()
DEFAULT_VESSEL_DIMENSIONS = VesselDimensions()
DEFAULT_COLONIZATION_PARAMS = ColonizationParameters()
DEFAULT_EMBEDDING_PARAMS = EmbeddingParameters()
DEFAULT_MULTI_INPUT_CONFIG = MultiInputConfig()


# =============================================================================
# VALIDATION FUNCTIONS
# =============================================================================

def validate_parameters(
    geometry: InsertGeometry,
    vessels: VesselDimensions,
    colonization: ColonizationParameters,
    embedding: EmbeddingParameters,
) -> List[str]:
    """
    Validate parameter combinations and return list of warnings/errors.
    
    Parameters
    ----------
    geometry : InsertGeometry
        Insert geometry parameters
    vessels : VesselDimensions
        Vessel dimension parameters
    colonization : ColonizationParameters
        Space colonization parameters
    embedding : EmbeddingParameters
        Embedding parameters
        
    Returns
    -------
    List[str]
        List of validation warnings/errors. Empty if all valid.
    """
    issues = []
    
    # Check vessel diameter ladder
    if vessels.min_printable_radius >= vessels.intermediate_radius:
        issues.append(
            f"WARNING: min_printable_radius ({vessels.min_printable_radius*1000:.3f}mm) "
            f">= intermediate_radius ({vessels.intermediate_radius*1000:.3f}mm). "
            "Diameter ladder violated."
        )
    
    if vessels.intermediate_radius >= vessels.inlet_radius:
        issues.append(
            f"WARNING: intermediate_radius ({vessels.intermediate_radius*1000:.3f}mm) "
            f">= inlet_radius ({vessels.inlet_radius*1000:.3f}mm). "
            "Diameter ladder violated."
        )
    
    if vessels.inlet_radius >= vessels.outlet_radius:
        issues.append(
            f"WARNING: inlet_radius ({vessels.inlet_radius*1000:.3f}mm) "
            f">= outlet_radius ({vessels.outlet_radius*1000:.3f}mm). "
            "Outlet should be larger than inlets (collecting venule)."
        )
    
    # Check outlet-to-inlet ratio
    actual_ratio = vessels.outlet_radius / vessels.inlet_radius
    if actual_ratio < 2.0:
        issues.append(
            f"WARNING: outlet_to_inlet_ratio ({actual_ratio:.2f}) < 2.0. "
            "Outlet should be 2-4x larger than inlets for proper collecting behavior."
        )
    
    # Check voxel pitch vs vessel radii
    if embedding.voxel_pitch >= vessels.min_printable_radius:
        issues.append(
            f"WARNING: voxel_pitch ({embedding.voxel_pitch*1000:.3f}mm) "
            f">= min_printable_radius ({vessels.min_printable_radius*1000:.3f}mm). "
            "Voxel resolution may be too coarse to capture fine vessels."
        )
    
    # Check colonization parameters
    if colonization.kill_radius >= colonization.influence_radius:
        issues.append(
            f"ERROR: kill_radius ({colonization.kill_radius*1000:.2f}mm) "
            f">= influence_radius ({colonization.influence_radius*1000:.2f}mm). "
            "Kill radius must be smaller than influence radius."
        )
    
    if colonization.step_size >= colonization.influence_radius:
        issues.append(
            f"WARNING: step_size ({colonization.step_size*1000:.2f}mm) "
            f">= influence_radius ({colonization.influence_radius*1000:.2f}mm). "
            "Step size should be smaller than influence radius for smooth growth."
        )
    
    # Check geometry constraints
    if geometry.wall_thickness >= geometry.minor_radius * 0.3:
        issues.append(
            f"WARNING: wall_thickness ({geometry.wall_thickness*1000:.2f}mm) "
            f">= 30% of minor_radius ({geometry.minor_radius*1000:.2f}mm). "
            "Wall thickness may be too large."
        )
    
    # Check 48-well compatibility
    max_diameter = 2 * geometry.major_radius
    if max_diameter > 0.010:  # 10mm
        issues.append(
            f"WARNING: Insert diameter ({max_diameter*1000:.1f}mm) > 10mm. "
            "May not fit in 48-well plate (~11.3mm wells) with adequate clearance."
        )
    
    return issues


def validate_network(
    network: VascularNetwork,
    variant_name: str,
    vessels: VesselDimensions = DEFAULT_VESSEL_DIMENSIONS,
) -> Dict[str, Any]:
    """
    Validate generated vascular network and return detailed metrics.
    
    Checks:
    - Network complexity (node/segment counts)
    - Inlet/outlet presence
    - Segment statistics (length, radius)
    - Connectivity (all nodes reachable)
    - Minimum diameter compliance
    
    Parameters
    ----------
    network : VascularNetwork
        Generated vascular network
    variant_name : str
        Name of the variant for logging
    vessels : VesselDimensions
        Vessel dimensions for validation
        
    Returns
    -------
    Dict[str, Any]
        Validation results including metrics and any issues found
    """
    logger.info(f"Validating {variant_name} network...")
    
    results = {
        "variant": variant_name,
        "valid": True,
        "issues": [],
        "metrics": {},
        "units": "millimeters",
    }
    
    # Count node types
    node_counts = {
        "inlet": 0,
        "outlet": 0,
        "terminal": 0,
        "junction": 0,
    }
    for node in network.nodes.values():
        node_type = node.node_type
        if node_type in node_counts:
            node_counts[node_type] += 1
    
    results["metrics"]["node_counts"] = node_counts
    results["metrics"]["total_nodes"] = len(network.nodes)
    results["metrics"]["total_segments"] = len(network.segments)
    
    logger.info(f"  Total nodes: {len(network.nodes)}")
    logger.info(f"  Total segments: {len(network.segments)}")
    logger.info(f"  Node breakdown: {node_counts}")
    
    # Check for minimum network complexity
    if len(network.segments) < 5:
        results["issues"].append(
            f"WARNING: Network has only {len(network.segments)} segments. "
            "Expected more complex branching structure."
        )
        results["valid"] = False
    
    # Check for inlets and outlets
    if node_counts["inlet"] == 0:
        results["issues"].append("ERROR: No inlet nodes found in network.")
        results["valid"] = False
    
    if node_counts["outlet"] == 0:
        results["issues"].append("ERROR: No outlet nodes found in network.")
        results["valid"] = False
    
    # Compute segment statistics
    segment_lengths = []
    segment_radii = []
    for segment in network.segments.values():
        length = segment.geometry.length()
        segment_lengths.append(length)
        segment_radii.append(segment.geometry.mean_radius())
    
    if segment_lengths:
        min_radius_mm = min(segment_radii) * 1000
        max_radius_mm = max(segment_radii) * 1000
        mean_radius_mm = sum(segment_radii) / len(segment_radii) * 1000
        
        results["metrics"]["segment_length_stats"] = {
            "min_mm": min(segment_lengths) * 1000,
            "max_mm": max(segment_lengths) * 1000,
            "mean_mm": sum(segment_lengths) / len(segment_lengths) * 1000,
        }
        results["metrics"]["segment_radius_stats"] = {
            "min_mm": min_radius_mm,
            "max_mm": max_radius_mm,
            "mean_mm": mean_radius_mm,
        }
        
        logger.info(f"  Segment lengths: min={min(segment_lengths)*1000:.3f}mm, "
                   f"max={max(segment_lengths)*1000:.3f}mm, "
                   f"mean={sum(segment_lengths)/len(segment_lengths)*1000:.3f}mm")
        logger.info(f"  Segment radii: min={min_radius_mm:.3f}mm, "
                   f"max={max_radius_mm:.3f}mm, "
                   f"mean={mean_radius_mm:.3f}mm")
        
        # Check minimum radius compliance
        min_printable_mm = vessels.min_printable_radius * 1000
        if min_radius_mm < min_printable_mm * 0.9:  # 10% tolerance
            results["issues"].append(
                f"WARNING: Minimum segment radius ({min_radius_mm:.3f}mm) "
                f"< min_printable_radius ({min_printable_mm:.3f}mm)."
            )
    
    # Check connectivity (simple check: all segments connected)
    if len(network.segments) > 0:
        connected_nodes = set()
        for segment in network.segments.values():
            connected_nodes.add(segment.start_node_id)
            connected_nodes.add(segment.end_node_id)
        
        unconnected = len(network.nodes) - len(connected_nodes)
        if unconnected > 0:
            results["issues"].append(
                f"WARNING: {unconnected} nodes are not connected to any segment."
            )
        results["metrics"]["connectivity"] = {
            "connected_nodes": len(connected_nodes),
            "unconnected_nodes": unconnected,
            "fully_connected": unconnected == 0,
        }
    
    # Log any issues
    for issue in results["issues"]:
        if issue.startswith("ERROR"):
            logger.error(f"  {issue}")
        else:
            logger.warning(f"  {issue}")
    
    if results["valid"]:
        logger.info(f"  Validation PASSED for {variant_name}")
    else:
        logger.warning(f"  Validation FAILED for {variant_name}")
    
    return results


# =============================================================================
# DESIGN SPECIFICATION CREATION
# =============================================================================

def create_single_input_spec(
    geometry: InsertGeometry = DEFAULT_INSERT_GEOMETRY,
    vessels: VesselDimensions = DEFAULT_VESSEL_DIMENSIONS,
    colonization: ColonizationParameters = DEFAULT_COLONIZATION_PARAMS,
    seed: int = 42,
) -> DesignSpec:
    """
    Create design specification for single-input terminal-venule insert.
    
    Port Layout (all on TOP FACE, z=0):
    - 1 inlet at perimeter of top face
    - 1 outlet at center of top face (larger than inlet)
    
    Growth Direction: DOWNWARD (negative Z) from top face into volume
    
    Parameters
    ----------
    geometry : InsertGeometry
        Insert geometry parameters
    vessels : VesselDimensions
        Vessel dimension parameters
    colonization : ColonizationParameters
        Space colonization parameters
    seed : int
        Random seed for reproducibility
        
    Returns
    -------
    DesignSpec
        Complete design specification for generation
    """
    logger.info("Creating single-input design specification...")
    logger.info("  Port layout: All ports on TOP FACE (z=0)")
    logger.info("  Growth direction: DOWNWARD (negative Z)")
    
    # Define ellipsoid domain centered below top face
    # Top face is at z=0, domain extends downward to z=-depth
    # Using ellipsoid with center at z=-depth/2
    domain_center_z = -geometry.depth / 2
    
    domain = EllipsoidSpec(
        type="ellipsoid",
        center=(0.0, 0.0, domain_center_z),
        semi_axes=(geometry.major_radius, geometry.minor_radius, geometry.depth / 2),
    )
    
    logger.info(f"  Domain: ellipsoid centered at z={domain_center_z*1000:.1f}mm")
    logger.info(f"  Semi-axes: ({geometry.major_radius*1000:.1f}mm, "
               f"{geometry.minor_radius*1000:.1f}mm, {geometry.depth/2*1000:.1f}mm)")
    
    # Single inlet near top face, positioned inside the ellipsoid domain
    # For an ellipsoid centered at z=-depth/2 with semi-axis z=depth/2,
    # we need to position the inlet slightly below z=0 to be inside the domain.
    # At z=-0.1*depth (10% below top), the ellipsoid cross-section allows
    # radial positions up to ~sqrt(1 - 0.1²) ≈ 0.995 of the semi-axes.
    # Position inlet at 60% of that available radius for safety margin.
    inlet_z_fraction = 0.15  # 15% below top face
    inlet_z = -geometry.depth * inlet_z_fraction
    
    # Calculate max radial position at this z level
    # Ellipsoid equation: (x/a)² + (y/b)² + ((z-c)/d)² = 1
    # At z = inlet_z, max radius fraction = sqrt(1 - ((inlet_z - domain_center_z) / (depth/2))²)
    z_normalized = (inlet_z - domain_center_z) / (geometry.depth / 2)
    max_radial_fraction = math.sqrt(max(0, 1 - z_normalized**2))
    inlet_radial_fraction = 0.6 * max_radial_fraction  # 60% of available radius
    
    inlet_x = geometry.major_radius * inlet_radial_fraction
    
    inlet = InletSpec(
        position=(inlet_x, 0.0, inlet_z),
        radius=vessels.inlet_radius,
        vessel_type="venous",
    )
    
    logger.info(f"  Inlet: position=({inlet_x*1000:.2f}, 0, {inlet_z*1000:.2f})mm, "
               f"radius={vessels.inlet_radius*1000:.3f}mm")
    
    # Central outlet near top face, at center
    # Position slightly below top face to be inside the ellipsoid domain
    # Outlet is larger than inlet (collecting venule)
    outlet_z = -geometry.depth * 0.05  # 5% below top face
    outlet = OutletSpec(
        position=(0.0, 0.0, outlet_z),
        radius=vessels.outlet_radius,
        vessel_type="venous",
    )
    
    logger.info(f"  Outlet: position=(0, 0, {outlet_z*1000:.2f})mm, "
               f"radius={vessels.outlet_radius*1000:.3f}mm")
    logger.info(f"  Outlet/inlet ratio: {vessels.outlet_radius/vessels.inlet_radius:.2f}x")
    
    # Colonization parameters with DOWNWARD bias
    # Preferred direction is negative Z (down into the insert)
    preferred_dir = (0.0, 0.0, -1.0)
    
    col_spec = ColonizationSpec(
        influence_radius=colonization.influence_radius,
        kill_radius=colonization.kill_radius,
        step_size=colonization.step_size,
        max_steps=colonization.max_steps,
        initial_radius=vessels.inlet_radius,
        min_radius=vessels.min_printable_radius,
        radius_decay=vessels.taper_factor,
        preferred_direction=preferred_dir,
        directional_bias=colonization.directional_bias,
        smoothing_weight=colonization.smoothing_weight,
        encourage_bifurcation=colonization.encourage_bifurcation,
        bifurcation_probability=colonization.bifurcation_probability,
        bifurcation_angle_threshold_deg=colonization.bifurcation_angle_threshold_deg,
    )
    
    logger.info(f"  Colonization: influence={colonization.influence_radius*1000:.2f}mm, "
               f"kill={colonization.kill_radius*1000:.2f}mm, "
               f"steps={colonization.max_steps}")
    logger.info("  Preferred direction: DOWNWARD (0, 0, -1)")
    
    # Create tree spec
    tree = TreeSpec(
        inlets=[inlet],
        outlets=[outlet],
        colonization=col_spec,
    )
    
    # Create full design spec
    spec = DesignSpec(
        domain=domain,
        tree=tree,
        seed=seed,
        metadata={
            "design_type": "terminal_venule_insert",
            "variant": "single_input",
            "port_layout": "all_on_top_face",
            "growth_direction": "downward",
            "description": "Single-input converging venule topology for 48-well insert",
        },
        output_units="mm",
    )
    
    logger.info("  Single-input design specification created successfully")
    
    return spec


def create_multi_input_spec(
    geometry: InsertGeometry = DEFAULT_INSERT_GEOMETRY,
    vessels: VesselDimensions = DEFAULT_VESSEL_DIMENSIONS,
    colonization: ColonizationParameters = DEFAULT_COLONIZATION_PARAMS,
    multi_config: MultiInputConfig = DEFAULT_MULTI_INPUT_CONFIG,
    seed: int = 42,
) -> DesignSpec:
    """
    Create design specification for multi-input terminal-venule insert.
    
    Port Layout (all on TOP FACE, z=0):
    - 4-6 inlets distributed around perimeter of top face
    - 1 outlet at center of top face (LARGER than inlets, 2-4x)
    
    Growth Direction: DOWNWARD (negative Z) from top face into volume
    
    Parameters
    ----------
    geometry : InsertGeometry
        Insert geometry parameters
    vessels : VesselDimensions
        Vessel dimension parameters
    colonization : ColonizationParameters
        Space colonization parameters
    multi_config : MultiInputConfig
        Multi-input specific configuration
    seed : int
        Random seed for reproducibility
        
    Returns
    -------
    DesignSpec
        Complete design specification for generation
    """
    logger.info(f"Creating multi-input design specification ({multi_config.num_inlets} inlets)...")
    logger.info("  Port layout: All ports on TOP FACE (z=0)")
    logger.info("  Growth direction: DOWNWARD (negative Z)")
    
    # Define ellipsoid domain centered below top face
    domain_center_z = -geometry.depth / 2
    
    domain = EllipsoidSpec(
        type="ellipsoid",
        center=(0.0, 0.0, domain_center_z),
        semi_axes=(geometry.major_radius, geometry.minor_radius, geometry.depth / 2),
    )
    
    logger.info(f"  Domain: ellipsoid centered at z={domain_center_z*1000:.1f}mm")
    logger.info(f"  Semi-axes: ({geometry.major_radius*1000:.1f}mm, "
               f"{geometry.minor_radius*1000:.1f}mm, {geometry.depth/2*1000:.1f}mm)")
    
    # Create multiple inlets distributed around perimeter, positioned inside the ellipsoid
    # Position inlets slightly below top face to be inside the domain
    inlets = []
    inlet_z_fraction = 0.15  # 15% below top face
    inlet_z = -geometry.depth * inlet_z_fraction
    
    # Calculate max radial position at this z level
    z_normalized = (inlet_z - domain_center_z) / (geometry.depth / 2)
    max_radial_fraction = math.sqrt(max(0, 1 - z_normalized**2))
    # Use configured radial fraction but cap at available space
    effective_radial_fraction = min(multi_config.inlet_radial_fraction, 0.6 * max_radial_fraction)
    
    for i in range(multi_config.num_inlets):
        # Calculate angle with optional offset
        angle = (2 * math.pi * i / multi_config.num_inlets + 
                math.radians(multi_config.inlet_angular_offset_deg))
        
        # Position on ellipse at effective_radial_fraction of radii
        inlet_x = geometry.major_radius * effective_radial_fraction * math.cos(angle)
        inlet_y = geometry.minor_radius * effective_radial_fraction * math.sin(angle)
        
        inlet = InletSpec(
            position=(inlet_x, inlet_y, inlet_z),
            radius=vessels.inlet_radius,
            vessel_type="venous",
        )
        inlets.append(inlet)
        
        logger.info(f"  Inlet {i+1}: position=({inlet_x*1000:.2f}, {inlet_y*1000:.2f}, "
                   f"{inlet_z*1000:.2f})mm, radius={vessels.inlet_radius*1000:.3f}mm")
    
    # Central outlet near top face - LARGER than inlets
    # Position slightly below top face to be inside the ellipsoid domain
    outlet_z = -geometry.depth * 0.05  # 5% below top face
    outlet = OutletSpec(
        position=(0.0, 0.0, outlet_z),
        radius=vessels.outlet_radius,
        vessel_type="venous",
    )
    
    logger.info(f"  Outlet (central): position=(0, 0, {outlet_z*1000:.2f})mm, "
               f"radius={vessels.outlet_radius*1000:.3f}mm")
    logger.info(f"  Outlet/inlet ratio: {vessels.outlet_radius/vessels.inlet_radius:.2f}x")
    
    # Colonization parameters with DOWNWARD bias
    preferred_dir = (0.0, 0.0, -1.0)
    
    col_spec = ColonizationSpec(
        influence_radius=colonization.influence_radius,
        kill_radius=colonization.kill_radius,
        step_size=colonization.step_size,
        max_steps=colonization.max_steps,
        initial_radius=vessels.inlet_radius,
        min_radius=vessels.min_printable_radius,
        radius_decay=vessels.taper_factor,
        preferred_direction=preferred_dir,
        directional_bias=colonization.directional_bias,
        smoothing_weight=colonization.smoothing_weight,
        encourage_bifurcation=colonization.encourage_bifurcation,
        bifurcation_probability=colonization.bifurcation_probability,
        bifurcation_angle_threshold_deg=colonization.bifurcation_angle_threshold_deg,
    )
    
    logger.info(f"  Colonization: influence={colonization.influence_radius*1000:.2f}mm, "
               f"kill={colonization.kill_radius*1000:.2f}mm, "
               f"steps={colonization.max_steps}")
    
    # Create tree spec
    tree = TreeSpec(
        inlets=inlets,
        outlets=[outlet],
        colonization=col_spec,
    )
    
    # Create full design spec
    spec = DesignSpec(
        domain=domain,
        tree=tree,
        seed=seed,
        metadata={
            "design_type": "terminal_venule_insert",
            "variant": "multi_input",
            "num_inlets": multi_config.num_inlets,
            "port_layout": "all_on_top_face",
            "growth_direction": "downward",
            "description": f"Multi-input ({multi_config.num_inlets} inlets) converging venule topology",
        },
        output_units="mm",
    )
    
    logger.info("  Multi-input design specification created successfully")
    
    return spec


# =============================================================================
# CUSTOM NETWORK GENERATION (with proper constraints in meters)
# =============================================================================

def generate_network_from_spec(
    spec: DesignSpec,
    vessels: VesselDimensions = DEFAULT_VESSEL_DIMENSIONS,
    colonization: ColonizationParameters = DEFAULT_COLONIZATION_PARAMS,
) -> VascularNetwork:
    """
    Generate vascular network from design specification with proper constraints.
    
    This function bypasses design_from_spec to use custom BranchingConstraints
    with values in meters (the internal unit system) rather than millimeters.
    
    The default BranchingConstraints uses millimeters, but all network operations
    use meters internally, causing a unit mismatch. This function creates
    constraints in meters to ensure proper network generation.
    
    Parameters
    ----------
    spec : DesignSpec
        Design specification with domain, tree, and colonization settings
    vessels : VesselDimensions
        Vessel dimension parameters (in meters)
    colonization : ColonizationParameters
        Colonization algorithm parameters (in meters)
        
    Returns
    -------
    VascularNetwork
        Generated vascular network
    """
    logger.info("Generating network with custom constraints (in meters)...")
    
    # Compile domain from spec
    domain = compile_domain(spec.domain)
    
    # Create network
    network = create_network(domain=domain, seed=spec.seed)
    
    # Get tree spec
    tree = spec.tree
    if tree is None:
        raise ValueError("DesignSpec must have a tree specification")
    
    # Compute domain center for direction calculations
    domain_center = np.array([domain.center.x, domain.center.y, domain.center.z])
    
    # Add inlets - direction points DOWNWARD into the domain
    for inlet_spec in tree.inlets:
        # Direction is downward (negative Z) for top-face ports
        direction = (0.0, 0.0, -1.0)
        
        result = add_inlet(
            network,
            position=Point3D(*inlet_spec.position),
            radius=inlet_spec.radius,
            vessel_type=inlet_spec.vessel_type,
            direction=direction,
        )
        if not result.is_success():
            logger.warning(f"Failed to add inlet: {result.message}")
    
    # Add outlets - direction points UPWARD (flow exits upward)
    for outlet_spec in tree.outlets:
        direction = (0.0, 0.0, 1.0)  # Upward for outlet
        
        result = add_outlet(
            network,
            position=Point3D(*outlet_spec.position),
            radius=outlet_spec.radius,
            vessel_type=outlet_spec.vessel_type,
            direction=direction,
        )
        if not result.is_success():
            logger.warning(f"Failed to add outlet: {result.message}")
    
    # Sample tissue points from domain
    tissue_points = domain.sample_points(n_points=1500, seed=spec.seed)
    logger.info(f"  Sampled {len(tissue_points)} tissue points from domain")
    
    # Create custom BranchingConstraints in METERS (not millimeters)
    constraints = BranchingConstraints(
        min_radius=vessels.min_printable_radius,
        max_radius=vessels.outlet_radius * 2,
        min_segment_length=colonization.step_size * 0.5,
        max_segment_length=colonization.step_size * 10,
        max_branch_order=25,
        max_branch_angle_deg=80.0,
    )
    logger.info(f"  Custom constraints: min_radius={constraints.min_radius*1000:.3f}mm, "
               f"min_segment_length={constraints.min_segment_length*1000:.3f}mm")
    
    # Get colonization spec
    col_spec = tree.colonization
    
    # Create SpaceColonizationParams
    taper = 0.85
    if hasattr(col_spec, 'radius_decay') and col_spec.radius_decay is not None:
        taper = col_spec.radius_decay
    
    params = SpaceColonizationParams(
        influence_radius=col_spec.influence_radius,
        kill_radius=col_spec.kill_radius,
        step_size=col_spec.step_size,
        min_radius=col_spec.min_radius,
        taper_factor=taper,
        vessel_type=tree.inlets[0].vessel_type if tree.inlets else "venous",
        max_steps=col_spec.max_steps,
        preferred_direction=col_spec.preferred_direction,
        directional_bias=col_spec.directional_bias,
        max_deviation_deg=col_spec.max_deviation_deg,
        smoothing_weight=col_spec.smoothing_weight,
        encourage_bifurcation=col_spec.encourage_bifurcation,
        min_attractions_for_bifurcation=col_spec.min_attractions_for_bifurcation,
        max_children_per_node=col_spec.max_children_per_node,
        bifurcation_angle_threshold_deg=col_spec.bifurcation_angle_threshold_deg,
        bifurcation_probability=col_spec.bifurcation_probability,
    )
    
    # Run space colonization with custom constraints
    logger.info(f"  Running space colonization (max_steps={params.max_steps})...")
    result = space_colonization_step(
        network,
        tissue_points=tissue_points,
        params=params,
        constraints=constraints,
        seed=spec.seed,
    )
    
    if result.status == OperationStatus.SUCCESS:
        logger.info(f"  Colonization succeeded: {result.message}")
    elif result.status == OperationStatus.PARTIAL_SUCCESS:
        logger.info(f"  Colonization partial success: {result.message}")
    else:
        logger.warning(f"  Colonization warning: {result.message}")
    
    # Log network statistics
    logger.info(f"  Network: {len(network.nodes)} nodes, {len(network.segments)} segments")
    
    return network


# =============================================================================
# GENERATION FUNCTIONS
# =============================================================================

def generate_insert(
    spec: DesignSpec,
    variant_name: str,
    output_dir: str,
    vessels: VesselDimensions = DEFAULT_VESSEL_DIMENSIONS,
    embedding_params: EmbeddingParameters = DEFAULT_EMBEDDING_PARAMS,
    skip_embedding: bool = False,
) -> Dict[str, Any]:
    """
    Generate terminal-venule insert from design specification.
    
    This function:
    1. Validates input parameters
    2. Generates vascular network via space colonization
    3. Validates the generated network
    4. Exports vascular mesh to STL (A)
    5. Optionally exports void volume STL (B)
    6. Optionally creates scaffold with voids STL (C)
    7. Saves parameter sheet and validation report
    
    Parameters
    ----------
    spec : DesignSpec
        Design specification
    variant_name : str
        Name for output files (e.g., "single_input", "multi_input")
    output_dir : str
        Output directory path
    vessels : VesselDimensions
        Vessel dimension parameters
    embedding_params : EmbeddingParameters
        Parameters for scaffold embedding
    skip_embedding : bool
        If True, skip the embedding step (faster for testing)
        
    Returns
    -------
    Dict[str, Any]
        Results dictionary containing:
        - success: bool
        - network: VascularNetwork
        - validation: validation results
        - paths: dict of output file paths
        - timing: dict of timing information
        - errors: list of any errors encountered
    """
    logger.info("=" * 70)
    logger.info(f"GENERATING {variant_name.upper()} TERMINAL-VENULE INSERT")
    logger.info("=" * 70)
    
    results = {
        "success": False,
        "variant": variant_name,
        "network": None,
        "validation": None,
        "paths": {},
        "timing": {},
        "errors": [],
    }
    
    # Create output directory
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    logger.info(f"Output directory: {output_path.absolute()}")
    
    # Save design spec
    spec_path = output_path / f"{variant_name}_design_spec.json"
    spec.to_json(str(spec_path))
    results["paths"]["design_spec"] = str(spec_path)
    logger.info(f"Saved design specification to: {spec_path}")
    
    # Step 1: Generate vascular network
    logger.info("-" * 50)
    logger.info("STEP 1: Generating vascular network...")
    logger.info("-" * 50)
    
    gen_start = time.time()
    try:
        network = generate_network_from_spec(spec, vessels=vessels)
        results["network"] = network
        gen_time = time.time() - gen_start
        results["timing"]["network_generation"] = gen_time
        logger.info(f"Network generation completed in {gen_time:.2f} seconds")
    except Exception as e:
        error_msg = f"Network generation failed: {e}"
        logger.error(error_msg)
        results["errors"].append(error_msg)
        return results
    
    # Step 2: Validate network
    logger.info("-" * 50)
    logger.info("STEP 2: Validating generated network...")
    logger.info("-" * 50)
    
    validation = validate_network(network, variant_name, vessels)
    results["validation"] = validation
    
    if not validation["valid"]:
        logger.warning("Network validation found issues (see above)")
    
    # Step 3: Export vascular mesh (A)
    logger.info("-" * 50)
    logger.info("STEP 3: Exporting vascular network mesh (A)...")
    logger.info("-" * 50)
    
    mesh_start = time.time()
    try:
        mesh_result = to_trimesh(
            network,
            mode="fast",
            radial_resolution=12,
            include_caps=True,
            include_node_spheres=True,
        )
        
        if mesh_result.is_success():
            mesh = mesh_result.metadata["mesh"]
            mesh_path = output_path / f"{variant_name}_vascular_network.stl"
            mesh.export(str(mesh_path))
            results["paths"]["vascular_mesh"] = str(mesh_path)
            
            mesh_time = time.time() - mesh_start
            results["timing"]["mesh_export"] = mesh_time
            
            logger.info(f"Vascular mesh exported to: {mesh_path}")
            logger.info(f"  Vertices: {len(mesh.vertices)}")
            logger.info(f"  Faces: {len(mesh.faces)}")
            logger.info(f"  Watertight: {mesh.is_watertight}")
            logger.info(f"  Export time: {mesh_time:.2f} seconds")
        else:
            error_msg = f"Mesh export failed: {mesh_result.message}"
            logger.error(error_msg)
            results["errors"].append(error_msg)
    except Exception as e:
        error_msg = f"Mesh export error: {e}"
        logger.error(error_msg)
        results["errors"].append(error_msg)
    
    # Step 4: Create scaffold with voids (B and C)
    if not skip_embedding and "vascular_mesh" in results["paths"]:
        logger.info("-" * 50)
        logger.info("STEP 4: Creating scaffold with channel voids (B, C)...")
        logger.info("-" * 50)
        
        embed_start = time.time()
        try:
            runtime_domain = compile_domain(spec.domain)
            
            logger.info(f"  Voxel pitch: {embedding_params.voxel_pitch*1000:.3f}mm")
            logger.info(f"  Shell thickness: {embedding_params.shell_thickness*1000:.3f}mm")
            
            embed_result = embed_tree_as_negative_space(
                tree_stl_path=results["paths"]["vascular_mesh"],
                domain=runtime_domain,
                voxel_pitch=embedding_params.voxel_pitch,
                dilation_voxels=embedding_params.dilation_voxels,
                smoothing_iters=embedding_params.smoothing_iterations,
                output_void=embedding_params.output_void_stl,
                output_shell=False,
                shell_thickness=embedding_params.shell_thickness,
                stl_units="mm",
                output_units="mm",
            )
            
            # Export void volume (B)
            if embedding_params.output_void_stl and embed_result.get("void") is not None:
                void_mesh = embed_result["void"]
                void_path = output_path / f"{variant_name}_void_volume.stl"
                void_mesh.export(str(void_path))
                results["paths"]["void_mesh"] = str(void_path)
                logger.info(f"Void volume exported to: {void_path}")
            
            # Export scaffold with voids (C)
            if embedding_params.output_scaffold_stl and embed_result.get("domain_with_void") is not None:
                scaffold_mesh = embed_result["domain_with_void"]
                scaffold_path = output_path / f"{variant_name}_scaffold_with_voids.stl"
                scaffold_mesh.export(str(scaffold_path))
                results["paths"]["scaffold_mesh"] = str(scaffold_path)
                
                logger.info(f"Scaffold mesh exported to: {scaffold_path}")
                logger.info(f"  Vertices: {len(scaffold_mesh.vertices)}")
                logger.info(f"  Faces: {len(scaffold_mesh.faces)}")
                logger.info(f"  Watertight: {scaffold_mesh.is_watertight}")
            
            embed_time = time.time() - embed_start
            results["timing"]["embedding"] = embed_time
            logger.info(f"  Embedding time: {embed_time:.2f} seconds")
                
        except Exception as e:
            error_msg = f"Scaffold embedding error: {e}"
            logger.error(error_msg)
            results["errors"].append(error_msg)
    elif skip_embedding:
        logger.info("-" * 50)
        logger.info("STEP 4: Skipping scaffold embedding (skip_embedding=True)")
        logger.info("-" * 50)
    
    # Step 5: Save parameter sheet and generation report
    logger.info("-" * 50)
    logger.info("STEP 5: Saving parameter sheet and validation report...")
    logger.info("-" * 50)
    
    # Parameter sheet
    param_sheet = {
        "variant": variant_name,
        "units": "millimeters (mm)",
        "insert_geometry": {
            "major_radius_mm": DEFAULT_INSERT_GEOMETRY.major_radius * 1000,
            "minor_radius_mm": DEFAULT_INSERT_GEOMETRY.minor_radius * 1000,
            "depth_mm": DEFAULT_INSERT_GEOMETRY.depth * 1000,
            "wall_thickness_mm": DEFAULT_INSERT_GEOMETRY.wall_thickness * 1000,
        },
        "vessel_dimensions": {
            "outlet_radius_mm": vessels.outlet_radius * 1000,
            "inlet_radius_mm": vessels.inlet_radius * 1000,
            "intermediate_radius_mm": vessels.intermediate_radius * 1000,
            "min_printable_radius_mm": vessels.min_printable_radius * 1000,
            "outlet_to_inlet_ratio": vessels.outlet_radius / vessels.inlet_radius,
            "taper_factor": vessels.taper_factor,
        },
        "colonization": {
            "influence_radius_mm": DEFAULT_COLONIZATION_PARAMS.influence_radius * 1000,
            "kill_radius_mm": DEFAULT_COLONIZATION_PARAMS.kill_radius * 1000,
            "step_size_mm": DEFAULT_COLONIZATION_PARAMS.step_size * 1000,
            "max_steps": DEFAULT_COLONIZATION_PARAMS.max_steps,
            "directional_bias": DEFAULT_COLONIZATION_PARAMS.directional_bias,
            "bifurcation_probability": DEFAULT_COLONIZATION_PARAMS.bifurcation_probability,
        },
    }
    
    param_path = output_path / f"{variant_name}_parameter_sheet.json"
    with open(param_path, "w") as f:
        json.dump(param_sheet, f, indent=2)
    results["paths"]["parameter_sheet"] = str(param_path)
    logger.info(f"Parameter sheet saved to: {param_path}")
    
    # Generation report (validation summary)
    report = {
        "variant": variant_name,
        "success": len(results["errors"]) == 0,
        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
        "units": "millimeters (mm)",
        "validation": validation,
        "timing": results["timing"],
        "output_files": results["paths"],
        "errors": results["errors"],
    }
    
    report_path = output_path / f"{variant_name}_generation_report.json"
    with open(report_path, "w") as f:
        json.dump(report, f, indent=2)
    results["paths"]["report"] = str(report_path)
    logger.info(f"Generation report saved to: {report_path}")
    
    # Final summary
    total_time = sum(results["timing"].values())
    results["timing"]["total"] = total_time
    results["success"] = len(results["errors"]) == 0
    
    logger.info("=" * 70)
    logger.info(f"GENERATION {'COMPLETED' if results['success'] else 'COMPLETED WITH ERRORS'}")
    logger.info(f"  Total time: {total_time:.2f} seconds")
    logger.info(f"  Output files: {len(results['paths'])}")
    if results["errors"]:
        logger.warning(f"  Errors: {len(results['errors'])}")
        for err in results["errors"]:
            logger.warning(f"    - {err}")
    logger.info("=" * 70)
    
    return results


def generate_single_input_insert(
    output_dir: str,
    density: DensityPreset = DensityPreset.MEDIUM,
    min_printable_radius: float = 0.0001,
    seed: int = 42,
    skip_embedding: bool = False,
) -> Dict[str, Any]:
    """
    Generate single-input terminal-venule insert.
    
    Parameters
    ----------
    output_dir : str
        Output directory path
    density : DensityPreset
        Branch density preset (LOW, MEDIUM, HIGH)
    min_printable_radius : float
        Minimum printable radius in meters (based on fabrication method)
    seed : int
        Random seed for reproducibility
    skip_embedding : bool
        If True, skip scaffold embedding step
        
    Returns
    -------
    Dict[str, Any]
        Generation results
    """
    logger.info("\n" + "=" * 70)
    logger.info("SINGLE-INPUT TERMINAL-VENULE INSERT GENERATION")
    logger.info(f"Density preset: {density.value.upper()}")
    logger.info("=" * 70 + "\n")
    
    # Get parameters for density preset
    colonization = get_colonization_params_for_density(density)
    vessels = get_vessel_dimensions_for_density(density, min_printable_radius)
    
    # Validate parameters
    issues = validate_parameters(
        DEFAULT_INSERT_GEOMETRY,
        vessels,
        colonization,
        DEFAULT_EMBEDDING_PARAMS,
    )
    
    if issues:
        logger.warning("Parameter validation issues:")
        for issue in issues:
            logger.warning(f"  {issue}")
    
    # Create spec
    spec = create_single_input_spec(
        vessels=vessels,
        colonization=colonization,
        seed=seed,
    )
    
    # Generate
    return generate_insert(
        spec=spec,
        variant_name="single_input",
        output_dir=output_dir,
        vessels=vessels,
        skip_embedding=skip_embedding,
    )


def generate_multi_input_insert(
    output_dir: str,
    num_inlets: int = 6,
    density: DensityPreset = DensityPreset.MEDIUM,
    min_printable_radius: float = 0.0001,
    seed: int = 42,
    skip_embedding: bool = False,
) -> Dict[str, Any]:
    """
    Generate multi-input terminal-venule insert.
    
    Parameters
    ----------
    output_dir : str
        Output directory path
    num_inlets : int
        Number of inlet ports (4-8 recommended)
    density : DensityPreset
        Branch density preset (LOW, MEDIUM, HIGH)
    min_printable_radius : float
        Minimum printable radius in meters (based on fabrication method)
    seed : int
        Random seed for reproducibility
    skip_embedding : bool
        If True, skip scaffold embedding step
        
    Returns
    -------
    Dict[str, Any]
        Generation results
    """
    logger.info("\n" + "=" * 70)
    logger.info(f"MULTI-INPUT ({num_inlets} INLETS) TERMINAL-VENULE INSERT GENERATION")
    logger.info(f"Density preset: {density.value.upper()}")
    logger.info("=" * 70 + "\n")
    
    # Get parameters for density preset
    colonization = get_colonization_params_for_density(density)
    vessels = get_vessel_dimensions_for_density(density, min_printable_radius)
    
    # Validate parameters
    issues = validate_parameters(
        DEFAULT_INSERT_GEOMETRY,
        vessels,
        colonization,
        DEFAULT_EMBEDDING_PARAMS,
    )
    
    if issues:
        logger.warning("Parameter validation issues:")
        for issue in issues:
            logger.warning(f"  {issue}")
    
    # Create multi-input config
    multi_config = MultiInputConfig(num_inlets=num_inlets)
    
    # Create spec
    spec = create_multi_input_spec(
        vessels=vessels,
        colonization=colonization,
        multi_config=multi_config,
        seed=seed,
    )
    
    # Generate
    return generate_insert(
        spec=spec,
        variant_name="multi_input",
        output_dir=output_dir,
        vessels=vessels,
        skip_embedding=skip_embedding,
    )


# =============================================================================
# COMMAND LINE INTERFACE
# =============================================================================

def main():
    """
    Command-line interface for terminal-venule insert generation.
    
    Usage examples:
        # Generate single-input variant with medium density
        python terminal_venule_insert.py --variant single --output-dir ./output
        
        # Generate multi-input variant with high density
        python terminal_venule_insert.py --variant multi --density high --output-dir ./output
        
        # Generate both variants with 4 inlets
        python terminal_venule_insert.py --variant both --num-inlets 4 --output-dir ./output
        
        # Quick test without embedding
        python terminal_venule_insert.py --variant single --skip-embedding --output-dir ./output
    """
    parser = argparse.ArgumentParser(
        description="Generate terminal-venule insert scaffolds for 48-well plates",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --variant single --output-dir ./output
  %(prog)s --variant multi --density high --num-inlets 6 --output-dir ./output
  %(prog)s --variant both --output-dir ./output
  %(prog)s --variant single --skip-embedding --output-dir ./output

Density Presets:
  low    - Sparse network, faster generation, larger features
  medium - Balanced density (default)
  high   - Dense arborization, slower generation, finer features

Output files:
  {variant}_vascular_network.stl    - Vascular channel mesh (A)
  {variant}_void_volume.stl         - Channels as void volume (B)
  {variant}_scaffold_with_voids.stl - Print-ready scaffold (C)
  {variant}_design_spec.json        - Design specification
  {variant}_parameter_sheet.json    - Parameter documentation
  {variant}_generation_report.json  - Validation summary
        """,
    )
    
    parser.add_argument(
        "--variant", "-v",
        type=str,
        choices=["single", "multi", "both"],
        default="single",
        help="Design variant to generate (default: single)",
    )
    
    parser.add_argument(
        "--density", "-d",
        type=str,
        choices=["low", "medium", "high"],
        default="medium",
        help="Branch density preset (default: medium)",
    )
    
    parser.add_argument(
        "--num-inlets", "-n",
        type=int,
        default=6,
        help="Number of inlets for multi-input variant (default: 6)",
    )
    
    parser.add_argument(
        "--min-radius",
        type=float,
        default=0.1,
        help="Minimum printable radius in mm (default: 0.1mm = 100um)",
    )
    
    parser.add_argument(
        "--output-dir", "-o",
        type=str,
        default="./terminal_venule_output",
        help="Output directory (default: ./terminal_venule_output)",
    )
    
    parser.add_argument(
        "--seed", "-s",
        type=int,
        default=42,
        help="Random seed for reproducibility (default: 42)",
    )
    
    parser.add_argument(
        "--skip-embedding",
        action="store_true",
        help="Skip scaffold embedding step (faster for testing)",
    )
    
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable debug-level logging",
    )
    
    args = parser.parse_args()
    
    # Configure logging level
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Parse density preset
    density = DensityPreset(args.density)
    
    # Convert min radius from mm to meters
    min_printable_radius = args.min_radius / 1000.0
    
    # Print header
    print("\n" + "=" * 70)
    print("TERMINAL-VENULE INSERT GENERATOR")
    print("48-Well Compatible Scaffold with Converging Channel Architecture")
    print("=" * 70)
    print(f"\nVariant: {args.variant}")
    print(f"Density preset: {args.density}")
    print(f"Min printable radius: {args.min_radius}mm")
    print(f"Output directory: {args.output_dir}")
    print(f"Random seed: {args.seed}")
    print(f"Skip embedding: {args.skip_embedding}")
    if args.variant in ["multi", "both"]:
        print(f"Number of inlets: {args.num_inlets}")
    print()
    
    results = {}
    
    # Generate requested variant(s)
    if args.variant in ["single", "both"]:
        results["single"] = generate_single_input_insert(
            output_dir=args.output_dir,
            density=density,
            min_printable_radius=min_printable_radius,
            seed=args.seed,
            skip_embedding=args.skip_embedding,
        )
    
    if args.variant in ["multi", "both"]:
        results["multi"] = generate_multi_input_insert(
            output_dir=args.output_dir,
            num_inlets=args.num_inlets,
            density=density,
            min_printable_radius=min_printable_radius,
            seed=args.seed,
            skip_embedding=args.skip_embedding,
        )
    
    # Print final summary
    print("\n" + "=" * 70)
    print("GENERATION SUMMARY")
    print("=" * 70)
    
    for variant, result in results.items():
        status = "SUCCESS" if result["success"] else "FAILED"
        print(f"\n{variant.upper()} variant: {status}")
        print("  Output files:")
        for name, path in result["paths"].items():
            print(f"    - {name}: {path}")
        if result["errors"]:
            print("  Errors:")
            for err in result["errors"]:
                print(f"    - {err}")
    
    print("\n" + "=" * 70)
    print("Generation complete!")
    print("=" * 70 + "\n")
    
    # Return exit code based on success
    all_success = all(r["success"] for r in results.values())
    return 0 if all_success else 1


if __name__ == "__main__":
    sys.exit(main())
