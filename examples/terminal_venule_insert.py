#!/usr/bin/env python3
"""
Terminal-Venule Insert Generator for 48-Well Plate Compatible Scaffolds

This module generates single-well inserts with terminal-venule-like channel architecture
designed for hepatocyte culture experiments. The design mimics liver sinusoidal topology
where many small tributaries (sinusoid-like channels) converge into a central collecting
venule.

DESIGN BRIEF
------------
The insert combines:
1. Terminal-venule-like channel architecture: many small tributaries converging into
   one central collecting venule
   - Human reference: central venule ~25-150 µm; sinusoids ~7-15 µm
   - Scaled up for printability while preserving topology

2. Open porous scaffold domain around/among channels for:
   - Cell invasion ("dig into")
   - Cell seeding onto scaffold surface
   - Hepatocyte embedding
   - Matrix remodeling

TWO DESIGN VARIANTS
-------------------
1. Single-Input Design:
   - One inlet at the perimeter
   - One central "venule" outlet/sink at the bottom center
   - Creates a simple converging tree topology

2. Multi-Input Design:
   - 4-6 inlets distributed around the perimeter/top
   - All converging to one central "venule" outlet/sink
   - Creates a more complex, radially symmetric converging network

EXPERIMENT PLAN (Comparison)
----------------------------
- Seed/embed hepatocytes in the porous domain
- Compare to organoids and to 2D monolayer
- Readouts: viability, function, infection-related metrics

USAGE
-----
    # Generate single-input variant
    python terminal_venule_insert.py --variant single --output-dir ./output

    # Generate multi-input variant with 6 inlets
    python terminal_venule_insert.py --variant multi --num-inlets 6 --output-dir ./output

    # Generate both variants
    python terminal_venule_insert.py --variant both --output-dir ./output

OUTPUT FILES
------------
For each variant, the following files are generated:
- {variant}_vascular_network.stl: The vascular channel network mesh
- {variant}_scaffold_with_voids.stl: Porous scaffold with channels carved as voids
- {variant}_design_spec.json: The design specification used
- {variant}_generation_report.json: Detailed generation metrics and validation results

Author: Generated by Agentic Organ Generation System
"""

import sys
import os
import json
import time
import math
import argparse
import logging
from pathlib import Path
from typing import Dict, Any, Optional, List, Tuple
from dataclasses import dataclass, asdict

# Add parent directory to path for imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from generation import (
    create_network,
    add_inlet,
    add_outlet,
    VascularNetwork,
)
from generation.specs.design_spec import (
    DesignSpec,
    EllipsoidSpec,
    TreeSpec,
    InletSpec,
    OutletSpec,
)
from generation.specs.compile import compile_domain
from generation.adapters.mesh_adapter import to_trimesh
from generation.ops.embedding import embed_tree_as_negative_space
from generation.backends.cco_hybrid_backend import CCOHybridBackend, CCOConfig
from generation.core.types import Point3D
from generation.core.result import OperationStatus
from generation.core.network import Node, Segment
import numpy as np

# Configure logging for verbose output
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)


# =============================================================================
# TUNABLE CONSTRAINTS AND PARAMETERS
# =============================================================================
# All geometric values are in METERS (internal unit system).
# Output STL files are converted to millimeters by default.
#
# These parameters can be adjusted to customize the insert design for different
# experimental requirements, printing capabilities, or biological constraints.
# =============================================================================

@dataclass
class InsertGeometry:
    """
    Geometric parameters for the 48-well compatible insert.
    
    These define the overall shape and size of the scaffold domain.
    Standard 48-well plates have ~11.3mm diameter wells.
    A typical insert should be 6-8mm diameter to fit with clearance.
    
    Attributes
    ----------
    radius : float
        Insert radius in meters. Default: 0.004m (4mm) for 8mm diameter insert.
        Adjust based on well plate specifications and desired clearance.
        
    height : float
        Insert height in meters. Default: 0.003m (3mm).
        Should be tall enough for adequate channel length but short enough
        to fit in well without interfering with imaging.
        
    wall_margin : float
        Margin from insert edge where channels should not extend, in meters.
        Default: 0.0003m (0.3mm). Ensures structural integrity at edges.
    """
    radius: float = 0.004          # 4mm radius = 8mm diameter insert
    height: float = 0.003          # 3mm height
    wall_margin: float = 0.0003    # 0.3mm margin from walls


@dataclass
class VesselDimensions:
    """
    Vessel radius parameters scaled for printability.
    
    Human liver reference values:
    - Central venule: 25-150 µm diameter
    - Sinusoids: 7-15 µm diameter
    
    These are scaled up significantly for bioprinting compatibility while
    maintaining the topological relationship (sinusoids << venule).
    
    Attributes
    ----------
    central_venule_radius : float
        Radius of the central collecting venule (outlet) in meters.
        Default: 0.0005m (500µm). This is the largest vessel.
        Scaled from human ~75µm to ~500µm for printability.
        
    inlet_radius : float
        Radius of inlet vessels in meters.
        Default: 0.0003m (300µm). Intermediate size.
        
    sinusoid_min_radius : float
        Minimum radius for sinusoid-like terminal branches in meters.
        Default: 0.0001m (100µm). Smallest printable vessel.
        Scaled from human ~10µm to ~100µm for printability.
        
    taper_factor : float
        Radius reduction factor per generation (Murray's law approximation).
        Default: 0.85. Each child branch is 85% of parent radius.
        Range: 0.7-0.95. Lower = faster tapering, more generations.
    """
    central_venule_radius: float = 0.0005   # 500µm - central outlet
    inlet_radius: float = 0.0004            # 400µm - peripheral inlets (must be > BranchingConstraints.min_radius=0.3mm)
    sinusoid_min_radius: float = 0.0003     # 300µm - minimum branch radius (must be >= BranchingConstraints.min_radius)
    taper_factor: float = 0.9               # Radius decay per generation (higher to avoid hitting min_radius too fast)


@dataclass
class CCOParameters:
    """
    CCO (Constrained Constructive Optimization) algorithm parameters for network growth.
    
    These control how the vascular network grows using the CCO hybrid backend,
    which implements Sexton et al.'s accelerated CCO algorithm with:
    - Partial binding optimization
    - Collision avoidance triage
    - Murray's law-based radius scaling
    
    Attributes
    ----------
    num_outlets : int
        Target number of terminal outlets (branch endpoints).
        Default: 20. More outlets = denser network.
        
    murray_exponent : float
        Exponent for Murray's law radius scaling (r_parent^gamma = sum(r_child^gamma)).
        Default: 3.0 (physiological value for blood vessels).
        
    collision_clearance : float
        Minimum clearance between vessel surfaces, in meters.
        Default: 0.0001m (0.1mm). Prevents vessel overlap.
        
    min_segment_length : float
        Minimum allowed segment length, in meters.
        Default: 0.0005m (0.5mm).
        
    max_segment_length : float
        Maximum allowed segment length, in meters.
        Default: 0.010m (10mm).
        
    min_terminal_separation : float
        Minimum distance between terminal outlets, in meters.
        Default: 0.0005m (0.5mm). Prevents clustering.
        
    candidate_edges_k : int
        Number of candidate edges to consider for each insertion.
        Default: 50. Higher = better optimization, slower.
        
    optimization_grid_resolution : int
        Resolution of grid for bifurcation point optimization.
        Default: 10. Higher = finer optimization.
    """
    num_outlets: int = 20                   # Target number of terminal outlets
    murray_exponent: float = 3.0            # Murray's law exponent
    collision_clearance: float = 0.0001     # 0.1mm minimum clearance
    min_segment_length: float = 0.0005      # 0.5mm minimum segment
    max_segment_length: float = 0.010       # 10mm maximum segment
    min_terminal_separation: float = 0.0005 # 0.5mm between terminals
    candidate_edges_k: int = 50             # Candidate edges for optimization
    optimization_grid_resolution: int = 10  # Grid resolution for optimization


@dataclass
class EmbeddingParameters:
    """
    Parameters for embedding vascular network into scaffold domain.
    
    These control the voxelization and boolean operations that create
    the porous scaffold with channels carved as negative space (voids).
    
    Attributes
    ----------
    voxel_pitch : float
        Voxel size for domain discretization, in meters.
        Default: 0.0001m (100µm). Smaller = higher resolution, slower.
        Should be smaller than smallest vessel radius.
        
    shell_thickness : float
        Wall thickness around channels, in meters.
        Default: 0.0003m (300µm). Minimum for structural integrity.
        
    smoothing_iterations : int
        Number of smoothing passes to reduce voxel artifacts.
        Default: 3. Higher = smoother surfaces, slower.
        
    dilation_voxels : int
        Number of voxels to dilate channel volumes.
        Default: 1. Ensures channels are fully open after boolean ops.
    """
    voxel_pitch: float = 0.0001             # 100µm voxel resolution
    shell_thickness: float = 0.0003         # 300µm wall thickness
    smoothing_iterations: int = 3           # Surface smoothing passes
    dilation_voxels: int = 1                # Channel dilation


@dataclass
class MultiInputConfig:
    """
    Configuration for multi-input variant.
    
    Attributes
    ----------
    num_inlets : int
        Number of inlet ports distributed around perimeter.
        Default: 6. Range: 4-8 recommended.
        
    inlet_z_offset : float
        Vertical offset of inlets from top of insert, in meters.
        Default: 0.0005m (0.5mm). Inlets slightly below top surface.
        
    radial_position_fraction : float
        Fraction of radius where inlets are positioned.
        Default: 0.85. Inlets at 85% of radius from center.
        Range: 0.7-0.95. Higher = closer to edge.
    """
    num_inlets: int = 6                     # Number of peripheral inlets
    inlet_z_offset: float = 0.0005          # 0.5mm below top
    radial_position_fraction: float = 0.85  # 85% of radius from center


# =============================================================================
# DEFAULT PARAMETER INSTANCES
# =============================================================================

DEFAULT_INSERT_GEOMETRY = InsertGeometry()
DEFAULT_VESSEL_DIMENSIONS = VesselDimensions()
DEFAULT_CCO_PARAMS = CCOParameters()
DEFAULT_EMBEDDING_PARAMS = EmbeddingParameters()
DEFAULT_MULTI_INPUT_CONFIG = MultiInputConfig()


# =============================================================================
# VALIDATION FUNCTIONS
# =============================================================================

def validate_parameters(
    geometry: InsertGeometry,
    vessels: VesselDimensions,
    cco_params: CCOParameters,
    embedding: EmbeddingParameters,
) -> List[str]:
    """
    Validate parameter combinations and return list of warnings/errors.
    
    Parameters
    ----------
    geometry : InsertGeometry
        Insert geometry parameters
    vessels : VesselDimensions
        Vessel dimension parameters
    cco_params : CCOParameters
        CCO generation parameters
    embedding : EmbeddingParameters
        Embedding parameters
        
    Returns
    -------
    List[str]
        List of validation warnings/errors. Empty if all valid.
    """
    issues = []
    
    # Check vessel radii relationships
    if vessels.sinusoid_min_radius >= vessels.inlet_radius:
        issues.append(
            f"WARNING: sinusoid_min_radius ({vessels.sinusoid_min_radius*1000:.2f}mm) "
            f">= inlet_radius ({vessels.inlet_radius*1000:.2f}mm). "
            "Sinusoids should be smaller than inlets."
        )
    
    if vessels.inlet_radius >= vessels.central_venule_radius:
        issues.append(
            f"WARNING: inlet_radius ({vessels.inlet_radius*1000:.2f}mm) "
            f">= central_venule_radius ({vessels.central_venule_radius*1000:.2f}mm). "
            "Inlets should be smaller than central venule."
        )
    
    # Check voxel pitch vs vessel radii
    if embedding.voxel_pitch >= vessels.sinusoid_min_radius:
        issues.append(
            f"WARNING: voxel_pitch ({embedding.voxel_pitch*1000:.3f}mm) "
            f">= sinusoid_min_radius ({vessels.sinusoid_min_radius*1000:.3f}mm). "
            "Voxel resolution may be too coarse to capture small vessels."
        )
    
    # Check CCO parameters
    if cco_params.min_segment_length >= cco_params.max_segment_length:
        issues.append(
            f"ERROR: min_segment_length ({cco_params.min_segment_length*1000:.2f}mm) "
            f">= max_segment_length ({cco_params.max_segment_length*1000:.2f}mm). "
            "Minimum segment length must be smaller than maximum."
        )
    
    if cco_params.num_outlets < 1:
        issues.append(
            f"ERROR: num_outlets ({cco_params.num_outlets}) must be at least 1."
        )
    
    # Check geometry constraints
    if geometry.wall_margin >= geometry.radius * 0.5:
        issues.append(
            f"WARNING: wall_margin ({geometry.wall_margin*1000:.2f}mm) "
            f">= 50% of radius ({geometry.radius*1000:.2f}mm). "
            "Wall margin is too large, leaving little space for channels."
        )
    
    return issues


def validate_network(
    network: VascularNetwork,
    variant_name: str,
) -> Dict[str, Any]:
    """
    Validate generated vascular network and return detailed metrics.
    
    Parameters
    ----------
    network : VascularNetwork
        Generated vascular network
    variant_name : str
        Name of the variant for logging
        
    Returns
    -------
    Dict[str, Any]
        Validation results including metrics and any issues found
    """
    logger.info(f"Validating {variant_name} network...")
    
    results = {
        "variant": variant_name,
        "valid": True,
        "issues": [],
        "metrics": {},
    }
    
    # Count node types
    node_counts = {
        "inlet": 0,
        "outlet": 0,
        "terminal": 0,
        "junction": 0,
    }
    for node in network.nodes.values():
        node_type = node.node_type
        if node_type in node_counts:
            node_counts[node_type] += 1
    
    results["metrics"]["node_counts"] = node_counts
    results["metrics"]["total_nodes"] = len(network.nodes)
    results["metrics"]["total_segments"] = len(network.segments)
    
    logger.info(f"  Total nodes: {len(network.nodes)}")
    logger.info(f"  Total segments: {len(network.segments)}")
    logger.info(f"  Node breakdown: {node_counts}")
    
    # Check for minimum network complexity
    if len(network.segments) < 5:
        results["issues"].append(
            f"WARNING: Network has only {len(network.segments)} segments. "
            "Expected more complex branching structure."
        )
        results["valid"] = False
    
    # Check for inlets and outlets
    if node_counts["inlet"] == 0:
        results["issues"].append("ERROR: No inlet nodes found in network.")
        results["valid"] = False
    
    if node_counts["outlet"] == 0:
        results["issues"].append("ERROR: No outlet nodes found in network.")
        results["valid"] = False
    
    # Compute segment length statistics
    segment_lengths = []
    segment_radii = []
    for segment in network.segments.values():
        length = segment.geometry.length()
        segment_lengths.append(length)
        segment_radii.append(segment.geometry.mean_radius())
    
    if segment_lengths:
        results["metrics"]["segment_length_stats"] = {
            "min_mm": min(segment_lengths) * 1000,
            "max_mm": max(segment_lengths) * 1000,
            "mean_mm": sum(segment_lengths) / len(segment_lengths) * 1000,
        }
        results["metrics"]["segment_radius_stats"] = {
            "min_mm": min(segment_radii) * 1000,
            "max_mm": max(segment_radii) * 1000,
            "mean_mm": sum(segment_radii) / len(segment_radii) * 1000,
        }
        
        logger.info(f"  Segment lengths: min={min(segment_lengths)*1000:.3f}mm, "
                   f"max={max(segment_lengths)*1000:.3f}mm, "
                   f"mean={sum(segment_lengths)/len(segment_lengths)*1000:.3f}mm")
        logger.info(f"  Segment radii: min={min(segment_radii)*1000:.3f}mm, "
                   f"max={max(segment_radii)*1000:.3f}mm, "
                   f"mean={sum(segment_radii)/len(segment_radii)*1000:.3f}mm")
    
    # Log any issues
    for issue in results["issues"]:
        if issue.startswith("ERROR"):
            logger.error(f"  {issue}")
        else:
            logger.warning(f"  {issue}")
    
    if results["valid"]:
        logger.info(f"  Validation PASSED for {variant_name}")
    else:
        logger.warning(f"  Validation FAILED for {variant_name}")
    
    return results


# =============================================================================
# DESIGN SPECIFICATION CREATION
# =============================================================================

def create_single_input_spec(
    geometry: InsertGeometry = DEFAULT_INSERT_GEOMETRY,
    vessels: VesselDimensions = DEFAULT_VESSEL_DIMENSIONS,
    cco_params: CCOParameters = DEFAULT_CCO_PARAMS,
    seed: int = 42,
) -> DesignSpec:
    """
    Create design specification for single-input terminal-venule insert.
    
    This creates a converging tree topology with:
    - One inlet at the perimeter (top edge)
    - One outlet at the center bottom (central venule)
    - Branching network connecting inlet to outlet using CCO algorithm
    
    Parameters
    ----------
    geometry : InsertGeometry
        Insert geometry parameters
    vessels : VesselDimensions
        Vessel dimension parameters
    cco_params : CCOParameters
        CCO generation parameters
    seed : int
        Random seed for reproducibility
        
    Returns
    -------
    DesignSpec
        Complete design specification for generation
    """
    logger.info("Creating single-input design specification...")
    
    # Define ellipsoid domain (approximating cylindrical insert)
    # Using ellipsoid because BoxDomain doesn't have center attribute needed by design_from_spec
    # Semi-axes: radius for X/Y, height/2 for Z
    domain = EllipsoidSpec(
        type="ellipsoid",
        center=(0.0, 0.0, geometry.height / 2),
        semi_axes=(geometry.radius, geometry.radius, geometry.height / 2),
    )
    
    logger.info(f"  Domain: ellipsoid with semi-axes ({geometry.radius*1000:.1f}mm, "
               f"{geometry.radius*1000:.1f}mm, {geometry.height/2*1000:.1f}mm)")
    
    # Single inlet at perimeter (positive X edge, near top)
    # For ellipsoid domain, we need to ensure the inlet is inside the ellipsoid
    # Ellipsoid equation: (x/a)² + (y/b)² + ((z-cz)/(c))² <= 1
    # Place inlet at 70% of radius on X-axis, at domain center height
    domain_center_z = geometry.height / 2
    inlet_x = geometry.radius * 0.7  # 70% of radius to stay inside ellipsoid
    inlet_z = domain_center_z + (geometry.height / 2) * 0.5  # Upper half of domain
    inlet = InletSpec(
        position=(inlet_x, 0.0, inlet_z),
        radius=vessels.inlet_radius,
        vessel_type="venous",  # Using venous for converging topology
    )
    
    logger.info(f"  Inlet: position=({inlet_x*1000:.2f}, 0, {inlet_z*1000:.2f})mm, "
               f"radius={vessels.inlet_radius*1000:.2f}mm")
    
    # Central outlet at bottom center (the "central venule")
    # Place at domain center height minus some offset to be inside ellipsoid
    outlet_z = domain_center_z - (geometry.height / 2) * 0.5  # Lower half of domain
    outlet = OutletSpec(
        position=(0.0, 0.0, outlet_z),
        radius=vessels.central_venule_radius,
        vessel_type="venous",
    )
    
    logger.info(f"  Outlet (central venule): position=(0, 0, {outlet_z*1000:.2f})mm, "
               f"radius={vessels.central_venule_radius*1000:.2f}mm")
    
    logger.info(f"  CCO params: num_outlets={cco_params.num_outlets}, "
               f"murray_exponent={cco_params.murray_exponent}")
    
    # Create tree spec (colonization is None for CCO-based generation)
    tree = TreeSpec(
        inlets=[inlet],
        outlets=[outlet],
        colonization=None,
    )
    
    # Create full design spec
    spec = DesignSpec(
        domain=domain,
        tree=tree,
        seed=seed,
        metadata={
            "design_type": "terminal_venule_insert",
            "variant": "single_input",
            "description": "Single-input converging venule topology for 48-well insert (CCO)",
            "generation_method": "cco_hybrid",
        },
        output_units="mm",
    )
    
    logger.info("  Single-input design specification created successfully")
    
    return spec


def create_multi_input_spec(
    geometry: InsertGeometry = DEFAULT_INSERT_GEOMETRY,
    vessels: VesselDimensions = DEFAULT_VESSEL_DIMENSIONS,
    cco_params: CCOParameters = DEFAULT_CCO_PARAMS,
    multi_config: MultiInputConfig = DEFAULT_MULTI_INPUT_CONFIG,
    seed: int = 42,
) -> DesignSpec:
    """
    Create design specification for multi-input terminal-venule insert.
    
    This creates a converging tree topology with:
    - Multiple inlets (4-6) distributed radially around the perimeter
    - One outlet at the center bottom (central venule)
    - Multiple branching networks all converging to the central outlet using CCO algorithm
    
    Parameters
    ----------
    geometry : InsertGeometry
        Insert geometry parameters
    vessels : VesselDimensions
        Vessel dimension parameters
    cco_params : CCOParameters
        CCO generation parameters
    multi_config : MultiInputConfig
        Multi-input specific configuration
    seed : int
        Random seed for reproducibility
        
    Returns
    -------
    DesignSpec
        Complete design specification for generation
    """
    logger.info(f"Creating multi-input design specification ({multi_config.num_inlets} inlets)...")
    
    # Define ellipsoid domain (approximating cylindrical insert)
    # Using ellipsoid because BoxDomain doesn't have center attribute needed by design_from_spec
    domain = EllipsoidSpec(
        type="ellipsoid",
        center=(0.0, 0.0, geometry.height / 2),
        semi_axes=(geometry.radius, geometry.radius, geometry.height / 2),
    )
    
    logger.info(f"  Domain: ellipsoid with semi-axes ({geometry.radius*1000:.1f}mm, "
               f"{geometry.radius*1000:.1f}mm, {geometry.height/2*1000:.1f}mm)")
    
    # Create multiple inlets distributed radially
    # For ellipsoid domain, we need to ensure inlets are inside the ellipsoid
    # Ellipsoid equation: (x/a)² + (y/b)² + ((z-cz)/(c))² <= 1
    # Place inlets at 60% of radius to stay safely inside ellipsoid
    inlets = []
    domain_center_z = geometry.height / 2
    inlet_radial_pos = geometry.radius * 0.6  # 60% of radius to stay inside ellipsoid
    inlet_z = domain_center_z + (geometry.height / 2) * 0.4  # Upper portion of domain
    
    for i in range(multi_config.num_inlets):
        angle = 2 * math.pi * i / multi_config.num_inlets
        inlet_x = inlet_radial_pos * math.cos(angle)
        inlet_y = inlet_radial_pos * math.sin(angle)
        
        inlet = InletSpec(
            position=(inlet_x, inlet_y, inlet_z),
            radius=vessels.inlet_radius,
            vessel_type="venous",
        )
        inlets.append(inlet)
        
        logger.info(f"  Inlet {i+1}: position=({inlet_x*1000:.2f}, {inlet_y*1000:.2f}, "
                   f"{inlet_z*1000:.2f})mm, radius={vessels.inlet_radius*1000:.2f}mm")
    
    # Central outlet at bottom center (inside ellipsoid)
    outlet_z = domain_center_z - (geometry.height / 2) * 0.5  # Lower half of domain
    outlet = OutletSpec(
        position=(0.0, 0.0, outlet_z),
        radius=vessels.central_venule_radius,
        vessel_type="venous",
    )
    
    logger.info(f"  Outlet (central venule): position=(0, 0, {outlet_z*1000:.2f})mm, "
               f"radius={vessels.central_venule_radius*1000:.2f}mm")
    
    logger.info(f"  CCO params: num_outlets={cco_params.num_outlets}, "
               f"murray_exponent={cco_params.murray_exponent}")
    
    # Create tree spec (colonization is None for CCO-based generation)
    tree = TreeSpec(
        inlets=inlets,
        outlets=[outlet],
        colonization=None,
    )
    
    # Create full design spec
    spec = DesignSpec(
        domain=domain,
        tree=tree,
        seed=seed,
        metadata={
            "design_type": "terminal_venule_insert",
            "variant": "multi_input",
            "num_inlets": multi_config.num_inlets,
            "description": f"Multi-input ({multi_config.num_inlets} inlets) converging venule topology (CCO)",
            "generation_method": "cco_hybrid",
        },
        output_units="mm",
    )
    
    logger.info("  Multi-input design specification created successfully")
    
    return spec


# =============================================================================
# CUSTOM NETWORK GENERATION (using CCO hybrid backend)
# =============================================================================

def generate_network_from_spec(
    spec: DesignSpec,
    vessels: VesselDimensions = DEFAULT_VESSEL_DIMENSIONS,
    cco_params: CCOParameters = DEFAULT_CCO_PARAMS,
) -> VascularNetwork:
    """
    Generate vascular network from design specification using CCO hybrid backend.
    
    This function uses the CCOHybridBackend which implements Sexton et al.'s
    accelerated CCO algorithm with:
    - Partial binding optimization for fast bifurcation optimization
    - Collision avoidance triage (cheap filter then expensive test)
    - Murray's law-based radius scaling with demand-based splitting
    - Local radius-at-split interpolation for correct bifurcation behavior
    
    For multi-inlet specifications, this generates a separate CCO tree for each
    inlet and merges them into a single network. Each inlet gets an equal share
    of the total target outlets.
    
    Parameters
    ----------
    spec : DesignSpec
        Design specification with domain, tree, and inlet/outlet settings
    vessels : VesselDimensions
        Vessel dimension parameters (in meters)
    cco_params : CCOParameters
        CCO algorithm parameters
        
    Returns
    -------
    VascularNetwork
        Generated vascular network
    """
    logger.info("Generating network using CCO hybrid backend...")
    
    # Compile domain from spec
    domain = compile_domain(spec.domain)
    
    # Get tree spec
    tree = spec.tree
    if tree is None:
        raise ValueError("DesignSpec must have a tree specification")
    
    if not tree.inlets:
        raise ValueError("DesignSpec must have at least one inlet")
    
    # Create CCO configuration
    config = CCOConfig(
        seed=spec.seed,
        murray_exponent=cco_params.murray_exponent,
        collision_clearance=cco_params.collision_clearance,
        min_segment_length=cco_params.min_segment_length,
        max_segment_length=cco_params.max_segment_length,
        min_terminal_separation=cco_params.min_terminal_separation,
        candidate_edges_k=cco_params.candidate_edges_k,
        optimization_grid_resolution=cco_params.optimization_grid_resolution,
        collision_check_enabled=True,
        use_partial_binding=True,
        use_collision_triage=True,
    )
    
    logger.info(f"  CCO config: murray_exponent={config.murray_exponent}, "
               f"collision_clearance={config.collision_clearance*1000:.3f}mm")
    
    # Create CCO backend
    backend = CCOHybridBackend()
    
    num_inlets = len(tree.inlets)
    
    if num_inlets == 1:
        # Single inlet case - generate one tree
        inlet_spec = tree.inlets[0]
        inlet_position = np.array(inlet_spec.position)
        inlet_radius = inlet_spec.radius
        vessel_type = inlet_spec.vessel_type
        
        logger.info(f"  Single inlet: position=({inlet_position[0]*1000:.2f}, "
                   f"{inlet_position[1]*1000:.2f}, {inlet_position[2]*1000:.2f})mm, "
                   f"radius={inlet_radius*1000:.2f}mm")
        logger.info(f"  Target outlets: {cco_params.num_outlets}")
        
        # Generate network using CCO backend
        logger.info(f"  Running CCO generation (num_outlets={cco_params.num_outlets})...")
        network = backend.generate(
            domain=domain,
            num_outlets=cco_params.num_outlets,
            inlet_position=inlet_position,
            inlet_radius=inlet_radius,
            vessel_type=vessel_type,
            config=config,
            rng_seed=spec.seed,
        )
    else:
        # Multi-inlet case - generate separate trees and merge
        logger.info(f"  Multi-inlet mode: {num_inlets} inlets")
        
        # Distribute outlets evenly among inlets
        outlets_per_inlet = max(1, cco_params.num_outlets // num_inlets)
        logger.info(f"  Target outlets per inlet: {outlets_per_inlet}")
        
        # Generate first tree (this becomes the base network)
        inlet_spec = tree.inlets[0]
        inlet_position = np.array(inlet_spec.position)
        inlet_radius = inlet_spec.radius
        vessel_type = inlet_spec.vessel_type
        
        logger.info(f"  Inlet 1: position=({inlet_position[0]*1000:.2f}, "
                   f"{inlet_position[1]*1000:.2f}, {inlet_position[2]*1000:.2f})mm")
        
        network = backend.generate(
            domain=domain,
            num_outlets=outlets_per_inlet,
            inlet_position=inlet_position,
            inlet_radius=inlet_radius,
            vessel_type=vessel_type,
            config=config,
            rng_seed=spec.seed,
        )
        
        # Generate additional trees for remaining inlets and merge
        for i, inlet_spec in enumerate(tree.inlets[1:], start=2):
            inlet_position = np.array(inlet_spec.position)
            inlet_radius = inlet_spec.radius
            vessel_type = inlet_spec.vessel_type
            
            logger.info(f"  Inlet {i}: position=({inlet_position[0]*1000:.2f}, "
                       f"{inlet_position[1]*1000:.2f}, {inlet_position[2]*1000:.2f})mm")
            
            # Generate tree for this inlet with different seed
            tree_network = backend.generate(
                domain=domain,
                num_outlets=outlets_per_inlet,
                inlet_position=inlet_position,
                inlet_radius=inlet_radius,
                vessel_type=vessel_type,
                config=config,
                rng_seed=(spec.seed + i) if spec.seed else None,
            )
            
            # Merge the tree into the main network
            # Create a mapping from old node IDs to new node IDs
            node_id_map = {}
            for old_node in tree_network.nodes.values():
                new_node_id = network.id_gen.next_id()
                new_node = Node(
                    id=new_node_id,
                    position=old_node.position,
                    node_type=old_node.node_type,
                    vessel_type=old_node.vessel_type,
                    attributes=old_node.attributes.copy(),
                )
                network.add_node(new_node)
                node_id_map[old_node.id] = new_node_id
            
            # Add segments with remapped node IDs
            for old_seg in tree_network.segments.values():
                new_seg_id = network.id_gen.next_id()
                new_seg = Segment(
                    id=new_seg_id,
                    start_node_id=node_id_map[old_seg.start_node_id],
                    end_node_id=node_id_map[old_seg.end_node_id],
                    geometry=old_seg.geometry,
                    vessel_type=old_seg.vessel_type,
                    attributes=old_seg.attributes.copy(),
                )
                network.add_segment(new_seg)
            
            logger.info(f"    Merged tree {i}: {len(tree_network.nodes)} nodes, "
                       f"{len(tree_network.segments)} segments")
    
    # Log network statistics
    logger.info(f"  CCO generation complete!")
    logger.info(f"  Network: {len(network.nodes)} nodes, {len(network.segments)} segments")
    
    # Count node types
    node_counts = {"inlet": 0, "outlet": 0, "terminal": 0, "junction": 0}
    for node in network.nodes.values():
        if node.node_type in node_counts:
            node_counts[node.node_type] += 1
    logger.info(f"  Node types: {node_counts}")
    
    return network


# =============================================================================
# GENERATION FUNCTIONS
# =============================================================================

def generate_insert(
    spec: DesignSpec,
    variant_name: str,
    output_dir: str,
    embedding_params: EmbeddingParameters = DEFAULT_EMBEDDING_PARAMS,
    skip_embedding: bool = False,
) -> Dict[str, Any]:
    """
    Generate terminal-venule insert from design specification.
    
    This function:
    1. Validates input parameters
    2. Generates vascular network via space colonization
    3. Validates the generated network
    4. Exports vascular mesh to STL
    5. Creates scaffold with channels as voids (optional)
    6. Saves all artifacts and reports
    
    Parameters
    ----------
    spec : DesignSpec
        Design specification
    variant_name : str
        Name for output files (e.g., "single_input", "multi_input")
    output_dir : str
        Output directory path
    embedding_params : EmbeddingParameters
        Parameters for scaffold embedding
    skip_embedding : bool
        If True, skip the embedding step (faster for testing)
        
    Returns
    -------
    Dict[str, Any]
        Results dictionary containing:
        - success: bool
        - network: VascularNetwork
        - validation: validation results
        - paths: dict of output file paths
        - timing: dict of timing information
        - errors: list of any errors encountered
    """
    logger.info("=" * 70)
    logger.info(f"GENERATING {variant_name.upper()} TERMINAL-VENULE INSERT")
    logger.info("=" * 70)
    
    results = {
        "success": False,
        "variant": variant_name,
        "network": None,
        "validation": None,
        "paths": {},
        "timing": {},
        "errors": [],
    }
    
    # Create output directory
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    logger.info(f"Output directory: {output_path.absolute()}")
    
    # Save design spec
    spec_path = output_path / f"{variant_name}_design_spec.json"
    spec.to_json(str(spec_path))
    results["paths"]["design_spec"] = str(spec_path)
    logger.info(f"Saved design specification to: {spec_path}")
    
    # Step 1: Generate vascular network
    # Using custom generate_network_from_spec to handle unit mismatch
    # (BranchingConstraints uses mm but network operations use meters)
    logger.info("-" * 50)
    logger.info("STEP 1: Generating vascular network...")
    logger.info("-" * 50)
    
    gen_start = time.time()
    try:
        # Use custom generation function with proper constraints in meters
        network = generate_network_from_spec(spec)
        results["network"] = network
        gen_time = time.time() - gen_start
        results["timing"]["network_generation"] = gen_time
        logger.info(f"Network generation completed in {gen_time:.2f} seconds")
    except Exception as e:
        error_msg = f"Network generation failed: {e}"
        logger.error(error_msg)
        results["errors"].append(error_msg)
        return results
    
    # Step 2: Validate network
    logger.info("-" * 50)
    logger.info("STEP 2: Validating generated network...")
    logger.info("-" * 50)
    
    validation = validate_network(network, variant_name)
    results["validation"] = validation
    
    if not validation["valid"]:
        logger.warning("Network validation found issues (see above)")
    
    # Step 3: Export vascular mesh
    logger.info("-" * 50)
    logger.info("STEP 3: Exporting vascular network mesh...")
    logger.info("-" * 50)
    
    mesh_start = time.time()
    try:
        mesh_result = to_trimesh(
            network,
            mode="fast",
            radial_resolution=12,
            include_caps=True,
            include_node_spheres=True,
        )
        
        if mesh_result.is_success():
            mesh = mesh_result.metadata["mesh"]
            mesh_path = output_path / f"{variant_name}_vascular_network.stl"
            mesh.export(str(mesh_path))
            results["paths"]["vascular_mesh"] = str(mesh_path)
            
            mesh_time = time.time() - mesh_start
            results["timing"]["mesh_export"] = mesh_time
            
            logger.info(f"Vascular mesh exported to: {mesh_path}")
            logger.info(f"  Vertices: {len(mesh.vertices)}")
            logger.info(f"  Faces: {len(mesh.faces)}")
            logger.info(f"  Watertight: {mesh.is_watertight}")
            logger.info(f"  Export time: {mesh_time:.2f} seconds")
        else:
            error_msg = f"Mesh export failed: {mesh_result.message}"
            logger.error(error_msg)
            results["errors"].append(error_msg)
    except Exception as e:
        error_msg = f"Mesh export error: {e}"
        logger.error(error_msg)
        results["errors"].append(error_msg)
    
    # Step 4: Create scaffold with voids (optional)
    if not skip_embedding and "vascular_mesh" in results["paths"]:
        logger.info("-" * 50)
        logger.info("STEP 4: Creating porous scaffold with channel voids...")
        logger.info("-" * 50)
        
        embed_start = time.time()
        try:
            # Create runtime domain for embedding
            from generation.specs.compile import compile_domain
            runtime_domain = compile_domain(spec.domain)
            
            logger.info(f"  Voxel pitch: {embedding_params.voxel_pitch*1000:.3f}mm")
            logger.info(f"  Shell thickness: {embedding_params.shell_thickness*1000:.3f}mm")
            logger.info(f"  Smoothing iterations: {embedding_params.smoothing_iterations}")
            
            embed_result = embed_tree_as_negative_space(
                tree_stl_path=results["paths"]["vascular_mesh"],
                domain=runtime_domain,
                voxel_pitch=embedding_params.voxel_pitch,
                dilation_voxels=embedding_params.dilation_voxels,
                smoothing_iters=embedding_params.smoothing_iterations,
                output_void=False,
                output_shell=False,
                shell_thickness=embedding_params.shell_thickness,
                stl_units="mm",
                output_units="mm",
            )
            
            if embed_result.get("domain_with_void") is not None:
                scaffold_mesh = embed_result["domain_with_void"]
                scaffold_path = output_path / f"{variant_name}_scaffold_with_voids.stl"
                scaffold_mesh.export(str(scaffold_path))
                results["paths"]["scaffold_mesh"] = str(scaffold_path)
                
                embed_time = time.time() - embed_start
                results["timing"]["embedding"] = embed_time
                
                logger.info(f"Scaffold mesh exported to: {scaffold_path}")
                logger.info(f"  Vertices: {len(scaffold_mesh.vertices)}")
                logger.info(f"  Faces: {len(scaffold_mesh.faces)}")
                logger.info(f"  Watertight: {scaffold_mesh.is_watertight}")
                logger.info(f"  Embedding time: {embed_time:.2f} seconds")
            else:
                logger.warning("Embedding produced no domain_with_void mesh")
                
        except Exception as e:
            error_msg = f"Scaffold embedding error: {e}"
            logger.error(error_msg)
            results["errors"].append(error_msg)
    elif skip_embedding:
        logger.info("-" * 50)
        logger.info("STEP 4: Skipping scaffold embedding (skip_embedding=True)")
        logger.info("-" * 50)
    
    # Step 5: Save generation report
    logger.info("-" * 50)
    logger.info("STEP 5: Saving generation report...")
    logger.info("-" * 50)
    
    report = {
        "variant": variant_name,
        "success": len(results["errors"]) == 0,
        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
        "validation": validation,
        "timing": results["timing"],
        "output_files": results["paths"],
        "errors": results["errors"],
        "parameters": {
            "geometry": asdict(DEFAULT_INSERT_GEOMETRY),
            "vessels": asdict(DEFAULT_VESSEL_DIMENSIONS),
            "cco_params": asdict(DEFAULT_CCO_PARAMS),
            "embedding": asdict(DEFAULT_EMBEDDING_PARAMS),
        },
    }
    
    report_path = output_path / f"{variant_name}_generation_report.json"
    with open(report_path, "w") as f:
        json.dump(report, f, indent=2)
    results["paths"]["report"] = str(report_path)
    logger.info(f"Generation report saved to: {report_path}")
    
    # Final summary
    total_time = sum(results["timing"].values())
    results["timing"]["total"] = total_time
    results["success"] = len(results["errors"]) == 0
    
    logger.info("=" * 70)
    logger.info(f"GENERATION {'COMPLETED' if results['success'] else 'COMPLETED WITH ERRORS'}")
    logger.info(f"  Total time: {total_time:.2f} seconds")
    logger.info(f"  Output files: {len(results['paths'])}")
    if results["errors"]:
        logger.warning(f"  Errors: {len(results['errors'])}")
        for err in results["errors"]:
            logger.warning(f"    - {err}")
    logger.info("=" * 70)
    
    return results


def generate_single_input_insert(
    output_dir: str,
    seed: int = 42,
    skip_embedding: bool = False,
) -> Dict[str, Any]:
    """
    Generate single-input terminal-venule insert.
    
    Convenience function that creates the spec and generates the insert.
    
    Parameters
    ----------
    output_dir : str
        Output directory path
    seed : int
        Random seed for reproducibility
    skip_embedding : bool
        If True, skip scaffold embedding step
        
    Returns
    -------
    Dict[str, Any]
        Generation results
    """
    logger.info("\n" + "=" * 70)
    logger.info("SINGLE-INPUT TERMINAL-VENULE INSERT GENERATION")
    logger.info("=" * 70 + "\n")
    
    # Validate parameters
    issues = validate_parameters(
        DEFAULT_INSERT_GEOMETRY,
        DEFAULT_VESSEL_DIMENSIONS,
        DEFAULT_CCO_PARAMS,
        DEFAULT_EMBEDDING_PARAMS,
    )
    
    if issues:
        logger.warning("Parameter validation issues:")
        for issue in issues:
            logger.warning(f"  {issue}")
    
    # Create spec
    spec = create_single_input_spec(seed=seed)
    
    # Generate
    return generate_insert(
        spec=spec,
        variant_name="single_input",
        output_dir=output_dir,
        skip_embedding=skip_embedding,
    )


def generate_multi_input_insert(
    output_dir: str,
    num_inlets: int = 6,
    seed: int = 42,
    skip_embedding: bool = False,
) -> Dict[str, Any]:
    """
    Generate multi-input terminal-venule insert.
    
    Convenience function that creates the spec and generates the insert.
    
    Parameters
    ----------
    output_dir : str
        Output directory path
    num_inlets : int
        Number of inlet ports (4-8 recommended)
    seed : int
        Random seed for reproducibility
    skip_embedding : bool
        If True, skip scaffold embedding step
        
    Returns
    -------
    Dict[str, Any]
        Generation results
    """
    logger.info("\n" + "=" * 70)
    logger.info(f"MULTI-INPUT ({num_inlets} INLETS) TERMINAL-VENULE INSERT GENERATION")
    logger.info("=" * 70 + "\n")
    
    # Validate parameters
    issues = validate_parameters(
        DEFAULT_INSERT_GEOMETRY,
        DEFAULT_VESSEL_DIMENSIONS,
        DEFAULT_CCO_PARAMS,
        DEFAULT_EMBEDDING_PARAMS,
    )
    
    if issues:
        logger.warning("Parameter validation issues:")
        for issue in issues:
            logger.warning(f"  {issue}")
    
    # Create multi-input config
    multi_config = MultiInputConfig(num_inlets=num_inlets)
    
    # Create spec
    spec = create_multi_input_spec(multi_config=multi_config, seed=seed)
    
    # Generate
    return generate_insert(
        spec=spec,
        variant_name="multi_input",
        output_dir=output_dir,
        skip_embedding=skip_embedding,
    )


# =============================================================================
# COMMAND LINE INTERFACE
# =============================================================================

def main():
    """
    Command-line interface for terminal-venule insert generation.
    
    Usage examples:
        # Generate single-input variant
        python terminal_venule_insert.py --variant single --output-dir ./output
        
        # Generate multi-input variant with 6 inlets
        python terminal_venule_insert.py --variant multi --num-inlets 6 --output-dir ./output
        
        # Generate both variants
        python terminal_venule_insert.py --variant both --output-dir ./output
        
        # Quick test without embedding (faster)
        python terminal_venule_insert.py --variant single --skip-embedding --output-dir ./output
    """
    parser = argparse.ArgumentParser(
        description="Generate terminal-venule insert scaffolds for 48-well plates",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --variant single --output-dir ./output
  %(prog)s --variant multi --num-inlets 6 --output-dir ./output
  %(prog)s --variant both --output-dir ./output
  %(prog)s --variant single --skip-embedding --output-dir ./output

Output files:
  {variant}_vascular_network.stl    - Vascular channel mesh
  {variant}_scaffold_with_voids.stl - Porous scaffold with channels as voids
  {variant}_design_spec.json        - Design specification
  {variant}_generation_report.json  - Generation metrics and validation
        """,
    )
    
    parser.add_argument(
        "--variant", "-v",
        type=str,
        choices=["single", "multi", "both"],
        default="single",
        help="Design variant to generate (default: single)",
    )
    
    parser.add_argument(
        "--num-inlets", "-n",
        type=int,
        default=6,
        help="Number of inlets for multi-input variant (default: 6)",
    )
    
    parser.add_argument(
        "--output-dir", "-o",
        type=str,
        default="./terminal_venule_output",
        help="Output directory (default: ./terminal_venule_output)",
    )
    
    parser.add_argument(
        "--seed", "-s",
        type=int,
        default=42,
        help="Random seed for reproducibility (default: 42)",
    )
    
    parser.add_argument(
        "--skip-embedding",
        action="store_true",
        help="Skip scaffold embedding step (faster for testing)",
    )
    
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable debug-level logging",
    )
    
    args = parser.parse_args()
    
    # Configure logging level
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Print header
    print("\n" + "=" * 70)
    print("TERMINAL-VENULE INSERT GENERATOR")
    print("48-Well Compatible Scaffold with Converging Channel Architecture")
    print("=" * 70)
    print(f"\nVariant: {args.variant}")
    print(f"Output directory: {args.output_dir}")
    print(f"Random seed: {args.seed}")
    print(f"Skip embedding: {args.skip_embedding}")
    if args.variant in ["multi", "both"]:
        print(f"Number of inlets: {args.num_inlets}")
    print()
    
    results = {}
    
    # Generate requested variant(s)
    if args.variant in ["single", "both"]:
        results["single"] = generate_single_input_insert(
            output_dir=args.output_dir,
            seed=args.seed,
            skip_embedding=args.skip_embedding,
        )
    
    if args.variant in ["multi", "both"]:
        results["multi"] = generate_multi_input_insert(
            output_dir=args.output_dir,
            num_inlets=args.num_inlets,
            seed=args.seed,
            skip_embedding=args.skip_embedding,
        )
    
    # Print final summary
    print("\n" + "=" * 70)
    print("GENERATION SUMMARY")
    print("=" * 70)
    
    for variant, result in results.items():
        status = "SUCCESS" if result["success"] else "FAILED"
        print(f"\n{variant.upper()} variant: {status}")
        print("  Output files:")
        for name, path in result["paths"].items():
            print(f"    - {name}: {path}")
        if result["errors"]:
            print("  Errors:")
            for err in result["errors"]:
                print(f"    - {err}")
    
    print("\n" + "=" * 70)
    print("Generation complete!")
    print("=" * 70 + "\n")
    
    # Return exit code based on success
    all_success = all(r["success"] for r in results.values())
    return 0 if all_success else 1


if __name__ == "__main__":
    sys.exit(main())
