#!/usr/bin/env python3
"""
Terminal-Venule Insert Generator for 48-Well Plate Compatible Scaffolds

This module generates single-well inserts with terminal-venule-like channel architecture
designed for hepatocyte culture experiments. The design mimics liver sinusoidal topology
where many small tributaries (sinusoid-like channels) converge into a central collecting
venule.

DESIGN BRIEF
------------
The insert combines:
1. Terminal-venule-like channel architecture: many small tributaries converging into
   one central collecting venule
   - Human reference: central venule ~25-150 µm; sinusoids ~7-15 µm
   - Scaled up for printability while preserving topology

2. Open porous scaffold domain around/among channels for:
   - Cell invasion ("dig into")
   - Cell seeding onto scaffold surface
   - Hepatocyte embedding
   - Matrix remodeling

TWO DESIGN VARIANTS
-------------------
1. Single-Input Design:
   - One inlet at the perimeter
   - One central "venule" outlet/sink at the bottom center
   - Creates a simple converging tree topology

2. Multi-Input Design:
   - 4-6 inlets distributed around the perimeter/top
   - All converging to one central "venule" outlet/sink
   - Creates a more complex, radially symmetric converging network

EXPERIMENT PLAN (Comparison)
----------------------------
- Seed/embed hepatocytes in the porous domain
- Compare to organoids and to 2D monolayer
- Readouts: viability, function, infection-related metrics

USAGE
-----
    # Generate single-input variant
    python terminal_venule_insert.py --variant single --output-dir ./output

    # Generate multi-input variant with 6 inlets
    python terminal_venule_insert.py --variant multi --num-inlets 6 --output-dir ./output

    # Generate both variants
    python terminal_venule_insert.py --variant both --output-dir ./output

OUTPUT FILES
------------
For each variant, the following files are generated:
- {variant}_vascular_network.stl: The vascular channel network mesh
- {variant}_scaffold_with_voids.stl: Porous scaffold with channels carved as voids
- {variant}_design_spec.json: The design specification used
- {variant}_generation_report.json: Detailed generation metrics and validation results

Author: Generated by Agentic Organ Generation System
"""

import sys
import os
import json
import time
import math
import argparse
import logging
from pathlib import Path
from typing import Dict, Any, Optional, List, Tuple
from dataclasses import dataclass, asdict

# Add parent directory to path for imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from generation import (
    design_from_spec,
    create_network,
    add_inlet,
    add_outlet,
    space_colonization_step,
    VascularNetwork,
    BoxDomain,
)
from generation.specs.design_spec import (
    DesignSpec,
    BoxSpec,
    EllipsoidSpec,
    TreeSpec,
    InletSpec,
    OutletSpec,
    ColonizationSpec,
)
from generation.specs.compile import compile_domain
from generation.adapters.mesh_adapter import to_trimesh, export_stl
from generation.ops.embedding import embed_tree_as_negative_space
from generation.ops.space_colonization import SpaceColonizationParams
from generation.rules.constraints import BranchingConstraints
from generation.core.types import Point3D
from generation.core.result import OperationStatus
import numpy as np

# Configure logging for verbose output
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)


# =============================================================================
# TUNABLE CONSTRAINTS AND PARAMETERS
# =============================================================================
# All geometric values are in METERS (internal unit system).
# Output STL files are converted to millimeters by default.
#
# These parameters can be adjusted to customize the insert design for different
# experimental requirements, printing capabilities, or biological constraints.
# =============================================================================

@dataclass
class InsertGeometry:
    """
    Geometric parameters for the 48-well compatible insert.
    
    These define the overall shape and size of the scaffold domain.
    Standard 48-well plates have ~11.3mm diameter wells.
    A typical insert should be 6-8mm diameter to fit with clearance.
    
    Attributes
    ----------
    radius : float
        Insert radius in meters. Default: 0.004m (4mm) for 8mm diameter insert.
        Adjust based on well plate specifications and desired clearance.
        
    height : float
        Insert height in meters. Default: 0.003m (3mm).
        Should be tall enough for adequate channel length but short enough
        to fit in well without interfering with imaging.
        
    wall_margin : float
        Margin from insert edge where channels should not extend, in meters.
        Default: 0.0003m (0.3mm). Ensures structural integrity at edges.
    """
    radius: float = 0.004          # 4mm radius = 8mm diameter insert
    height: float = 0.003          # 3mm height
    wall_margin: float = 0.0003    # 0.3mm margin from walls


@dataclass
class VesselDimensions:
    """
    Vessel radius parameters scaled for printability.
    
    Human liver reference values:
    - Central venule: 25-150 µm diameter
    - Sinusoids: 7-15 µm diameter
    
    These are scaled up significantly for bioprinting compatibility while
    maintaining the topological relationship (sinusoids << venule).
    
    Attributes
    ----------
    central_venule_radius : float
        Radius of the central collecting venule (outlet) in meters.
        Default: 0.0005m (500µm). This is the largest vessel.
        Scaled from human ~75µm to ~500µm for printability.
        
    inlet_radius : float
        Radius of inlet vessels in meters.
        Default: 0.0003m (300µm). Intermediate size.
        
    sinusoid_min_radius : float
        Minimum radius for sinusoid-like terminal branches in meters.
        Default: 0.0001m (100µm). Smallest printable vessel.
        Scaled from human ~10µm to ~100µm for printability.
        
    taper_factor : float
        Radius reduction factor per generation (Murray's law approximation).
        Default: 0.85. Each child branch is 85% of parent radius.
        Range: 0.7-0.95. Lower = faster tapering, more generations.
    """
    central_venule_radius: float = 0.0005   # 500µm - central outlet
    inlet_radius: float = 0.0004            # 400µm - peripheral inlets (must be > BranchingConstraints.min_radius=0.3mm)
    sinusoid_min_radius: float = 0.0003     # 300µm - minimum branch radius (must be >= BranchingConstraints.min_radius)
    taper_factor: float = 0.9               # Radius decay per generation (higher to avoid hitting min_radius too fast)


@dataclass
class ColonizationParameters:
    """
    Space colonization algorithm parameters for network growth.
    
    These control how the vascular network grows from inlets toward the
    central outlet, creating the converging tree topology.
    
    Attributes
    ----------
    influence_radius : float
        Radius within which tissue points attract growing tips, in meters.
        Default: 0.002m (2mm). Larger = longer-range attraction, sparser network.
        
    kill_radius : float
        Radius within which tissue points are considered "perfused" and removed.
        Default: 0.0004m (0.4mm). Smaller = denser network coverage.
        
    step_size : float
        Growth step size per iteration, in meters.
        Default: 0.0003m (0.3mm). Smaller = smoother curves, more iterations.
        
    max_steps : int
        Maximum number of growth iterations.
        Default: 200. Increase for denser networks, decrease for faster generation.
        
    directional_bias : float
        Weight for preferred direction (toward center) vs pure attraction.
        Range: 0.0-1.0. Default: 0.3.
        0.0 = pure attraction-based growth
        1.0 = pure directional growth toward center
        
    smoothing_weight : float
        Weight for smoothing growth direction with previous direction.
        Range: 0.0-1.0. Default: 0.3.
        Higher = smoother, more gradual curves.
        
    encourage_bifurcation : bool
        Whether to encourage branching at nodes with multiple attractions.
        Default: True. Creates more realistic tree topology.
        
    bifurcation_probability : float
        Probability of bifurcating when conditions are met.
        Range: 0.0-1.0. Default: 0.6.
        
    bifurcation_angle_threshold_deg : float
        Minimum angle spread (degrees) between attractions to trigger bifurcation.
        Default: 35.0 degrees.
    """
    influence_radius: float = 0.004         # 4mm attraction range (larger for small domain)
    kill_radius: float = 0.001              # 1.0mm perfusion radius
    step_size: float = 0.001                # 1.0mm growth step (must be >= BranchingConstraints.min_segment_length)
    max_steps: int = 50                     # Maximum iterations
    directional_bias: float = 0.3           # Bias toward center
    smoothing_weight: float = 0.3           # Direction smoothing
    encourage_bifurcation: bool = True      # Enable branching
    bifurcation_probability: float = 0.6    # Branching probability
    bifurcation_angle_threshold_deg: float = 35.0  # Min angle for bifurcation


@dataclass
class EmbeddingParameters:
    """
    Parameters for embedding vascular network into scaffold domain.
    
    These control the voxelization and boolean operations that create
    the porous scaffold with channels carved as negative space (voids).
    
    Attributes
    ----------
    voxel_pitch : float
        Voxel size for domain discretization, in meters.
        Default: 0.0001m (100µm). Smaller = higher resolution, slower.
        Should be smaller than smallest vessel radius.
        
    shell_thickness : float
        Wall thickness around channels, in meters.
        Default: 0.0003m (300µm). Minimum for structural integrity.
        
    smoothing_iterations : int
        Number of smoothing passes to reduce voxel artifacts.
        Default: 3. Higher = smoother surfaces, slower.
        
    dilation_voxels : int
        Number of voxels to dilate channel volumes.
        Default: 1. Ensures channels are fully open after boolean ops.
    """
    voxel_pitch: float = 0.0001             # 100µm voxel resolution
    shell_thickness: float = 0.0003         # 300µm wall thickness
    smoothing_iterations: int = 3           # Surface smoothing passes
    dilation_voxels: int = 1                # Channel dilation


@dataclass
class MultiInputConfig:
    """
    Configuration for multi-input variant.
    
    Attributes
    ----------
    num_inlets : int
        Number of inlet ports distributed around perimeter.
        Default: 6. Range: 4-8 recommended.
        
    inlet_z_offset : float
        Vertical offset of inlets from top of insert, in meters.
        Default: 0.0005m (0.5mm). Inlets slightly below top surface.
        
    radial_position_fraction : float
        Fraction of radius where inlets are positioned.
        Default: 0.85. Inlets at 85% of radius from center.
        Range: 0.7-0.95. Higher = closer to edge.
    """
    num_inlets: int = 6                     # Number of peripheral inlets
    inlet_z_offset: float = 0.0005          # 0.5mm below top
    radial_position_fraction: float = 0.85  # 85% of radius from center


# =============================================================================
# DEFAULT PARAMETER INSTANCES
# =============================================================================

DEFAULT_INSERT_GEOMETRY = InsertGeometry()
DEFAULT_VESSEL_DIMENSIONS = VesselDimensions()
DEFAULT_COLONIZATION_PARAMS = ColonizationParameters()
DEFAULT_EMBEDDING_PARAMS = EmbeddingParameters()
DEFAULT_MULTI_INPUT_CONFIG = MultiInputConfig()


# =============================================================================
# VALIDATION FUNCTIONS
# =============================================================================

def validate_parameters(
    geometry: InsertGeometry,
    vessels: VesselDimensions,
    colonization: ColonizationParameters,
    embedding: EmbeddingParameters,
) -> List[str]:
    """
    Validate parameter combinations and return list of warnings/errors.
    
    Parameters
    ----------
    geometry : InsertGeometry
        Insert geometry parameters
    vessels : VesselDimensions
        Vessel dimension parameters
    colonization : ColonizationParameters
        Space colonization parameters
    embedding : EmbeddingParameters
        Embedding parameters
        
    Returns
    -------
    List[str]
        List of validation warnings/errors. Empty if all valid.
    """
    issues = []
    
    # Check vessel radii relationships
    if vessels.sinusoid_min_radius >= vessels.inlet_radius:
        issues.append(
            f"WARNING: sinusoid_min_radius ({vessels.sinusoid_min_radius*1000:.2f}mm) "
            f">= inlet_radius ({vessels.inlet_radius*1000:.2f}mm). "
            "Sinusoids should be smaller than inlets."
        )
    
    if vessels.inlet_radius >= vessels.central_venule_radius:
        issues.append(
            f"WARNING: inlet_radius ({vessels.inlet_radius*1000:.2f}mm) "
            f">= central_venule_radius ({vessels.central_venule_radius*1000:.2f}mm). "
            "Inlets should be smaller than central venule."
        )
    
    # Check voxel pitch vs vessel radii
    if embedding.voxel_pitch >= vessels.sinusoid_min_radius:
        issues.append(
            f"WARNING: voxel_pitch ({embedding.voxel_pitch*1000:.3f}mm) "
            f">= sinusoid_min_radius ({vessels.sinusoid_min_radius*1000:.3f}mm). "
            "Voxel resolution may be too coarse to capture small vessels."
        )
    
    # Check colonization parameters
    if colonization.kill_radius >= colonization.influence_radius:
        issues.append(
            f"ERROR: kill_radius ({colonization.kill_radius*1000:.2f}mm) "
            f">= influence_radius ({colonization.influence_radius*1000:.2f}mm). "
            "Kill radius must be smaller than influence radius."
        )
    
    if colonization.step_size >= colonization.influence_radius:
        issues.append(
            f"WARNING: step_size ({colonization.step_size*1000:.2f}mm) "
            f">= influence_radius ({colonization.influence_radius*1000:.2f}mm). "
            "Step size should be smaller than influence radius for smooth growth."
        )
    
    # Check geometry constraints
    if geometry.wall_margin >= geometry.radius * 0.5:
        issues.append(
            f"WARNING: wall_margin ({geometry.wall_margin*1000:.2f}mm) "
            f">= 50% of radius ({geometry.radius*1000:.2f}mm). "
            "Wall margin is too large, leaving little space for channels."
        )
    
    return issues


def validate_network(
    network: VascularNetwork,
    variant_name: str,
) -> Dict[str, Any]:
    """
    Validate generated vascular network and return detailed metrics.
    
    Parameters
    ----------
    network : VascularNetwork
        Generated vascular network
    variant_name : str
        Name of the variant for logging
        
    Returns
    -------
    Dict[str, Any]
        Validation results including metrics and any issues found
    """
    logger.info(f"Validating {variant_name} network...")
    
    results = {
        "variant": variant_name,
        "valid": True,
        "issues": [],
        "metrics": {},
    }
    
    # Count node types
    node_counts = {
        "inlet": 0,
        "outlet": 0,
        "terminal": 0,
        "junction": 0,
    }
    for node in network.nodes.values():
        node_type = node.node_type
        if node_type in node_counts:
            node_counts[node_type] += 1
    
    results["metrics"]["node_counts"] = node_counts
    results["metrics"]["total_nodes"] = len(network.nodes)
    results["metrics"]["total_segments"] = len(network.segments)
    
    logger.info(f"  Total nodes: {len(network.nodes)}")
    logger.info(f"  Total segments: {len(network.segments)}")
    logger.info(f"  Node breakdown: {node_counts}")
    
    # Check for minimum network complexity
    if len(network.segments) < 5:
        results["issues"].append(
            f"WARNING: Network has only {len(network.segments)} segments. "
            "Expected more complex branching structure."
        )
        results["valid"] = False
    
    # Check for inlets and outlets
    if node_counts["inlet"] == 0:
        results["issues"].append("ERROR: No inlet nodes found in network.")
        results["valid"] = False
    
    if node_counts["outlet"] == 0:
        results["issues"].append("ERROR: No outlet nodes found in network.")
        results["valid"] = False
    
    # Compute segment length statistics
    segment_lengths = []
    segment_radii = []
    for segment in network.segments.values():
        length = segment.geometry.length()
        segment_lengths.append(length)
        segment_radii.append(segment.geometry.mean_radius())
    
    if segment_lengths:
        results["metrics"]["segment_length_stats"] = {
            "min_mm": min(segment_lengths) * 1000,
            "max_mm": max(segment_lengths) * 1000,
            "mean_mm": sum(segment_lengths) / len(segment_lengths) * 1000,
        }
        results["metrics"]["segment_radius_stats"] = {
            "min_mm": min(segment_radii) * 1000,
            "max_mm": max(segment_radii) * 1000,
            "mean_mm": sum(segment_radii) / len(segment_radii) * 1000,
        }
        
        logger.info(f"  Segment lengths: min={min(segment_lengths)*1000:.3f}mm, "
                   f"max={max(segment_lengths)*1000:.3f}mm, "
                   f"mean={sum(segment_lengths)/len(segment_lengths)*1000:.3f}mm")
        logger.info(f"  Segment radii: min={min(segment_radii)*1000:.3f}mm, "
                   f"max={max(segment_radii)*1000:.3f}mm, "
                   f"mean={sum(segment_radii)/len(segment_radii)*1000:.3f}mm")
    
    # Log any issues
    for issue in results["issues"]:
        if issue.startswith("ERROR"):
            logger.error(f"  {issue}")
        else:
            logger.warning(f"  {issue}")
    
    if results["valid"]:
        logger.info(f"  Validation PASSED for {variant_name}")
    else:
        logger.warning(f"  Validation FAILED for {variant_name}")
    
    return results


# =============================================================================
# DESIGN SPECIFICATION CREATION
# =============================================================================

def create_single_input_spec(
    geometry: InsertGeometry = DEFAULT_INSERT_GEOMETRY,
    vessels: VesselDimensions = DEFAULT_VESSEL_DIMENSIONS,
    colonization: ColonizationParameters = DEFAULT_COLONIZATION_PARAMS,
    seed: int = 42,
) -> DesignSpec:
    """
    Create design specification for single-input terminal-venule insert.
    
    This creates a converging tree topology with:
    - One inlet at the perimeter (top edge)
    - One outlet at the center bottom (central venule)
    - Branching network connecting inlet to outlet
    
    Parameters
    ----------
    geometry : InsertGeometry
        Insert geometry parameters
    vessels : VesselDimensions
        Vessel dimension parameters
    colonization : ColonizationParameters
        Space colonization parameters
    seed : int
        Random seed for reproducibility
        
    Returns
    -------
    DesignSpec
        Complete design specification for generation
    """
    logger.info("Creating single-input design specification...")
    
    # Define ellipsoid domain (approximating cylindrical insert)
    # Using ellipsoid because BoxDomain doesn't have center attribute needed by design_from_spec
    # Semi-axes: radius for X/Y, height/2 for Z
    domain = EllipsoidSpec(
        type="ellipsoid",
        center=(0.0, 0.0, geometry.height / 2),
        semi_axes=(geometry.radius, geometry.radius, geometry.height / 2),
    )
    
    logger.info(f"  Domain: ellipsoid with semi-axes ({geometry.radius*1000:.1f}mm, "
               f"{geometry.radius*1000:.1f}mm, {geometry.height/2*1000:.1f}mm)")
    
    # Single inlet at perimeter (positive X edge, near top)
    # For ellipsoid domain, we need to ensure the inlet is inside the ellipsoid
    # Ellipsoid equation: (x/a)² + (y/b)² + ((z-cz)/(c))² <= 1
    # Place inlet at 70% of radius on X-axis, at domain center height
    domain_center_z = geometry.height / 2
    inlet_x = geometry.radius * 0.7  # 70% of radius to stay inside ellipsoid
    inlet_z = domain_center_z + (geometry.height / 2) * 0.5  # Upper half of domain
    inlet = InletSpec(
        position=(inlet_x, 0.0, inlet_z),
        radius=vessels.inlet_radius,
        vessel_type="venous",  # Using venous for converging topology
    )
    
    logger.info(f"  Inlet: position=({inlet_x*1000:.2f}, 0, {inlet_z*1000:.2f})mm, "
               f"radius={vessels.inlet_radius*1000:.2f}mm")
    
    # Central outlet at bottom center (the "central venule")
    # Place at domain center height minus some offset to be inside ellipsoid
    outlet_z = domain_center_z - (geometry.height / 2) * 0.5  # Lower half of domain
    outlet = OutletSpec(
        position=(0.0, 0.0, outlet_z),
        radius=vessels.central_venule_radius,
        vessel_type="venous",
    )
    
    logger.info(f"  Outlet (central venule): position=(0, 0, {outlet_z*1000:.2f})mm, "
               f"radius={vessels.central_venule_radius*1000:.2f}mm")
    
    # Colonization parameters with directional bias toward center
    # Preferred direction points from inlet toward outlet (toward center and down)
    preferred_dir = (-inlet_x, 0.0, outlet_z - inlet_z)
    # Normalize
    dir_length = math.sqrt(preferred_dir[0]**2 + preferred_dir[1]**2 + preferred_dir[2]**2)
    preferred_dir = (
        preferred_dir[0] / dir_length,
        preferred_dir[1] / dir_length,
        preferred_dir[2] / dir_length,
    )
    
    col_spec = ColonizationSpec(
        influence_radius=colonization.influence_radius,
        kill_radius=colonization.kill_radius,
        step_size=colonization.step_size,
        max_steps=colonization.max_steps,
        initial_radius=vessels.inlet_radius,
        min_radius=vessels.sinusoid_min_radius,
        radius_decay=vessels.taper_factor,
        preferred_direction=preferred_dir,
        directional_bias=colonization.directional_bias,
        smoothing_weight=colonization.smoothing_weight,
        encourage_bifurcation=colonization.encourage_bifurcation,
        bifurcation_probability=colonization.bifurcation_probability,
        bifurcation_angle_threshold_deg=colonization.bifurcation_angle_threshold_deg,
    )
    
    logger.info(f"  Colonization: influence_radius={colonization.influence_radius*1000:.2f}mm, "
               f"kill_radius={colonization.kill_radius*1000:.2f}mm, "
               f"max_steps={colonization.max_steps}")
    logger.info(f"  Preferred direction: {preferred_dir}")
    
    # Create tree spec
    tree = TreeSpec(
        inlets=[inlet],
        outlets=[outlet],
        colonization=col_spec,
    )
    
    # Create full design spec
    spec = DesignSpec(
        domain=domain,
        tree=tree,
        seed=seed,
        metadata={
            "design_type": "terminal_venule_insert",
            "variant": "single_input",
            "description": "Single-input converging venule topology for 48-well insert",
        },
        output_units="mm",
    )
    
    logger.info("  Single-input design specification created successfully")
    
    return spec


def create_multi_input_spec(
    geometry: InsertGeometry = DEFAULT_INSERT_GEOMETRY,
    vessels: VesselDimensions = DEFAULT_VESSEL_DIMENSIONS,
    colonization: ColonizationParameters = DEFAULT_COLONIZATION_PARAMS,
    multi_config: MultiInputConfig = DEFAULT_MULTI_INPUT_CONFIG,
    seed: int = 42,
) -> DesignSpec:
    """
    Create design specification for multi-input terminal-venule insert.
    
    This creates a converging tree topology with:
    - Multiple inlets (4-6) distributed radially around the perimeter
    - One outlet at the center bottom (central venule)
    - Multiple branching networks all converging to the central outlet
    
    Parameters
    ----------
    geometry : InsertGeometry
        Insert geometry parameters
    vessels : VesselDimensions
        Vessel dimension parameters
    colonization : ColonizationParameters
        Space colonization parameters
    multi_config : MultiInputConfig
        Multi-input specific configuration
    seed : int
        Random seed for reproducibility
        
    Returns
    -------
    DesignSpec
        Complete design specification for generation
    """
    logger.info(f"Creating multi-input design specification ({multi_config.num_inlets} inlets)...")
    
    # Define ellipsoid domain (approximating cylindrical insert)
    # Using ellipsoid because BoxDomain doesn't have center attribute needed by design_from_spec
    domain = EllipsoidSpec(
        type="ellipsoid",
        center=(0.0, 0.0, geometry.height / 2),
        semi_axes=(geometry.radius, geometry.radius, geometry.height / 2),
    )
    
    logger.info(f"  Domain: ellipsoid with semi-axes ({geometry.radius*1000:.1f}mm, "
               f"{geometry.radius*1000:.1f}mm, {geometry.height/2*1000:.1f}mm)")
    
    # Create multiple inlets distributed radially
    # For ellipsoid domain, we need to ensure inlets are inside the ellipsoid
    # Ellipsoid equation: (x/a)² + (y/b)² + ((z-cz)/(c))² <= 1
    # Place inlets at 60% of radius to stay safely inside ellipsoid
    inlets = []
    domain_center_z = geometry.height / 2
    inlet_radial_pos = geometry.radius * 0.6  # 60% of radius to stay inside ellipsoid
    inlet_z = domain_center_z + (geometry.height / 2) * 0.4  # Upper portion of domain
    
    for i in range(multi_config.num_inlets):
        angle = 2 * math.pi * i / multi_config.num_inlets
        inlet_x = inlet_radial_pos * math.cos(angle)
        inlet_y = inlet_radial_pos * math.sin(angle)
        
        inlet = InletSpec(
            position=(inlet_x, inlet_y, inlet_z),
            radius=vessels.inlet_radius,
            vessel_type="venous",
        )
        inlets.append(inlet)
        
        logger.info(f"  Inlet {i+1}: position=({inlet_x*1000:.2f}, {inlet_y*1000:.2f}, "
                   f"{inlet_z*1000:.2f})mm, radius={vessels.inlet_radius*1000:.2f}mm")
    
    # Central outlet at bottom center (inside ellipsoid)
    outlet_z = domain_center_z - (geometry.height / 2) * 0.5  # Lower half of domain
    outlet = OutletSpec(
        position=(0.0, 0.0, outlet_z),
        radius=vessels.central_venule_radius,
        vessel_type="venous",
    )
    
    logger.info(f"  Outlet (central venule): position=(0, 0, {outlet_z*1000:.2f})mm, "
               f"radius={vessels.central_venule_radius*1000:.2f}mm")
    
    # Colonization parameters - preferred direction toward center (0, 0, outlet_z)
    # Since inlets are distributed radially, we use a downward bias
    preferred_dir = (0.0, 0.0, -1.0)  # Straight down toward outlet
    
    col_spec = ColonizationSpec(
        influence_radius=colonization.influence_radius,
        kill_radius=colonization.kill_radius,
        step_size=colonization.step_size,
        max_steps=colonization.max_steps,
        initial_radius=vessels.inlet_radius,
        min_radius=vessels.sinusoid_min_radius,
        radius_decay=vessels.taper_factor,
        preferred_direction=preferred_dir,
        directional_bias=colonization.directional_bias,
        smoothing_weight=colonization.smoothing_weight,
        encourage_bifurcation=colonization.encourage_bifurcation,
        bifurcation_probability=colonization.bifurcation_probability,
        bifurcation_angle_threshold_deg=colonization.bifurcation_angle_threshold_deg,
    )
    
    logger.info(f"  Colonization: influence_radius={colonization.influence_radius*1000:.2f}mm, "
               f"kill_radius={colonization.kill_radius*1000:.2f}mm, "
               f"max_steps={colonization.max_steps}")
    
    # Create tree spec
    tree = TreeSpec(
        inlets=inlets,
        outlets=[outlet],
        colonization=col_spec,
    )
    
    # Create full design spec
    spec = DesignSpec(
        domain=domain,
        tree=tree,
        seed=seed,
        metadata={
            "design_type": "terminal_venule_insert",
            "variant": "multi_input",
            "num_inlets": multi_config.num_inlets,
            "description": f"Multi-input ({multi_config.num_inlets} inlets) converging venule topology",
        },
        output_units="mm",
    )
    
    logger.info("  Multi-input design specification created successfully")
    
    return spec


# =============================================================================
# CUSTOM NETWORK GENERATION (with proper constraints in meters)
# =============================================================================

def generate_network_from_spec(
    spec: DesignSpec,
    vessels: VesselDimensions = DEFAULT_VESSEL_DIMENSIONS,
    colonization: ColonizationParameters = DEFAULT_COLONIZATION_PARAMS,
) -> VascularNetwork:
    """
    Generate vascular network from design specification with proper constraints.
    
    This function bypasses design_from_spec to use custom BranchingConstraints
    with values in meters (the internal unit system) rather than millimeters.
    
    The default BranchingConstraints uses millimeters, but all network operations
    use meters internally, causing a unit mismatch. This function creates
    constraints in meters to ensure proper network generation.
    
    Parameters
    ----------
    spec : DesignSpec
        Design specification with domain, tree, and colonization settings
    vessels : VesselDimensions
        Vessel dimension parameters (in meters)
    colonization : ColonizationParameters
        Colonization algorithm parameters (in meters)
        
    Returns
    -------
    VascularNetwork
        Generated vascular network
    """
    logger.info("Generating network with custom constraints (in meters)...")
    
    # Compile domain from spec
    domain = compile_domain(spec.domain)
    
    # Create network
    network = create_network(domain=domain, seed=spec.seed)
    
    # Get tree spec
    tree = spec.tree
    if tree is None:
        raise ValueError("DesignSpec must have a tree specification")
    
    # Compute domain center for direction calculations
    domain_center = np.array([domain.center.x, domain.center.y, domain.center.z])
    
    # Add inlets
    for inlet_spec in tree.inlets:
        inlet_pos = np.array(inlet_spec.position)
        # Direction points inward from inlet toward domain center
        direction_vec = domain_center - inlet_pos
        direction_norm = np.linalg.norm(direction_vec)
        if direction_norm > 1e-9:
            direction = tuple(direction_vec / direction_norm)
        else:
            direction = (0.0, 0.0, -1.0)  # Default downward
        
        result = add_inlet(
            network,
            position=Point3D(*inlet_spec.position),
            radius=inlet_spec.radius,
            vessel_type=inlet_spec.vessel_type,
            direction=direction,
        )
        if not result.is_success():
            logger.warning(f"Failed to add inlet: {result.message}")
    
    # Add outlets
    for outlet_spec in tree.outlets:
        outlet_pos = np.array(outlet_spec.position)
        # Direction points outward from domain center toward outlet
        direction_vec = outlet_pos - domain_center
        direction_norm = np.linalg.norm(direction_vec)
        if direction_norm > 1e-9:
            direction = tuple(direction_vec / direction_norm)
        else:
            direction = (0.0, 0.0, 1.0)  # Default upward
        
        result = add_outlet(
            network,
            position=Point3D(*outlet_spec.position),
            radius=outlet_spec.radius,
            vessel_type=outlet_spec.vessel_type,
            direction=direction,
        )
        if not result.is_success():
            logger.warning(f"Failed to add outlet: {result.message}")
    
    # Sample tissue points from domain
    tissue_points = domain.sample_points(n_points=1000, seed=spec.seed)
    logger.info(f"  Sampled {len(tissue_points)} tissue points from domain")
    
    # Create custom BranchingConstraints in METERS (not millimeters)
    # The default BranchingConstraints uses mm, but network operations use meters
    constraints = BranchingConstraints(
        min_radius=vessels.sinusoid_min_radius,      # In meters
        max_radius=vessels.central_venule_radius * 2, # In meters
        min_segment_length=colonization.step_size * 0.5,  # In meters
        max_segment_length=colonization.step_size * 10,   # In meters
        max_branch_order=20,
        max_branch_angle_deg=80.0,
    )
    logger.info(f"  Custom constraints: min_radius={constraints.min_radius*1000:.3f}mm, "
               f"min_segment_length={constraints.min_segment_length*1000:.3f}mm")
    
    # Get colonization spec
    col_spec = tree.colonization
    
    # Create SpaceColonizationParams
    params = SpaceColonizationParams(
        influence_radius=col_spec.influence_radius,
        kill_radius=col_spec.kill_radius,
        step_size=col_spec.step_size,
        min_radius=col_spec.min_radius,
        taper_factor=col_spec.radius_decay if hasattr(col_spec, 'radius_decay') else 0.95,
        vessel_type=tree.inlets[0].vessel_type if tree.inlets else "arterial",
        max_steps=col_spec.max_steps,
        preferred_direction=col_spec.preferred_direction,
        directional_bias=col_spec.directional_bias,
        max_deviation_deg=col_spec.max_deviation_deg,
        smoothing_weight=col_spec.smoothing_weight,
        encourage_bifurcation=col_spec.encourage_bifurcation,
        min_attractions_for_bifurcation=col_spec.min_attractions_for_bifurcation,
        max_children_per_node=col_spec.max_children_per_node,
        bifurcation_angle_threshold_deg=col_spec.bifurcation_angle_threshold_deg,
        bifurcation_probability=col_spec.bifurcation_probability,
    )
    
    # Run space colonization with custom constraints
    logger.info(f"  Running space colonization (max_steps={params.max_steps})...")
    result = space_colonization_step(
        network,
        tissue_points=tissue_points,
        params=params,
        constraints=constraints,
        seed=spec.seed,
    )
    
    if result.status == OperationStatus.SUCCESS:
        logger.info(f"  Colonization succeeded: {result.message}")
    elif result.status == OperationStatus.PARTIAL_SUCCESS:
        logger.info(f"  Colonization partial success: {result.message}")
    else:
        logger.warning(f"  Colonization warning: {result.message}")
    
    # Log network statistics
    logger.info(f"  Network: {len(network.nodes)} nodes, {len(network.segments)} segments")
    
    return network


# =============================================================================
# GENERATION FUNCTIONS
# =============================================================================

def generate_insert(
    spec: DesignSpec,
    variant_name: str,
    output_dir: str,
    embedding_params: EmbeddingParameters = DEFAULT_EMBEDDING_PARAMS,
    skip_embedding: bool = False,
) -> Dict[str, Any]:
    """
    Generate terminal-venule insert from design specification.
    
    This function:
    1. Validates input parameters
    2. Generates vascular network via space colonization
    3. Validates the generated network
    4. Exports vascular mesh to STL
    5. Creates scaffold with channels as voids (optional)
    6. Saves all artifacts and reports
    
    Parameters
    ----------
    spec : DesignSpec
        Design specification
    variant_name : str
        Name for output files (e.g., "single_input", "multi_input")
    output_dir : str
        Output directory path
    embedding_params : EmbeddingParameters
        Parameters for scaffold embedding
    skip_embedding : bool
        If True, skip the embedding step (faster for testing)
        
    Returns
    -------
    Dict[str, Any]
        Results dictionary containing:
        - success: bool
        - network: VascularNetwork
        - validation: validation results
        - paths: dict of output file paths
        - timing: dict of timing information
        - errors: list of any errors encountered
    """
    logger.info("=" * 70)
    logger.info(f"GENERATING {variant_name.upper()} TERMINAL-VENULE INSERT")
    logger.info("=" * 70)
    
    results = {
        "success": False,
        "variant": variant_name,
        "network": None,
        "validation": None,
        "paths": {},
        "timing": {},
        "errors": [],
    }
    
    # Create output directory
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    logger.info(f"Output directory: {output_path.absolute()}")
    
    # Save design spec
    spec_path = output_path / f"{variant_name}_design_spec.json"
    spec.to_json(str(spec_path))
    results["paths"]["design_spec"] = str(spec_path)
    logger.info(f"Saved design specification to: {spec_path}")
    
    # Step 1: Generate vascular network
    # Using custom generate_network_from_spec to handle unit mismatch
    # (BranchingConstraints uses mm but network operations use meters)
    logger.info("-" * 50)
    logger.info("STEP 1: Generating vascular network...")
    logger.info("-" * 50)
    
    gen_start = time.time()
    try:
        # Use custom generation function with proper constraints in meters
        network = generate_network_from_spec(spec)
        results["network"] = network
        gen_time = time.time() - gen_start
        results["timing"]["network_generation"] = gen_time
        logger.info(f"Network generation completed in {gen_time:.2f} seconds")
    except Exception as e:
        error_msg = f"Network generation failed: {e}"
        logger.error(error_msg)
        results["errors"].append(error_msg)
        return results
    
    # Step 2: Validate network
    logger.info("-" * 50)
    logger.info("STEP 2: Validating generated network...")
    logger.info("-" * 50)
    
    validation = validate_network(network, variant_name)
    results["validation"] = validation
    
    if not validation["valid"]:
        logger.warning("Network validation found issues (see above)")
    
    # Step 3: Export vascular mesh
    logger.info("-" * 50)
    logger.info("STEP 3: Exporting vascular network mesh...")
    logger.info("-" * 50)
    
    mesh_start = time.time()
    try:
        mesh_result = to_trimesh(
            network,
            mode="fast",
            radial_resolution=12,
            include_caps=True,
            include_node_spheres=True,
        )
        
        if mesh_result.is_success():
            mesh = mesh_result.metadata["mesh"]
            mesh_path = output_path / f"{variant_name}_vascular_network.stl"
            mesh.export(str(mesh_path))
            results["paths"]["vascular_mesh"] = str(mesh_path)
            
            mesh_time = time.time() - mesh_start
            results["timing"]["mesh_export"] = mesh_time
            
            logger.info(f"Vascular mesh exported to: {mesh_path}")
            logger.info(f"  Vertices: {len(mesh.vertices)}")
            logger.info(f"  Faces: {len(mesh.faces)}")
            logger.info(f"  Watertight: {mesh.is_watertight}")
            logger.info(f"  Export time: {mesh_time:.2f} seconds")
        else:
            error_msg = f"Mesh export failed: {mesh_result.message}"
            logger.error(error_msg)
            results["errors"].append(error_msg)
    except Exception as e:
        error_msg = f"Mesh export error: {e}"
        logger.error(error_msg)
        results["errors"].append(error_msg)
    
    # Step 4: Create scaffold with voids (optional)
    if not skip_embedding and "vascular_mesh" in results["paths"]:
        logger.info("-" * 50)
        logger.info("STEP 4: Creating porous scaffold with channel voids...")
        logger.info("-" * 50)
        
        embed_start = time.time()
        try:
            # Create runtime domain for embedding
            from generation.specs.compile import compile_domain
            runtime_domain = compile_domain(spec.domain)
            
            logger.info(f"  Voxel pitch: {embedding_params.voxel_pitch*1000:.3f}mm")
            logger.info(f"  Shell thickness: {embedding_params.shell_thickness*1000:.3f}mm")
            logger.info(f"  Smoothing iterations: {embedding_params.smoothing_iterations}")
            
            embed_result = embed_tree_as_negative_space(
                tree_stl_path=results["paths"]["vascular_mesh"],
                domain=runtime_domain,
                voxel_pitch=embedding_params.voxel_pitch,
                dilation_voxels=embedding_params.dilation_voxels,
                smoothing_iters=embedding_params.smoothing_iterations,
                output_void=False,
                output_shell=False,
                shell_thickness=embedding_params.shell_thickness,
                stl_units="mm",
                output_units="mm",
            )
            
            if embed_result.get("domain_with_void") is not None:
                scaffold_mesh = embed_result["domain_with_void"]
                scaffold_path = output_path / f"{variant_name}_scaffold_with_voids.stl"
                scaffold_mesh.export(str(scaffold_path))
                results["paths"]["scaffold_mesh"] = str(scaffold_path)
                
                embed_time = time.time() - embed_start
                results["timing"]["embedding"] = embed_time
                
                logger.info(f"Scaffold mesh exported to: {scaffold_path}")
                logger.info(f"  Vertices: {len(scaffold_mesh.vertices)}")
                logger.info(f"  Faces: {len(scaffold_mesh.faces)}")
                logger.info(f"  Watertight: {scaffold_mesh.is_watertight}")
                logger.info(f"  Embedding time: {embed_time:.2f} seconds")
            else:
                logger.warning("Embedding produced no domain_with_void mesh")
                
        except Exception as e:
            error_msg = f"Scaffold embedding error: {e}"
            logger.error(error_msg)
            results["errors"].append(error_msg)
    elif skip_embedding:
        logger.info("-" * 50)
        logger.info("STEP 4: Skipping scaffold embedding (skip_embedding=True)")
        logger.info("-" * 50)
    
    # Step 5: Save generation report
    logger.info("-" * 50)
    logger.info("STEP 5: Saving generation report...")
    logger.info("-" * 50)
    
    report = {
        "variant": variant_name,
        "success": len(results["errors"]) == 0,
        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
        "validation": validation,
        "timing": results["timing"],
        "output_files": results["paths"],
        "errors": results["errors"],
        "parameters": {
            "geometry": asdict(DEFAULT_INSERT_GEOMETRY),
            "vessels": asdict(DEFAULT_VESSEL_DIMENSIONS),
            "colonization": asdict(DEFAULT_COLONIZATION_PARAMS),
            "embedding": asdict(DEFAULT_EMBEDDING_PARAMS),
        },
    }
    
    report_path = output_path / f"{variant_name}_generation_report.json"
    with open(report_path, "w") as f:
        json.dump(report, f, indent=2)
    results["paths"]["report"] = str(report_path)
    logger.info(f"Generation report saved to: {report_path}")
    
    # Final summary
    total_time = sum(results["timing"].values())
    results["timing"]["total"] = total_time
    results["success"] = len(results["errors"]) == 0
    
    logger.info("=" * 70)
    logger.info(f"GENERATION {'COMPLETED' if results['success'] else 'COMPLETED WITH ERRORS'}")
    logger.info(f"  Total time: {total_time:.2f} seconds")
    logger.info(f"  Output files: {len(results['paths'])}")
    if results["errors"]:
        logger.warning(f"  Errors: {len(results['errors'])}")
        for err in results["errors"]:
            logger.warning(f"    - {err}")
    logger.info("=" * 70)
    
    return results


def generate_single_input_insert(
    output_dir: str,
    seed: int = 42,
    skip_embedding: bool = False,
) -> Dict[str, Any]:
    """
    Generate single-input terminal-venule insert.
    
    Convenience function that creates the spec and generates the insert.
    
    Parameters
    ----------
    output_dir : str
        Output directory path
    seed : int
        Random seed for reproducibility
    skip_embedding : bool
        If True, skip scaffold embedding step
        
    Returns
    -------
    Dict[str, Any]
        Generation results
    """
    logger.info("\n" + "=" * 70)
    logger.info("SINGLE-INPUT TERMINAL-VENULE INSERT GENERATION")
    logger.info("=" * 70 + "\n")
    
    # Validate parameters
    issues = validate_parameters(
        DEFAULT_INSERT_GEOMETRY,
        DEFAULT_VESSEL_DIMENSIONS,
        DEFAULT_COLONIZATION_PARAMS,
        DEFAULT_EMBEDDING_PARAMS,
    )
    
    if issues:
        logger.warning("Parameter validation issues:")
        for issue in issues:
            logger.warning(f"  {issue}")
    
    # Create spec
    spec = create_single_input_spec(seed=seed)
    
    # Generate
    return generate_insert(
        spec=spec,
        variant_name="single_input",
        output_dir=output_dir,
        skip_embedding=skip_embedding,
    )


def generate_multi_input_insert(
    output_dir: str,
    num_inlets: int = 6,
    seed: int = 42,
    skip_embedding: bool = False,
) -> Dict[str, Any]:
    """
    Generate multi-input terminal-venule insert.
    
    Convenience function that creates the spec and generates the insert.
    
    Parameters
    ----------
    output_dir : str
        Output directory path
    num_inlets : int
        Number of inlet ports (4-8 recommended)
    seed : int
        Random seed for reproducibility
    skip_embedding : bool
        If True, skip scaffold embedding step
        
    Returns
    -------
    Dict[str, Any]
        Generation results
    """
    logger.info("\n" + "=" * 70)
    logger.info(f"MULTI-INPUT ({num_inlets} INLETS) TERMINAL-VENULE INSERT GENERATION")
    logger.info("=" * 70 + "\n")
    
    # Validate parameters
    issues = validate_parameters(
        DEFAULT_INSERT_GEOMETRY,
        DEFAULT_VESSEL_DIMENSIONS,
        DEFAULT_COLONIZATION_PARAMS,
        DEFAULT_EMBEDDING_PARAMS,
    )
    
    if issues:
        logger.warning("Parameter validation issues:")
        for issue in issues:
            logger.warning(f"  {issue}")
    
    # Create multi-input config
    multi_config = MultiInputConfig(num_inlets=num_inlets)
    
    # Create spec
    spec = create_multi_input_spec(multi_config=multi_config, seed=seed)
    
    # Generate
    return generate_insert(
        spec=spec,
        variant_name="multi_input",
        output_dir=output_dir,
        skip_embedding=skip_embedding,
    )


# =============================================================================
# COMMAND LINE INTERFACE
# =============================================================================

def main():
    """
    Command-line interface for terminal-venule insert generation.
    
    Usage examples:
        # Generate single-input variant
        python terminal_venule_insert.py --variant single --output-dir ./output
        
        # Generate multi-input variant with 6 inlets
        python terminal_venule_insert.py --variant multi --num-inlets 6 --output-dir ./output
        
        # Generate both variants
        python terminal_venule_insert.py --variant both --output-dir ./output
        
        # Quick test without embedding (faster)
        python terminal_venule_insert.py --variant single --skip-embedding --output-dir ./output
    """
    parser = argparse.ArgumentParser(
        description="Generate terminal-venule insert scaffolds for 48-well plates",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --variant single --output-dir ./output
  %(prog)s --variant multi --num-inlets 6 --output-dir ./output
  %(prog)s --variant both --output-dir ./output
  %(prog)s --variant single --skip-embedding --output-dir ./output

Output files:
  {variant}_vascular_network.stl    - Vascular channel mesh
  {variant}_scaffold_with_voids.stl - Porous scaffold with channels as voids
  {variant}_design_spec.json        - Design specification
  {variant}_generation_report.json  - Generation metrics and validation
        """,
    )
    
    parser.add_argument(
        "--variant", "-v",
        type=str,
        choices=["single", "multi", "both"],
        default="single",
        help="Design variant to generate (default: single)",
    )
    
    parser.add_argument(
        "--num-inlets", "-n",
        type=int,
        default=6,
        help="Number of inlets for multi-input variant (default: 6)",
    )
    
    parser.add_argument(
        "--output-dir", "-o",
        type=str,
        default="./terminal_venule_output",
        help="Output directory (default: ./terminal_venule_output)",
    )
    
    parser.add_argument(
        "--seed", "-s",
        type=int,
        default=42,
        help="Random seed for reproducibility (default: 42)",
    )
    
    parser.add_argument(
        "--skip-embedding",
        action="store_true",
        help="Skip scaffold embedding step (faster for testing)",
    )
    
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable debug-level logging",
    )
    
    args = parser.parse_args()
    
    # Configure logging level
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Print header
    print("\n" + "=" * 70)
    print("TERMINAL-VENULE INSERT GENERATOR")
    print("48-Well Compatible Scaffold with Converging Channel Architecture")
    print("=" * 70)
    print(f"\nVariant: {args.variant}")
    print(f"Output directory: {args.output_dir}")
    print(f"Random seed: {args.seed}")
    print(f"Skip embedding: {args.skip_embedding}")
    if args.variant in ["multi", "both"]:
        print(f"Number of inlets: {args.num_inlets}")
    print()
    
    results = {}
    
    # Generate requested variant(s)
    if args.variant in ["single", "both"]:
        results["single"] = generate_single_input_insert(
            output_dir=args.output_dir,
            seed=args.seed,
            skip_embedding=args.skip_embedding,
        )
    
    if args.variant in ["multi", "both"]:
        results["multi"] = generate_multi_input_insert(
            output_dir=args.output_dir,
            num_inlets=args.num_inlets,
            seed=args.seed,
            skip_embedding=args.skip_embedding,
        )
    
    # Print final summary
    print("\n" + "=" * 70)
    print("GENERATION SUMMARY")
    print("=" * 70)
    
    for variant, result in results.items():
        status = "SUCCESS" if result["success"] else "FAILED"
        print(f"\n{variant.upper()} variant: {status}")
        print("  Output files:")
        for name, path in result["paths"].items():
            print(f"    - {name}: {path}")
        if result["errors"]:
            print("  Errors:")
            for err in result["errors"]:
                print(f"    - {err}")
    
    print("\n" + "=" * 70)
    print("Generation complete!")
    print("=" * 70 + "\n")
    
    # Return exit code based on success
    all_success = all(r["success"] for r in results.values())
    return 0 if all_success else 1


if __name__ == "__main__":
    sys.exit(main())
