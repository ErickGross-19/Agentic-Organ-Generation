#!/usr/bin/env python3
"""
Branching + Embedding Stress Test

Stress-test the limits of the repo's prebuilt branching and embedding functions
under extremely fine voxelization (1 um voxel pitch) and maximally dense branching.

This script runs all five scenarios and exports intermediate + final STLs:
- Scenario A: K-bifurcation (K-ary tree)
- Scenario B: Space colonization
- Scenario C: CCO
- Scenario D: CCO + NLP
- Scenario E: Planar XY branching stress

UNITS:
- Internal computations: METERS
- Output STL files: MILLIMETERS (scaled at export)

Author: Generated by Agentic Organ Generation System
"""

import sys
import os
import time
import json
import math
import tempfile
from pathlib import Path
from typing import Optional, Dict, Any, List, Tuple
from dataclasses import dataclass, field

import numpy as np
import trimesh

# Add parent directory to path for imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from generation.core.domain import CylinderDomain
from generation.core.types import Point3D
from generation.core.network import VascularNetwork, Node
from generation.ops.growth import grow_kary_tree_to_depths, grow_kary_tree_v2, KaryTreeSpec
from generation.ops.embedding import embed_tree_as_negative_space, VoxelBudgetExceededError
from generation.ops.features import add_raised_ridge, RidgeSpec, FaceId
from generation.adapters.mesh_adapter import to_trimesh
from generation.backends.cco_hybrid_backend import CCOHybridBackend, CCOConfig
from generation.backends.space_colonization_backend import SpaceColonizationBackend, SpaceColonizationConfig
from generation.optimization.nlp_geometry import optimize_geometry, NLPConfig
from validity.mesh.voxel_utils import remove_small_components


# =============================================================================
# CONFIGURABLE PARAMETERS
# =============================================================================

# Memory / file size cap (default: 30 GB)
MAX_MEMORY_GB = 30.0

# Per-attempt runtime limit in seconds (default: 600 = 10 minutes)
MAX_RUNTIME_SECONDS = 600

# Embedding voxel pitch (1 micron = 1e-6 m)
EMBEDDING_VOXEL_PITCH_M = 1e-6

# Ridge union voxel pitch (10-25 um is fine)
RIDGE_VOXEL_PITCH_M = 15e-6

# =============================================================================
# DOMAIN PARAMETERS (shared by all scenarios)
# =============================================================================

# Cylinder domain centered at origin
CYLINDER_RADIUS_M = 0.005          # 5.0 mm radius
CYLINDER_HEIGHT_M = 0.002          # 2.0 mm height
CYLINDER_CENTER = (0.0, 0.0, 0.0)  # Centered at origin
# Top face: z = +1.0 mm, bottom face: z = -1.0 mm

# Ridge parameters
RIDGE_HEIGHT_M = 0.0005            # 0.50 mm ridge height
RIDGE_THICKNESS_M = 0.0005         # 0.50 mm ridge thickness/width
RIDGE_OVERLAP_M = 0.00005          # 0.05 mm overlap into base

# Inlet parameters
INLET_POSITION = (0.0, 0.0, 0.001)  # Center of top face at z = +1.0 mm
INLET_DIAMETER_M = 0.001            # 1.0 mm diameter
INLET_RADIUS_M = INLET_DIAMETER_M / 2  # 0.5 mm radius

# Derived parameters
TOP_FACE_Z_M = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2  # +1.0 mm
BOTTOM_FACE_Z_M = CYLINDER_CENTER[2] - CYLINDER_HEIGHT_M / 2  # -1.0 mm

# =============================================================================
# OUTPUT DIRECTORIES
# =============================================================================

OUTPUT_BASE_DIR = Path(__file__).parent.parent / "outputs" / "branching_stress"
INTERMEDIATE_DIR = OUTPUT_BASE_DIR / "intermediate"
FINAL_DIR = OUTPUT_BASE_DIR / "final"


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def ensure_output_dirs():
    """Create output directories if they don't exist."""
    INTERMEDIATE_DIR.mkdir(parents=True, exist_ok=True)
    FINAL_DIR.mkdir(parents=True, exist_ok=True)
    print("Output directories created:")
    print(f"  Intermediate: {INTERMEDIATE_DIR}")
    print(f"  Final: {FINAL_DIR}")


def estimate_voxel_grid_memory(domain_size: np.ndarray, voxel_pitch: float) -> Tuple[Tuple[int, int, int], float]:
    """
    Estimate voxel grid shape and memory usage.
    
    Returns
    -------
    grid_shape : tuple
        (nx, ny, nz) grid dimensions
    memory_gb : float
        Estimated memory usage in GB
    """
    pad = 2 * voxel_pitch
    grid_shape = np.ceil((domain_size + 2 * pad) / voxel_pitch).astype(int) + 1
    grid_shape = np.maximum(grid_shape, 1)
    
    total_voxels = int(np.prod(grid_shape))
    # Estimate: ~5 boolean masks + some float arrays for marching cubes
    memory_bytes = total_voxels * 5 + total_voxels * 8
    memory_gb = memory_bytes / (1024 ** 3)
    
    return tuple(grid_shape), memory_gb


def check_memory_budget(domain_size: np.ndarray, voxel_pitch: float, max_memory_gb: float = MAX_MEMORY_GB) -> Tuple[bool, Tuple[int, int, int], float]:
    """
    Check if the voxel grid would exceed the memory budget.
    
    Returns
    -------
    within_budget : bool
        True if within budget
    grid_shape : tuple
        (nx, ny, nz) grid dimensions
    memory_gb : float
        Estimated memory usage in GB
    """
    grid_shape, memory_gb = estimate_voxel_grid_memory(domain_size, voxel_pitch)
    within_budget = memory_gb <= max_memory_gb
    return within_budget, grid_shape, memory_gb


def create_cylinder_domain() -> CylinderDomain:
    """Create the shared cylinder domain."""
    return CylinderDomain(
        center=Point3D(*CYLINDER_CENTER),
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
    )


def create_cylinder_mesh() -> trimesh.Trimesh:
    """Create a cylinder mesh for the domain."""
    mesh = trimesh.creation.cylinder(
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
        sections=64,
    )
    mesh.apply_translation(CYLINDER_CENTER)
    return mesh


def add_ridge_to_mesh(base_mesh: trimesh.Trimesh, domain: CylinderDomain) -> trimesh.Trimesh:
    """Add a raised ridge to the top face of the mesh."""
    ridge_spec = RidgeSpec(
        height=RIDGE_HEIGHT_M,
        thickness=RIDGE_THICKNESS_M,
        overlap=RIDGE_OVERLAP_M,
        voxel_pitch=RIDGE_VOXEL_PITCH_M,
    )
    
    result = add_raised_ridge(
        base_mesh=base_mesh,
        domain=domain,
        face=FaceId.TOP,
        ridge_spec=ridge_spec,
    )
    
    return result


def scale_mesh_to_mm(mesh: trimesh.Trimesh) -> trimesh.Trimesh:
    """Scale mesh from meters to millimeters."""
    scaled = mesh.copy()
    scaled.apply_scale(1000.0)
    return scaled


def export_mesh_with_units(mesh: trimesh.Trimesh, path: Path, units: str = "mm"):
    """Export mesh with units sidecar file."""
    # Scale to mm if needed
    if units == "mm":
        export_mesh = scale_mesh_to_mm(mesh)
    else:
        export_mesh = mesh
    
    # Export STL
    export_mesh.export(str(path))
    
    # Write units sidecar
    sidecar_path = Path(str(path) + ".units.json")
    with open(sidecar_path, 'w') as f:
        json.dump({"units": units}, f)
    
    print(f"  Exported: {path} ({units})")


def network_to_void_mesh(network: VascularNetwork, include_caps: bool = False) -> trimesh.Trimesh:
    """Convert a VascularNetwork to a void mesh."""
    result = to_trimesh(
        network,
        mode="fast",
        radial_resolution=16,
        include_caps=include_caps,
        include_node_spheres=False,
    )
    
    if not result.is_success():
        raise RuntimeError(f"Failed to convert network to mesh: {result.message}")
    
    return result.metadata['mesh']


def log_attempt_info(
    scenario: str,
    attempt: int,
    params: Dict[str, Any],
    grid_shape: Tuple[int, int, int],
    memory_gb: float,
    voxel_counts: Optional[Dict[str, int]] = None,
    fallback_used: bool = False,
    watertight: Optional[bool] = None,
    volume: Optional[float] = None,
    bounds: Optional[np.ndarray] = None,
    runtime: Optional[float] = None,
    density_metric: Optional[float] = None,
):
    """Log information for an attempt."""
    print(f"\n{'='*60}")
    print(f"Scenario {scenario} - Attempt {attempt}")
    print(f"{'='*60}")
    print(f"Parameters: {params}")
    print(f"Voxel grid shape: {grid_shape}")
    print(f"Estimated memory: {memory_gb:.2f} GB")
    
    if voxel_counts:
        print("Voxel counts:")
        print(f"  Domain: {voxel_counts.get('domain', 'N/A')}")
        print(f"  Void: {voxel_counts.get('void', 'N/A')}")
        print(f"  Solid: {voxel_counts.get('solid', 'N/A')}")
    
    print(f"Fallback used: {fallback_used}")
    
    if watertight is not None:
        print(f"Watertight: {watertight}")
    if volume is not None:
        print(f"Volume: {volume:.9e} m^3")
    if bounds is not None:
        print(f"Bounds: min={bounds[0]}, max={bounds[1]}")
    if runtime is not None:
        print(f"Runtime: {runtime:.2f} seconds")
    if density_metric is not None:
        print(f"Density metric: {density_metric}")


def verify_carve_result(
    domain_voxels: int,
    solid_voxels: int,
    void_voxels: int,
    output_volume: float,
    domain_volume: float,
) -> Tuple[bool, str]:
    """
    Verify that the carve operation produced a valid result.
    
    Returns
    -------
    is_valid : bool
        True if the result is valid
    reason : str
        Reason for the result
    """
    epsilon = max(1, int(0.001 * domain_voxels))
    
    if void_voxels <= 0:
        return False, "void mask is empty"
    
    if solid_voxels >= (domain_voxels - epsilon):
        return False, "void not meaningfully carved (solid_voxels >= domain_voxels)"
    
    if output_volume < 0.30 * domain_volume:
        return False, f"output is shell-like (volume {output_volume:.9e} < 30% of domain {domain_volume:.9e})"
    
    reduction_pct = (domain_volume - output_volume) / domain_volume * 100.0
    if reduction_pct < 0.2:
        return False, f"output looks uncarved (reduction {reduction_pct:.3f}% < 0.2%)"
    
    return True, "all checks passed"


@dataclass
class AttemptResult:
    """Result of a single attempt."""
    success: bool = False
    params: Dict[str, Any] = field(default_factory=dict)
    density_metric: float = 0.0
    void_mesh: Optional[trimesh.Trimesh] = None
    final_mesh: Optional[trimesh.Trimesh] = None
    runtime: float = 0.0
    voxel_counts: Dict[str, int] = field(default_factory=dict)
    grid_shape: Tuple[int, int, int] = (0, 0, 0)
    memory_gb: float = 0.0
    error: Optional[str] = None


@dataclass
class ScenarioResult:
    """Result of a scenario."""
    scenario: str
    best_attempt: Optional[AttemptResult] = None
    all_attempts: List[AttemptResult] = field(default_factory=list)


# =============================================================================
# SCENARIO A: K-BIFURCATION (K-ARY TREE)
# =============================================================================

def run_scenario_a_kary() -> ScenarioResult:
    """
    Scenario A: K-bifurcation (K-ary tree)
    
    Use the repo's prebuilt K-ary tree builder (grow_kary_tree_to_depths / KaryTreeSpec).
    Goal: maximize density while embeddable at 1um.
    
    Parameter sweep:
    - K in [4, 6] if supported; otherwise K=4
    - levels increasing until failure
    - terminal radius decreasing (e.g., 100 um -> 25 um) as stable
    
    Density score: maximize segments or terminal count.
    """
    print("\n" + "="*80)
    print("SCENARIO A: K-BIFURCATION (K-ARY TREE)")
    print("="*80)
    
    result = ScenarioResult(scenario="A")
    domain = create_cylinder_domain()
    domain_size = np.array([2 * CYLINDER_RADIUS_M, 2 * CYLINDER_RADIUS_M, CYLINDER_HEIGHT_M])
    domain_volume = math.pi * (CYLINDER_RADIUS_M ** 2) * CYLINDER_HEIGHT_M
    
    # Parameter sweep configurations
    k_values = [4, 6]
    level_range = range(3, 10)  # Start with 3 levels, increase until failure
    terminal_radii = [100e-6, 75e-6, 50e-6, 25e-6]  # 100um to 25um
    
    best_attempt = None
    best_density = 0.0
    
    for K in k_values:
        for num_levels in level_range:
            for terminal_radius in terminal_radii:
                # Check memory budget first
                within_budget, grid_shape, memory_gb = check_memory_budget(
                    domain_size, EMBEDDING_VOXEL_PITCH_M
                )
                
                if not within_budget:
                    print(f"\nSkipping K={K}, levels={num_levels}, terminal_r={terminal_radius*1e6:.0f}um: "
                          f"memory {memory_gb:.2f} GB exceeds budget {MAX_MEMORY_GB} GB")
                    continue
                
                params = {
                    "K": K,
                    "num_levels": num_levels,
                    "terminal_radius_um": terminal_radius * 1e6,
                }
                
                attempt = AttemptResult(params=params, grid_shape=grid_shape, memory_gb=memory_gb)
                start_time = time.time()
                
                try:
                    # Create network with inlet
                    network = VascularNetwork(domain=domain, seed=42)
                    inlet_node = Node(
                        id=network.id_gen.next_id(),
                        position=Point3D(*INLET_POSITION),
                        node_type="inlet",
                        vessel_type="venous",
                        attributes={
                            "radius": INLET_RADIUS_M,
                            "direction": {"dx": 0.0, "dy": 0.0, "dz": -1.0},
                            "branch_order": 0,
                        },
                    )
                    network.add_node(inlet_node)
                    
                    # Compute bifurcation depths
                    usable_height = CYLINDER_HEIGHT_M * 0.85
                    depths = [usable_height * (i + 1) / (num_levels + 1) for i in range(num_levels)]
                    
                    # Taper function
                    def taper_fn(level, n_levels, parent_radius):
                        # Exponential taper from inlet radius to terminal radius
                        if n_levels <= 1:
                            return terminal_radius
                        t = level / (n_levels - 1)
                        return INLET_RADIUS_M * (1 - t) + terminal_radius * t
                    
                    # Grow K-ary tree
                    grow_result = grow_kary_tree_to_depths(
                        network=network,
                        root_node_id=inlet_node.id,
                        K=K,
                        depths=depths,
                        taper_fn=taper_fn,
                        angle_deg=45.0,
                        angle_decay=0.9,
                        boundary_mode="strict",
                        seed=42,
                    )
                    
                    if not grow_result.is_success():
                        attempt.error = f"Tree growth failed: {grow_result.message}"
                        attempt.runtime = time.time() - start_time
                        result.all_attempts.append(attempt)
                        continue
                    
                    # Get density metric (number of segments)
                    num_segments = len(network.segments)
                    num_terminals = sum(1 for n in network.nodes.values() if n.node_type == "terminal")
                    density_metric = num_segments
                    
                    # Convert to void mesh
                    void_mesh = network_to_void_mesh(network, include_caps=False)
                    
                    # Clean up small components
                    void_mesh = remove_small_components(void_mesh, min_faces=100)
                    
                    # Check runtime
                    elapsed = time.time() - start_time
                    if elapsed > MAX_RUNTIME_SECONDS:
                        attempt.error = f"Runtime exceeded: {elapsed:.2f}s > {MAX_RUNTIME_SECONDS}s"
                        attempt.runtime = elapsed
                        result.all_attempts.append(attempt)
                        break
                    
                    # Export intermediate void mesh
                    attempt.void_mesh = void_mesh
                    
                    # Try embedding at 1um voxel pitch
                    with tempfile.NamedTemporaryFile(suffix=".stl", delete=False) as tmp:
                        void_mesh.export(tmp.name)
                        tmp_path = tmp.name
                    
                    try:
                        embed_result = embed_tree_as_negative_space(
                            tree_stl_path=tmp_path,
                            domain=domain,
                            voxel_pitch=EMBEDDING_VOXEL_PITCH_M,
                            method="voxel_subtraction",
                            output_void=True,
                            output_units="m",
                            stl_units="m",
                        )
                        
                        final_mesh = embed_result['domain_with_void']
                        metadata = embed_result.get('metadata', {})
                        voxel_counts = metadata.get('voxel_counts', {})
                        
                        # Verify carve result
                        is_valid, reason = verify_carve_result(
                            domain_voxels=voxel_counts.get('domain', 1),
                            solid_voxels=voxel_counts.get('solid', 0),
                            void_voxels=voxel_counts.get('void', 0),
                            output_volume=final_mesh.volume if final_mesh else 0,
                            domain_volume=domain_volume,
                        )
                        
                        if not is_valid:
                            attempt.error = f"Carve verification failed: {reason}"
                            attempt.runtime = time.time() - start_time
                            result.all_attempts.append(attempt)
                            continue
                        
                        attempt.success = True
                        attempt.final_mesh = final_mesh
                        attempt.density_metric = density_metric
                        attempt.voxel_counts = voxel_counts
                        
                    except VoxelBudgetExceededError as e:
                        attempt.error = f"Voxel budget exceeded: {e}"
                    except Exception as e:
                        attempt.error = f"Embedding failed: {e}"
                    finally:
                        os.unlink(tmp_path)
                    
                except Exception as e:
                    attempt.error = f"Unexpected error: {e}"
                
                attempt.runtime = time.time() - start_time
                result.all_attempts.append(attempt)
                
                # Log attempt info
                log_attempt_info(
                    scenario="A",
                    attempt=len(result.all_attempts),
                    params=params,
                    grid_shape=grid_shape,
                    memory_gb=memory_gb,
                    voxel_counts=attempt.voxel_counts,
                    watertight=attempt.final_mesh.is_watertight if attempt.final_mesh else None,
                    volume=attempt.final_mesh.volume if attempt.final_mesh else None,
                    runtime=attempt.runtime,
                    density_metric=attempt.density_metric,
                )
                
                # Update best attempt
                if attempt.success and attempt.density_metric > best_density:
                    best_density = attempt.density_metric
                    best_attempt = attempt
                
                # Check if we should stop increasing levels
                if attempt.error and "memory" in attempt.error.lower():
                    break
    
    result.best_attempt = best_attempt
    return result


# =============================================================================
# SCENARIO B: SPACE COLONIZATION
# =============================================================================

def run_scenario_b_space_colonization() -> ScenarioResult:
    """
    Scenario B: Space colonization
    
    Use the repo's prebuilt space colonization tool.
    Sweep attractor count/density upward until failure.
    
    Density score: maximize segments/terminals.
    """
    print("\n" + "="*80)
    print("SCENARIO B: SPACE COLONIZATION")
    print("="*80)
    
    result = ScenarioResult(scenario="B")
    domain = create_cylinder_domain()
    domain_size = np.array([2 * CYLINDER_RADIUS_M, 2 * CYLINDER_RADIUS_M, CYLINDER_HEIGHT_M])
    domain_volume = math.pi * (CYLINDER_RADIUS_M ** 2) * CYLINDER_HEIGHT_M
    
    # Parameter sweep configurations
    attractor_counts = [500, 1000, 2000, 5000, 10000]
    
    best_attempt = None
    best_density = 0.0
    
    for num_attractors in attractor_counts:
        # Check memory budget first
        within_budget, grid_shape, memory_gb = check_memory_budget(
            domain_size, EMBEDDING_VOXEL_PITCH_M
        )
        
        if not within_budget:
            print(f"\nSkipping attractors={num_attractors}: "
                  f"memory {memory_gb:.2f} GB exceeds budget {MAX_MEMORY_GB} GB")
            continue
        
        params = {
            "num_attractors": num_attractors,
        }
        
        attempt = AttemptResult(params=params, grid_shape=grid_shape, memory_gb=memory_gb)
        start_time = time.time()
        
        try:
            # Use SpaceColonizationBackend
            backend = SpaceColonizationBackend()
            config = SpaceColonizationConfig(
                attraction_distance=0.005,  # 5mm
                kill_distance=0.001,  # 1mm
                step_size=0.0005,  # 0.5mm
                num_attractors=num_attractors,
                max_iterations=500,
            )
            
            network = backend.generate(
                domain=domain,
                num_outlets=num_attractors // 10,
                inlet_position=np.array(INLET_POSITION),
                inlet_radius=INLET_RADIUS_M,
                vessel_type="venous",
                config=config,
                rng_seed=42,
            )
            
            # Get density metric
            num_segments = len(network.segments)
            num_terminals = sum(1 for n in network.nodes.values() if n.node_type == "terminal")
            density_metric = num_segments
            
            # Convert to void mesh
            void_mesh = network_to_void_mesh(network, include_caps=False)
            
            # Clean up small components
            void_mesh = remove_small_components(void_mesh, min_faces=100)
            
            # Check runtime
            elapsed = time.time() - start_time
            if elapsed > MAX_RUNTIME_SECONDS:
                attempt.error = f"Runtime exceeded: {elapsed:.2f}s > {MAX_RUNTIME_SECONDS}s"
                attempt.runtime = elapsed
                result.all_attempts.append(attempt)
                break
            
            attempt.void_mesh = void_mesh
            
            # Try embedding at 1um voxel pitch
            with tempfile.NamedTemporaryFile(suffix=".stl", delete=False) as tmp:
                void_mesh.export(tmp.name)
                tmp_path = tmp.name
            
            try:
                embed_result = embed_tree_as_negative_space(
                    tree_stl_path=tmp_path,
                    domain=domain,
                    voxel_pitch=EMBEDDING_VOXEL_PITCH_M,
                    method="voxel_subtraction",
                    output_void=True,
                    output_units="m",
                    stl_units="m",
                )
                
                final_mesh = embed_result['domain_with_void']
                metadata = embed_result.get('metadata', {})
                voxel_counts = metadata.get('voxel_counts', {})
                
                # Verify carve result
                is_valid, reason = verify_carve_result(
                    domain_voxels=voxel_counts.get('domain', 1),
                    solid_voxels=voxel_counts.get('solid', 0),
                    void_voxels=voxel_counts.get('void', 0),
                    output_volume=final_mesh.volume if final_mesh else 0,
                    domain_volume=domain_volume,
                )
                
                if not is_valid:
                    attempt.error = f"Carve verification failed: {reason}"
                    attempt.runtime = time.time() - start_time
                    result.all_attempts.append(attempt)
                    continue
                
                attempt.success = True
                attempt.final_mesh = final_mesh
                attempt.density_metric = density_metric
                attempt.voxel_counts = voxel_counts
                
            except VoxelBudgetExceededError as e:
                attempt.error = f"Voxel budget exceeded: {e}"
            except Exception as e:
                attempt.error = f"Embedding failed: {e}"
            finally:
                os.unlink(tmp_path)
            
        except Exception as e:
            attempt.error = f"Unexpected error: {e}"
        
        attempt.runtime = time.time() - start_time
        result.all_attempts.append(attempt)
        
        # Log attempt info
        log_attempt_info(
            scenario="B",
            attempt=len(result.all_attempts),
            params=params,
            grid_shape=grid_shape,
            memory_gb=memory_gb,
            voxel_counts=attempt.voxel_counts,
            watertight=attempt.final_mesh.is_watertight if attempt.final_mesh else None,
            volume=attempt.final_mesh.volume if attempt.final_mesh else None,
            runtime=attempt.runtime,
            density_metric=attempt.density_metric,
        )
        
        # Update best attempt
        if attempt.success and attempt.density_metric > best_density:
            best_density = attempt.density_metric
            best_attempt = attempt
    
    result.best_attempt = best_attempt
    return result


# =============================================================================
# SCENARIO C: CCO
# =============================================================================

def run_scenario_c_cco() -> ScenarioResult:
    """
    Scenario C: CCO
    
    Use the repo's CCO backend/generator.
    Sweep target_outlets upward until failure.
    Tune collision_clearance downward cautiously and log it.
    Log achieved outlets vs requested.
    
    Density score: maximize achieved outlets.
    """
    print("\n" + "="*80)
    print("SCENARIO C: CCO")
    print("="*80)
    
    result = ScenarioResult(scenario="C")
    domain = create_cylinder_domain()
    domain_size = np.array([2 * CYLINDER_RADIUS_M, 2 * CYLINDER_RADIUS_M, CYLINDER_HEIGHT_M])
    domain_volume = math.pi * (CYLINDER_RADIUS_M ** 2) * CYLINDER_HEIGHT_M
    
    # Parameter sweep configurations
    target_outlets_range = [50, 100, 200, 500, 1000]
    collision_clearances = [0.0001, 0.00005, 0.00002]  # 100um, 50um, 20um
    
    best_attempt = None
    best_density = 0.0
    
    for target_outlets in target_outlets_range:
        for collision_clearance in collision_clearances:
            # Check memory budget first
            within_budget, grid_shape, memory_gb = check_memory_budget(
                domain_size, EMBEDDING_VOXEL_PITCH_M
            )
            
            if not within_budget:
                print(f"\nSkipping outlets={target_outlets}, clearance={collision_clearance*1e6:.0f}um: "
                      f"memory {memory_gb:.2f} GB exceeds budget {MAX_MEMORY_GB} GB")
                continue
            
            params = {
                "target_outlets": target_outlets,
                "collision_clearance_um": collision_clearance * 1e6,
            }
            
            attempt = AttemptResult(params=params, grid_shape=grid_shape, memory_gb=memory_gb)
            start_time = time.time()
            
            try:
                # Use CCOHybridBackend
                backend = CCOHybridBackend()
                config = CCOConfig(
                    collision_clearance=collision_clearance,
                    collision_check_enabled=True,
                    min_radius=25e-6,  # 25um minimum radius
                    max_consecutive_failures=100,
                )
                
                network = backend.generate(
                    domain=domain,
                    num_outlets=target_outlets,
                    inlet_position=np.array(INLET_POSITION),
                    inlet_radius=INLET_RADIUS_M,
                    vessel_type="venous",
                    config=config,
                    rng_seed=42,
                )
                
                # Get density metric (achieved outlets)
                num_segments = len(network.segments)
                num_terminals = sum(1 for n in network.nodes.values() if n.node_type == "terminal")
                achieved_outlets = num_terminals
                density_metric = achieved_outlets
                
                print(f"  Achieved outlets: {achieved_outlets} / {target_outlets} requested")
                
                # Convert to void mesh
                void_mesh = network_to_void_mesh(network, include_caps=False)
                
                # Clean up small components
                void_mesh = remove_small_components(void_mesh, min_faces=100)
                
                # Check runtime
                elapsed = time.time() - start_time
                if elapsed > MAX_RUNTIME_SECONDS:
                    attempt.error = f"Runtime exceeded: {elapsed:.2f}s > {MAX_RUNTIME_SECONDS}s"
                    attempt.runtime = elapsed
                    result.all_attempts.append(attempt)
                    break
                
                attempt.void_mesh = void_mesh
                
                # Try embedding at 1um voxel pitch
                with tempfile.NamedTemporaryFile(suffix=".stl", delete=False) as tmp:
                    void_mesh.export(tmp.name)
                    tmp_path = tmp.name
                
                try:
                    embed_result = embed_tree_as_negative_space(
                        tree_stl_path=tmp_path,
                        domain=domain,
                        voxel_pitch=EMBEDDING_VOXEL_PITCH_M,
                        method="voxel_subtraction",
                        output_void=True,
                        output_units="m",
                        stl_units="m",
                    )
                    
                    final_mesh = embed_result['domain_with_void']
                    metadata = embed_result.get('metadata', {})
                    voxel_counts = metadata.get('voxel_counts', {})
                    
                    # Verify carve result
                    is_valid, reason = verify_carve_result(
                        domain_voxels=voxel_counts.get('domain', 1),
                        solid_voxels=voxel_counts.get('solid', 0),
                        void_voxels=voxel_counts.get('void', 0),
                        output_volume=final_mesh.volume if final_mesh else 0,
                        domain_volume=domain_volume,
                    )
                    
                    if not is_valid:
                        attempt.error = f"Carve verification failed: {reason}"
                        attempt.runtime = time.time() - start_time
                        result.all_attempts.append(attempt)
                        continue
                    
                    attempt.success = True
                    attempt.final_mesh = final_mesh
                    attempt.density_metric = density_metric
                    attempt.voxel_counts = voxel_counts
                    
                except VoxelBudgetExceededError as e:
                    attempt.error = f"Voxel budget exceeded: {e}"
                except Exception as e:
                    attempt.error = f"Embedding failed: {e}"
                finally:
                    os.unlink(tmp_path)
                
            except Exception as e:
                attempt.error = f"Unexpected error: {e}"
            
            attempt.runtime = time.time() - start_time
            result.all_attempts.append(attempt)
            
            # Log attempt info
            log_attempt_info(
                scenario="C",
                attempt=len(result.all_attempts),
                params=params,
                grid_shape=grid_shape,
                memory_gb=memory_gb,
                voxel_counts=attempt.voxel_counts,
                watertight=attempt.final_mesh.is_watertight if attempt.final_mesh else None,
                volume=attempt.final_mesh.volume if attempt.final_mesh else None,
                runtime=attempt.runtime,
                density_metric=attempt.density_metric,
            )
            
            # Update best attempt
            if attempt.success and attempt.density_metric > best_density:
                best_density = attempt.density_metric
                best_attempt = attempt
    
    result.best_attempt = best_attempt
    return result


# =============================================================================
# SCENARIO D: CCO + NLP
# =============================================================================

def run_scenario_d_cco_nlp() -> ScenarioResult:
    """
    Scenario D: CCO + NLP
    
    Start from CCO and run the repo's NLP optimization step.
    Sweep target_outlets upward until failure.
    Log NLP convergence status; handle failures gracefully.
    
    Density score: maximize achieved outlets.
    """
    print("\n" + "="*80)
    print("SCENARIO D: CCO + NLP")
    print("="*80)
    
    result = ScenarioResult(scenario="D")
    domain = create_cylinder_domain()
    domain_size = np.array([2 * CYLINDER_RADIUS_M, 2 * CYLINDER_RADIUS_M, CYLINDER_HEIGHT_M])
    domain_volume = math.pi * (CYLINDER_RADIUS_M ** 2) * CYLINDER_HEIGHT_M
    
    # Parameter sweep configurations
    target_outlets_range = [50, 100, 200, 500]
    
    best_attempt = None
    best_density = 0.0
    
    for target_outlets in target_outlets_range:
        # Check memory budget first
        within_budget, grid_shape, memory_gb = check_memory_budget(
            domain_size, EMBEDDING_VOXEL_PITCH_M
        )
        
        if not within_budget:
            print(f"\nSkipping outlets={target_outlets}: "
                  f"memory {memory_gb:.2f} GB exceeds budget {MAX_MEMORY_GB} GB")
            continue
        
        params = {
            "target_outlets": target_outlets,
            "nlp_enabled": True,
        }
        
        attempt = AttemptResult(params=params, grid_shape=grid_shape, memory_gb=memory_gb)
        start_time = time.time()
        
        try:
            # Use CCOHybridBackend
            backend = CCOHybridBackend()
            config = CCOConfig(
                collision_clearance=0.00005,  # 50um
                collision_check_enabled=True,
                min_radius=25e-6,  # 25um minimum radius
                max_consecutive_failures=100,
            )
            
            network = backend.generate(
                domain=domain,
                num_outlets=target_outlets,
                inlet_position=np.array(INLET_POSITION),
                inlet_radius=INLET_RADIUS_M,
                vessel_type="venous",
                config=config,
                rng_seed=42,
            )
            
            # Run NLP optimization
            nlp_config = NLPConfig(
                min_radius=25e-6,
                max_radius=INLET_RADIUS_M,
                max_iterations=500,
                solver_tolerance=1e-6,
            )
            
            nlp_result = optimize_geometry(network, config=nlp_config)
            
            print(f"  NLP optimization: success={nlp_result.success}, "
                  f"iterations={nlp_result.iterations}, "
                  f"volume_reduction={nlp_result.volume_reduction:.2%}")
            
            if nlp_result.errors:
                print(f"  NLP errors: {nlp_result.errors}")
            
            # Get density metric (achieved outlets)
            num_segments = len(network.segments)
            num_terminals = sum(1 for n in network.nodes.values() if n.node_type == "terminal")
            achieved_outlets = num_terminals
            density_metric = achieved_outlets
            
            print(f"  Achieved outlets: {achieved_outlets} / {target_outlets} requested")
            
            # Convert to void mesh
            void_mesh = network_to_void_mesh(network, include_caps=False)
            
            # Clean up small components
            void_mesh = remove_small_components(void_mesh, min_faces=100)
            
            # Check runtime
            elapsed = time.time() - start_time
            if elapsed > MAX_RUNTIME_SECONDS:
                attempt.error = f"Runtime exceeded: {elapsed:.2f}s > {MAX_RUNTIME_SECONDS}s"
                attempt.runtime = elapsed
                result.all_attempts.append(attempt)
                break
            
            attempt.void_mesh = void_mesh
            
            # Try embedding at 1um voxel pitch
            with tempfile.NamedTemporaryFile(suffix=".stl", delete=False) as tmp:
                void_mesh.export(tmp.name)
                tmp_path = tmp.name
            
            try:
                embed_result = embed_tree_as_negative_space(
                    tree_stl_path=tmp_path,
                    domain=domain,
                    voxel_pitch=EMBEDDING_VOXEL_PITCH_M,
                    method="voxel_subtraction",
                    output_void=True,
                    output_units="m",
                    stl_units="m",
                )
                
                final_mesh = embed_result['domain_with_void']
                metadata = embed_result.get('metadata', {})
                voxel_counts = metadata.get('voxel_counts', {})
                
                # Verify carve result
                is_valid, reason = verify_carve_result(
                    domain_voxels=voxel_counts.get('domain', 1),
                    solid_voxels=voxel_counts.get('solid', 0),
                    void_voxels=voxel_counts.get('void', 0),
                    output_volume=final_mesh.volume if final_mesh else 0,
                    domain_volume=domain_volume,
                )
                
                if not is_valid:
                    attempt.error = f"Carve verification failed: {reason}"
                    attempt.runtime = time.time() - start_time
                    result.all_attempts.append(attempt)
                    continue
                
                attempt.success = True
                attempt.final_mesh = final_mesh
                attempt.density_metric = density_metric
                attempt.voxel_counts = voxel_counts
                
            except VoxelBudgetExceededError as e:
                attempt.error = f"Voxel budget exceeded: {e}"
            except Exception as e:
                attempt.error = f"Embedding failed: {e}"
            finally:
                os.unlink(tmp_path)
            
        except Exception as e:
            attempt.error = f"Unexpected error: {e}"
        
        attempt.runtime = time.time() - start_time
        result.all_attempts.append(attempt)
        
        # Log attempt info
        log_attempt_info(
            scenario="D",
            attempt=len(result.all_attempts),
            params=params,
            grid_shape=grid_shape,
            memory_gb=memory_gb,
            voxel_counts=attempt.voxel_counts,
            watertight=attempt.final_mesh.is_watertight if attempt.final_mesh else None,
            volume=attempt.final_mesh.volume if attempt.final_mesh else None,
            runtime=attempt.runtime,
            density_metric=attempt.density_metric,
        )
        
        # Update best attempt
        if attempt.success and attempt.density_metric > best_density:
            best_density = attempt.density_metric
            best_attempt = attempt
    
    result.best_attempt = best_attempt
    return result


# =============================================================================
# SCENARIO E: PLANAR XY BRANCHING STRESS
# =============================================================================

def run_scenario_e_planar() -> ScenarioResult:
    """
    Scenario E: Planar XY branching stress
    
    Use the repo's prebuilt planar branching method if it exists.
    If not, configure an existing branching method using official parameters
    that constrain it to planar XY.
    
    Goal: maximize dense planar branching while embeddable.
    Density score: maximize segments/terminals.
    """
    print("\n" + "="*80)
    print("SCENARIO E: PLANAR XY BRANCHING STRESS")
    print("="*80)
    
    result = ScenarioResult(scenario="E")
    domain = create_cylinder_domain()
    domain_size = np.array([2 * CYLINDER_RADIUS_M, 2 * CYLINDER_RADIUS_M, CYLINDER_HEIGHT_M])
    domain_volume = math.pi * (CYLINDER_RADIUS_M ** 2) * CYLINDER_HEIGHT_M
    
    # For planar XY branching, we'll use the K-ary tree with constrained Z
    # by setting a very small angle and enforcing downward bias
    k_values = [4, 6]
    level_range = range(3, 8)
    
    best_attempt = None
    best_density = 0.0
    
    for K in k_values:
        for num_levels in level_range:
            # Check memory budget first
            within_budget, grid_shape, memory_gb = check_memory_budget(
                domain_size, EMBEDDING_VOXEL_PITCH_M
            )
            
            if not within_budget:
                print(f"\nSkipping K={K}, levels={num_levels}: "
                      f"memory {memory_gb:.2f} GB exceeds budget {MAX_MEMORY_GB} GB")
                continue
            
            params = {
                "K": K,
                "num_levels": num_levels,
                "planar_constraint": "XY",
            }
            
            attempt = AttemptResult(params=params, grid_shape=grid_shape, memory_gb=memory_gb)
            start_time = time.time()
            
            try:
                # Create network with inlet at a specific Z level for planar growth
                # Place inlet slightly below top face to allow planar growth
                planar_z = TOP_FACE_Z_M - 0.0002  # 0.2mm below top
                inlet_pos = (0.0, 0.0, planar_z)
                
                network = VascularNetwork(domain=domain, seed=42)
                inlet_node = Node(
                    id=network.id_gen.next_id(),
                    position=Point3D(*inlet_pos),
                    node_type="inlet",
                    vessel_type="venous",
                    attributes={
                        "radius": INLET_RADIUS_M,
                        # Direction in XY plane (no Z component)
                        "direction": {"dx": 1.0, "dy": 0.0, "dz": 0.0},
                        "branch_order": 0,
                    },
                )
                network.add_node(inlet_node)
                
                # Use KaryTreeSpec with planar constraints
                spec = KaryTreeSpec(
                    K=K,
                    num_levels=num_levels,
                    # Very small vertical angles to keep growth mostly planar
                    leader_angle_deg_start=5.0,
                    leader_angle_deg_min=2.0,
                    side_angle_deg_start=10.0,
                    side_angle_deg_min=5.0,
                    # Disable downward bias to keep planar
                    enforce_downward_bias=False,
                    # Use golden angle for good XY distribution
                    use_golden_angle_rotation=True,
                    # Tight envelope to stay within cylinder
                    envelope_r_frac_start=0.3,
                    envelope_r_frac_end=0.9,
                )
                
                # Compute depths (very small Z variation for planar)
                depths = [0.0001 * (i + 1) for i in range(num_levels)]  # 0.1mm increments
                
                # Grow K-ary tree with planar constraints
                grow_result = grow_kary_tree_v2(
                    network=network,
                    root_node_id=inlet_node.id,
                    depths=depths,
                    spec=spec,
                    seed=42,
                )
                
                if not grow_result.is_success():
                    attempt.error = f"Tree growth failed: {grow_result.message}"
                    attempt.runtime = time.time() - start_time
                    result.all_attempts.append(attempt)
                    continue
                
                # Get density metric
                num_segments = len(network.segments)
                num_terminals = sum(1 for n in network.nodes.values() if n.node_type == "terminal")
                density_metric = num_segments
                
                # Convert to void mesh
                void_mesh = network_to_void_mesh(network, include_caps=False)
                
                # Clean up small components
                void_mesh = remove_small_components(void_mesh, min_faces=100)
                
                # Check runtime
                elapsed = time.time() - start_time
                if elapsed > MAX_RUNTIME_SECONDS:
                    attempt.error = f"Runtime exceeded: {elapsed:.2f}s > {MAX_RUNTIME_SECONDS}s"
                    attempt.runtime = elapsed
                    result.all_attempts.append(attempt)
                    break
                
                attempt.void_mesh = void_mesh
                
                # Try embedding at 1um voxel pitch
                with tempfile.NamedTemporaryFile(suffix=".stl", delete=False) as tmp:
                    void_mesh.export(tmp.name)
                    tmp_path = tmp.name
                
                try:
                    embed_result = embed_tree_as_negative_space(
                        tree_stl_path=tmp_path,
                        domain=domain,
                        voxel_pitch=EMBEDDING_VOXEL_PITCH_M,
                        method="voxel_subtraction",
                        output_void=True,
                        output_units="m",
                        stl_units="m",
                    )
                    
                    final_mesh = embed_result['domain_with_void']
                    metadata = embed_result.get('metadata', {})
                    voxel_counts = metadata.get('voxel_counts', {})
                    
                    # Verify carve result
                    is_valid, reason = verify_carve_result(
                        domain_voxels=voxel_counts.get('domain', 1),
                        solid_voxels=voxel_counts.get('solid', 0),
                        void_voxels=voxel_counts.get('void', 0),
                        output_volume=final_mesh.volume if final_mesh else 0,
                        domain_volume=domain_volume,
                    )
                    
                    if not is_valid:
                        attempt.error = f"Carve verification failed: {reason}"
                        attempt.runtime = time.time() - start_time
                        result.all_attempts.append(attempt)
                        continue
                    
                    attempt.success = True
                    attempt.final_mesh = final_mesh
                    attempt.density_metric = density_metric
                    attempt.voxel_counts = voxel_counts
                    
                except VoxelBudgetExceededError as e:
                    attempt.error = f"Voxel budget exceeded: {e}"
                except Exception as e:
                    attempt.error = f"Embedding failed: {e}"
                finally:
                    os.unlink(tmp_path)
                
            except Exception as e:
                attempt.error = f"Unexpected error: {e}"
            
            attempt.runtime = time.time() - start_time
            result.all_attempts.append(attempt)
            
            # Log attempt info
            log_attempt_info(
                scenario="E",
                attempt=len(result.all_attempts),
                params=params,
                grid_shape=grid_shape,
                memory_gb=memory_gb,
                voxel_counts=attempt.voxel_counts,
                watertight=attempt.final_mesh.is_watertight if attempt.final_mesh else None,
                volume=attempt.final_mesh.volume if attempt.final_mesh else None,
                runtime=attempt.runtime,
                density_metric=attempt.density_metric,
            )
            
            # Update best attempt
            if attempt.success and attempt.density_metric > best_density:
                best_density = attempt.density_metric
                best_attempt = attempt
    
    result.best_attempt = best_attempt
    return result


# =============================================================================
# EXPORT FUNCTIONS
# =============================================================================

def export_scenario_results(scenario_result: ScenarioResult, domain: CylinderDomain):
    """Export the best result for a scenario."""
    scenario = scenario_result.scenario
    best = scenario_result.best_attempt
    
    if best is None:
        print(f"\nScenario {scenario}: No successful attempts to export")
        return
    
    print(f"\n{'='*60}")
    print(f"Exporting Scenario {scenario} Best Result")
    print(f"{'='*60}")
    print(f"Parameters: {best.params}")
    print(f"Density metric: {best.density_metric}")
    
    # Export intermediate void STL
    if best.void_mesh is not None:
        void_path = INTERMEDIATE_DIR / f"stress_{scenario}_{'kary' if scenario == 'A' else 'space_colonization' if scenario == 'B' else 'cco' if scenario == 'C' else 'cco_nlp' if scenario == 'D' else 'planar'}_void.stl"
        export_mesh_with_units(best.void_mesh, void_path, units="mm")
    
    # Add ridge to final mesh and export
    if best.final_mesh is not None:
        # Add ridge to the embedded mesh
        final_with_ridge = add_ridge_to_mesh(best.final_mesh, domain)
        
        scenario_names = {
            "A": "kary",
            "B": "space_colonization",
            "C": "cco",
            "D": "cco_nlp",
            "E": "planar",
        }
        final_path = FINAL_DIR / f"stress_{scenario}_{scenario_names[scenario]}_best.stl"
        export_mesh_with_units(final_with_ridge, final_path, units="mm")


# =============================================================================
# MAIN FUNCTION
# =============================================================================

def main():
    """Run all five scenarios and export results."""
    print("="*80)
    print("BRANCHING + EMBEDDING STRESS TEST")
    print("="*80)
    print(f"Max memory budget: {MAX_MEMORY_GB} GB")
    print(f"Max runtime per attempt: {MAX_RUNTIME_SECONDS} seconds")
    print(f"Embedding voxel pitch: {EMBEDDING_VOXEL_PITCH_M*1e6:.1f} um")
    print(f"Ridge voxel pitch: {RIDGE_VOXEL_PITCH_M*1e6:.1f} um")
    
    # Create output directories
    ensure_output_dirs()
    
    # Create shared domain
    domain = create_cylinder_domain()
    
    # Run all scenarios
    results = {}
    
    # Scenario A: K-ary tree
    results["A"] = run_scenario_a_kary()
    export_scenario_results(results["A"], domain)
    
    # Scenario B: Space colonization
    results["B"] = run_scenario_b_space_colonization()
    export_scenario_results(results["B"], domain)
    
    # Scenario C: CCO
    results["C"] = run_scenario_c_cco()
    export_scenario_results(results["C"], domain)
    
    # Scenario D: CCO + NLP
    results["D"] = run_scenario_d_cco_nlp()
    export_scenario_results(results["D"], domain)
    
    # Scenario E: Planar XY
    results["E"] = run_scenario_e_planar()
    export_scenario_results(results["E"], domain)
    
    # Print summary
    print("\n" + "="*80)
    print("SUMMARY")
    print("="*80)
    
    for scenario, result in results.items():
        best = result.best_attempt
        if best:
            print(f"Scenario {scenario}: SUCCESS")
            print(f"  Best params: {best.params}")
            print(f"  Density metric: {best.density_metric}")
            print(f"  Runtime: {best.runtime:.2f}s")
        else:
            print(f"Scenario {scenario}: NO SUCCESSFUL ATTEMPTS")
            if result.all_attempts:
                last_error = result.all_attempts[-1].error
                print(f"  Last error: {last_error}")
    
    print("\n" + "="*80)
    print("STRESS TEST COMPLETE")
    print("="*80)
    print(f"Intermediate outputs: {INTERMEDIATE_DIR}")
    print(f"Final outputs: {FINAL_DIR}")


if __name__ == "__main__":
    main()
