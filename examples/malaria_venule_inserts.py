#!/usr/bin/env python3
"""
Malaria Venule Inserts Generator

This module generates five STL files for malaria venule insert scaffolds:
1. Object 1 (Control): Solid cylinder with ridge, no internal voids
2. Object 2 (Control + Channels): Control with 4 straight channels
3. Object 3 (Bifurcation 512): 4 inlets with recursive bifurcation to 512 terminals
4. Object 4 (Turn-Bifurcate-Merge): Single inlet with 90-degree turn, bifurcation, merge, return
5. Object 5 (CCO-NLP Organic): 4 inlets with CCO hybrid growth + NLP iterative optimization

DESIGN CHOICES DOCUMENTED:
- Ridge geometry: Annular ring on perimeter (outer_radius=5mm, inner_radius=4.9mm)
  Fallback: Solid raised disk if ring creation fails
- Object 2 channel count: 4 channels (minimum specified)
- Object 2 channel placement: Square pattern at (+/-1.5mm, +/-1.5mm) from center
- Object 3 bifurcation depths: 0.25, 0.50, 0.75, 1.00, 1.25, 1.50, 1.75 mm from top
- Object 3 branch taper: Exponential from 1mm to 100um over 7 levels
- Overlap-based merge strategy: Voxel union merges overlapping void volumes
- Object 5 CCO-NLP: 4 rounds of CCO growth + NLP optimization, 512 total terminals
  - Coordinate convention: Cylinder centered at origin, z spans [-1mm, +1mm]
  - Inlet z aligned with top face at z = +1mm
  - Optimized per-tree after each round, then globally on merged network

UNITS:
- Internal computations: METERS
- Output STL files: MILLIMETERS (scaled at export)

Author: Generated by Agentic Organ Generation System
"""

import sys
import os
import math
import json
import numpy as np
import trimesh
from pathlib import Path
from typing import List, Tuple, Optional, Dict, Any
from dataclasses import dataclass

# Add parent directory to path for imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from generation.core.domain import CylinderDomain
from generation.core.types import Point3D, Direction3D, TubeGeometry
from generation.core.network import VascularNetwork, Node, VesselSegment
from generation.ops.build import create_network, add_inlet
from generation.ops.growth import grow_branch, grow_to_point
from generation.adapters.mesh_adapter import to_trimesh, export_stl
from generation.ops.embedding import embed_tree_as_negative_space
from generation.rules.constraints import BranchingConstraints

# Additional imports for Object 5 (CCO-NLP)
from generation.specs.design_spec import DesignSpec, CylinderSpec, TreeSpec, InletSpec
from generation.specs.compile import compile_domain
from generation.backends.cco_hybrid_backend import CCOHybridBackend, CCOConfig
from generation.optimization import optimize_geometry, NLPConfig

# Validity checking imports
from validity import run_pre_embedding_validation, run_post_embedding_validation, ValidationConfig


# =============================================================================
# HARDCODED PARAMETERS - All dimensions in METERS internally
# =============================================================================

# --- Base Cylinder Parameters (shared by all objects) ---
CYLINDER_RADIUS_M = 0.005          # 5 mm radius = 10 mm diameter
CYLINDER_HEIGHT_M = 0.002          # 2 mm height
CYLINDER_CENTER = (0.0, 0.0, 0.0)  # Centered at origin

# --- Ridge Parameters (shared by all objects) ---
RIDGE_HEIGHT_M = 0.0001            # 0.1 mm ridge height
RIDGE_THICKNESS_M = 0.0001         # 0.1 mm ridge thickness (annular ring width)
# Ridge interpretation: Annular ring on perimeter
# - Outer radius = CYLINDER_RADIUS_M (5.0 mm)
# - Inner radius = CYLINDER_RADIUS_M - RIDGE_THICKNESS_M (4.9 mm)
# - Z range = [+1.0 mm, +1.1 mm] (top of cylinder to top of ridge)

# --- Derived Parameters ---
RIDGE_INNER_RADIUS_M = CYLINDER_RADIUS_M - RIDGE_THICKNESS_M  # 4.9 mm
TOP_FACE_Z_M = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2     # +1.0 mm


# =============================================================================
# HELPER FUNCTIONS FOR PARAMETER INFERENCE
# =============================================================================

def compute_inlet_positions(
    num_inlets: int,
    inlet_radius: float,
    cylinder_radius: float = CYLINDER_RADIUS_M,
    ridge_inner_radius: float = RIDGE_INNER_RADIUS_M,
    wall_margin: float = 0.0005,  # 0.5 mm default wall margin
    include_z: bool = False,
    z_position: float = None,
) -> List[Tuple[float, ...]]:
    """
    Compute inlet positions based on geometry parameters.
    
    Inlets are placed in a symmetric pattern inside the ridge, leaving enough
    margin from the ridge inner edge and between adjacent inlets.
    
    Parameters
    ----------
    num_inlets : int
        Number of inlets to place
    inlet_radius : float
        Radius of each inlet (in meters)
    cylinder_radius : float
        Radius of the cylinder (in meters)
    ridge_inner_radius : float
        Inner radius of the ridge (in meters)
    wall_margin : float
        Minimum margin from ridge inner edge (in meters)
    include_z : bool
        If True, return 3D positions (x, y, z); if False, return 2D (x, y)
    z_position : float
        Z coordinate for 3D positions (required if include_z=True)
    
    Returns
    -------
    List of tuples with inlet positions
    """
    if num_inlets == 0:
        return []
    
    # Maximum radius for inlet center placement
    # Must stay inside ridge inner edge with margin for inlet radius
    max_placement_radius = ridge_inner_radius - inlet_radius - wall_margin
    
    if num_inlets == 1:
        # Single inlet at center
        positions = [(0.0, 0.0)]
    elif num_inlets == 2:
        # Two inlets along X axis
        offset = max_placement_radius * 0.7  # 70% of max radius
        positions = [(offset, 0.0), (-offset, 0.0)]
    elif num_inlets == 3:
        # Three inlets in equilateral triangle
        offset = max_placement_radius * 0.7
        positions = [
            (0.0, offset),
            (offset * math.cos(math.radians(210)), offset * math.sin(math.radians(210))),
            (offset * math.cos(math.radians(330)), offset * math.sin(math.radians(330))),
        ]
    elif num_inlets == 4:
        # Four inlets in square pattern
        # For a square inscribed in a circle of radius r, the offset from center is r/sqrt(2)
        offset = max_placement_radius / math.sqrt(2)
        positions = [
            (offset, offset),
            (-offset, offset),
            (-offset, -offset),
            (offset, -offset),
        ]
    else:
        # N inlets in circular pattern
        offset = max_placement_radius * 0.7
        positions = []
        for i in range(num_inlets):
            angle = 2 * math.pi * i / num_inlets
            x = offset * math.cos(angle)
            y = offset * math.sin(angle)
            positions.append((x, y))
    
    # Add Z coordinate if requested
    if include_z:
        if z_position is None:
            z_position = TOP_FACE_Z_M
        positions = [(x, y, z_position) for x, y in positions]
    
    return positions


def compute_bifurcation_depths(
    num_bifurcations: int,
    cylinder_height: float = CYLINDER_HEIGHT_M,
    top_margin_fraction: float = 0.0,
    bottom_margin_fraction: float = 0.125,
) -> List[float]:
    """
    Compute bifurcation depths based on number of bifurcations and object height.
    
    Depths are evenly spaced from near the top to near the bottom of the cylinder.
    
    Parameters
    ----------
    num_bifurcations : int
        Number of bifurcation levels
    cylinder_height : float
        Height of the cylinder (in meters)
    top_margin_fraction : float
        Fraction of height to leave as margin at top (default 0)
    bottom_margin_fraction : float
        Fraction of height to leave as margin at bottom (default 0.125 = 1/8)
    
    Returns
    -------
    List of depths (in meters) from the top face
    """
    if num_bifurcations == 0:
        return []
    
    # Usable height for bifurcations
    usable_height = cylinder_height * (1 - top_margin_fraction - bottom_margin_fraction)
    start_depth = cylinder_height * top_margin_fraction
    
    # Evenly space bifurcations
    # depth[i] = start_depth + (i + 1) / (num_bifurcations + 1) * usable_height
    depths = []
    for i in range(num_bifurcations):
        depth = start_depth + (i + 1) / (num_bifurcations + 1) * usable_height
        depths.append(depth)
    
    return depths

# =============================================================================
# OBJECT 1: Control (solid cylinder + ridge, no channels)
# =============================================================================
# Object 1 has no inlets or terminals - it's a solid control sample
OBJ1_NUM_INLETS = 0                # No inlets (solid control)
OBJ1_INLET_RADIUS_M = None         # N/A for solid control
OBJ1_TERMINAL_RADIUS_M = None      # N/A for solid control

# =============================================================================
# OBJECT 2: Straight Channels
# =============================================================================
OBJ2_NUM_INLETS = 4                # 4 straight channels (range 4-9, using minimum)
OBJ2_INLET_RADIUS_M = 0.001        # 1 mm channel/inlet radius
OBJ2_TERMINAL_RADIUS_M = 0.001     # 1 mm (same as inlet - no taper for straight channels)
OBJ2_CHANNEL_DEPTH_M = 0.001       # 1 mm channel depth (extends downward from top)
OBJ2_WALL_MARGIN_M = 0.0005        # 0.5 mm minimum wall margin from cylinder edge
# Inlet positions for Object 2 - INFERRED from geometry
OBJ2_INLET_POSITIONS = compute_inlet_positions(
    num_inlets=OBJ2_NUM_INLETS,
    inlet_radius=OBJ2_INLET_RADIUS_M,
    wall_margin=OBJ2_WALL_MARGIN_M,
)

# =============================================================================
# OBJECT 3: Recursive Bifurcation (512 terminals)
# =============================================================================
OBJ3_NUM_INLETS = 4                # 4 inlet channels
OBJ3_INLET_RADIUS_M = 0.001        # 1 mm inlet radius
OBJ3_TERMINAL_RADIUS_M = 0.0001    # 100 um terminal radius
OBJ3_TOTAL_TERMINALS = 512         # Total terminal count
OBJ3_TERMINALS_PER_INLET = 128     # 512 / 4 = 128 terminals per inlet
OBJ3_BIFURCATION_LEVELS = 7        # 2^7 = 128 terminals per inlet
OBJ3_WALL_MARGIN_M = 0.0005        # 0.5 mm minimum wall margin from cylinder edge
# Bifurcation depth schedule - INFERRED from number of bifurcations and object height
OBJ3_BIFURCATION_DEPTHS_M = compute_bifurcation_depths(
    num_bifurcations=OBJ3_BIFURCATION_LEVELS,
    cylinder_height=CYLINDER_HEIGHT_M,
)
# Inlet positions for Object 3 - INFERRED from geometry
OBJ3_INLET_POSITIONS = compute_inlet_positions(
    num_inlets=OBJ3_NUM_INLETS,
    inlet_radius=OBJ3_INLET_RADIUS_M,
    wall_margin=OBJ3_WALL_MARGIN_M,
)

# =============================================================================
# OBJECT 4: Turn-Bifurcate-Merge Loop
# =============================================================================
OBJ4_NUM_INLETS = 1                # Single inlet for loop structure
OBJ4_INLET_RADIUS_M = 0.001        # 1 mm inlet radius
OBJ4_TERMINAL_RADIUS_M = 0.0005    # 500 um terminal radius (before merge back)
OBJ4_DOWNWARD_LENGTH_M = 0.001     # 1 mm downward travel before turn
OBJ4_HORIZONTAL_LENGTH_M = 0.001   # 1 mm horizontal travel after turn
OBJ4_NUM_BIFURCATIONS = 3          # Number of bifurcation levels in lateral plane
OBJ4_MERGE_OVERLAP_M = 0.0005      # 0.5 mm overlap for merge region
OBJ4_WALL_MARGIN_M = 0.0005        # 0.5 mm minimum wall margin from cylinder edge
# Inlet position for Object 4 - INFERRED from geometry (single inlet at center)
_obj4_positions = compute_inlet_positions(
    num_inlets=OBJ4_NUM_INLETS,
    inlet_radius=OBJ4_INLET_RADIUS_M,
    wall_margin=OBJ4_WALL_MARGIN_M,
)
OBJ4_INLET_POSITION = _obj4_positions[0] if _obj4_positions else (0.0, 0.0)

# =============================================================================
# OBJECT 5: CCO-NLP Organic Growth
# =============================================================================
# Coordinate convention: Cylinder centered at origin, z spans [-1mm, +1mm]
# Top face at z = +1mm = +0.001m
OBJ5_NUM_INLETS = 4                # 4 inlet channels
OBJ5_INLET_RADIUS_M = 0.001        # 1 mm inlet radius
OBJ5_TERMINAL_RADIUS_M = 0.0001    # 100 um terminal radius (minimum)
OBJ5_TOTAL_OUTLETS = 512           # Total terminal outlets (128 per inlet)
OBJ5_NUM_ROUNDS = 4                # Number of CCO growth rounds
OBJ5_OUTLETS_PER_ROUND = 32        # 512 / 4 inlets / 4 rounds = 32 per round per inlet
OBJ5_STRAIGHT_DOWN_M = 0.0001      # 0.1 mm straight down before CCO growth
OBJ5_VESSEL_TYPE = "venous"        # Vessel type for inserts
OBJ5_SEED = 42                     # Random seed for reproducibility
OBJ5_WALL_MARGIN_M = 0.0005        # 0.5 mm minimum wall margin from cylinder edge
# Inlet positions for Object 5 - INFERRED from geometry (with Z coordinate at top face)
OBJ5_INLET_POSITIONS = compute_inlet_positions(
    num_inlets=OBJ5_NUM_INLETS,
    inlet_radius=OBJ5_INLET_RADIUS_M,
    wall_margin=OBJ5_WALL_MARGIN_M,
    include_z=True,
    z_position=TOP_FACE_Z_M,
)
# CCO configuration parameters (tuned for tiny domain)
OBJ5_CCO_COLLISION_CLEARANCE = 5e-5    # 50 um collision clearance
OBJ5_CCO_MIN_SEGMENT_LENGTH = 2e-4     # 200 um minimum segment
OBJ5_CCO_MAX_SEGMENT_LENGTH = 2e-3     # 2 mm maximum segment (within 2mm height)
OBJ5_CCO_MIN_TERMINAL_SEP = 5e-5       # 50 um between terminals
OBJ5_CCO_CANDIDATE_EDGES_K = 50        # Candidate edges for optimization
OBJ5_CCO_GRID_RESOLUTION = 10          # Grid resolution for bifurcation optimization
OBJ5_CCO_USE_NLP = True                # Enable NLP-based bifurcation optimization
OBJ5_CCO_MURRAY_EXPONENT = 3.0         # Murray's law exponent
# NLP global optimization parameters
OBJ5_NLP_ENABLED = True                # Enable global NLP optimization
OBJ5_NLP_MURRAY_EXPONENT = 3.0         # Murray's law exponent
OBJ5_NLP_TARGET_PRESSURE_DROP = 13332.0  # ~100 mmHg pressure drop
OBJ5_NLP_VISCOSITY = 0.0035            # Blood viscosity (Pa*s)
OBJ5_NLP_FIX_TERMINALS = True          # Fix terminal positions
OBJ5_NLP_FIX_ROOT = True               # Fix inlet positions
OBJ5_NLP_MAX_ITERATIONS = 500          # Max optimization iterations
OBJ5_NLP_TOLERANCE = 1e-5              # Solver tolerance
OBJ5_NLP_CLEANUP_DEGENERATE = True     # Remove degenerate segments

# =============================================================================
# VOXELIZATION PARAMETERS
# =============================================================================
VOXEL_PITCH_M = 2.5e-5             # 25 um voxel pitch (for fine resolution embedding)
VOXEL_PITCH_UNION_M = 5.0e-5       # 50 um voxel pitch (for union operations)
# Note: Ridge is 0.1mm (100um) thick, so we need at least 2 voxels across it
# Using 50um pitch gives 2 voxels across the ridge thickness for proper resolution
# 25 um pitch on 10mm x 10mm x 2mm domain = ~12.8M voxels
VOXEL_PITCH_RIDGE_M = 2.5e-5       # 25 um for ridge operations (4 voxels across 0.1mm ridge)

# =============================================================================
# OUTPUT PARAMETERS
# =============================================================================
OUTPUT_UNITS = "mm"                # Output STL files in millimeters
OUTPUT_DIR = Path(__file__).parent / "Malaria Venule Inserts"


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def meters_to_mm(value_m: float) -> float:
    """Convert meters to millimeters."""
    return value_m * 1000.0


def print_validation_details(report, indent: str = "    "):
    """
    Print detailed validation results including failure reasons.
    
    Parameters
    ----------
    report : ValidationReport
        The validation report to print details from
    indent : str
        Indentation prefix for output lines
    """
    print(f"{indent}Validation status: {report.status}")
    print(f"{indent}Passed: {report.passed}")
    
    if not report.passed or report.status != "ok":
        summary = report.summary
        print(f"{indent}Summary: {summary.get('passed_checks', '?')}/{summary.get('total_checks', '?')} checks passed, "
              f"{summary.get('failed_checks', '?')} failed, {summary.get('total_warnings', '?')} warnings")
        
        for category_name, category_report in report.reports.items():
            if not category_report.passed:
                print(f"{indent}  Category '{category_name}' FAILED:")
                for check in category_report.checks:
                    if not check.passed:
                        print(f"{indent}    - {check.check_name}: {check.message}")
                        if check.details:
                            for key, value in check.details.items():
                                print(f"{indent}        {key}: {value}")
            elif hasattr(category_report, 'checks'):
                for check in category_report.checks:
                    if check.warnings:
                        print(f"{indent}  Category '{category_name}' warnings:")
                        for warning in check.warnings:
                            print(f"{indent}    - {check.check_name}: {warning}")


def create_cylinder_mesh(radius: float, height: float, center: Tuple[float, float, float]) -> trimesh.Trimesh:
    """Create a solid cylinder mesh centered at the given point."""
    cylinder = trimesh.creation.cylinder(
        radius=radius,
        height=height,
        sections=64,
    )
    cylinder.apply_translation([center[0], center[1], center[2]])
    return cylinder


def create_ridge_mesh(
    outer_radius: float,
    inner_radius: float,
    height: float,
    z_base: float,
    center_xy: Tuple[float, float],
) -> trimesh.Trimesh:
    """
    Create an annular ring (ridge) mesh using direct mesh construction (no Blender).
    
    Design choice: Ridge is an annular ring on the perimeter of the top face.
    Uses direct vertex/face construction to avoid Blender dependency.
    Falls back to solid disk only if mesh construction fails.
    """
    try:
        # Create ring using direct mesh construction (no Blender dependency)
        # Generate annular cross-section
        angles = np.linspace(0, 2 * np.pi, 65)
        outer_points = np.column_stack([
            outer_radius * np.cos(angles),
            outer_radius * np.sin(angles),
        ])
        inner_points = np.column_stack([
            inner_radius * np.cos(angles[::-1]),
            inner_radius * np.sin(angles[::-1]),
        ])
        
        # Create top and bottom faces
        n_outer = len(outer_points) - 1
        n_inner = len(inner_points) - 1
        
        # Build vertices for top and bottom rings
        top_z = z_base + height
        bottom_z = z_base
        
        vertices = []
        # Bottom outer ring
        for i in range(n_outer):
            vertices.append([outer_points[i, 0] + center_xy[0], 
                           outer_points[i, 1] + center_xy[1], bottom_z])
        # Bottom inner ring
        for i in range(n_inner):
            vertices.append([inner_points[i, 0] + center_xy[0], 
                           inner_points[i, 1] + center_xy[1], bottom_z])
        # Top outer ring
        for i in range(n_outer):
            vertices.append([outer_points[i, 0] + center_xy[0], 
                           outer_points[i, 1] + center_xy[1], top_z])
        # Top inner ring
        for i in range(n_inner):
            vertices.append([inner_points[i, 0] + center_xy[0], 
                           inner_points[i, 1] + center_xy[1], top_z])
        
        vertices = np.array(vertices)
        
        # Build faces
        faces = []
        # Outer wall faces
        for i in range(n_outer):
            i_next = (i + 1) % n_outer
            # Bottom outer, top outer
            faces.append([i, i_next, i + 2 * n_outer])
            faces.append([i_next, i_next + 2 * n_outer, i + 2 * n_outer])
        
        # Inner wall faces
        for i in range(n_inner):
            i_next = (i + 1) % n_inner
            base = n_outer
            top_base = 3 * n_outer
            # Bottom inner, top inner (reversed winding)
            faces.append([base + i, base + i + 2 * n_outer, base + i_next])
            faces.append([base + i_next, base + i + 2 * n_outer, base + i_next + 2 * n_outer])
        
        # Top and bottom annular faces
        for i in range(n_outer):
            i_next = (i + 1) % n_outer
            # Bottom face
            faces.append([i, n_outer + i, i_next])
            faces.append([i_next, n_outer + i, n_outer + i_next])
            # Top face
            faces.append([2 * n_outer + i, 2 * n_outer + i_next, 3 * n_outer + i])
            faces.append([2 * n_outer + i_next, 3 * n_outer + i_next, 3 * n_outer + i])
        
        ring = trimesh.Trimesh(vertices=vertices, faces=np.array(faces))
        ring.fix_normals()
        print("  Ridge: Created annular ring using direct mesh construction")
        return ring
        
    except Exception as e:
        print(f"  Ridge: Annular ring creation failed ({e}), using solid disk fallback")
        # Fallback: Solid disk
        disk = trimesh.creation.cylinder(
            radius=outer_radius,
            height=height,
            sections=64,
        )
        disk.apply_translation([center_xy[0], center_xy[1], z_base + height / 2])
        print("  Ridge: Created solid disk (fallback)")
        return disk


def create_channel_mesh(
    position_xy: Tuple[float, float],
    z_top: float,
    radius: float,
    depth: float,
) -> trimesh.Trimesh:
    """Create a cylindrical channel mesh extending downward from z_top."""
    channel = trimesh.creation.cylinder(
        radius=radius,
        height=depth,
        sections=32,
    )
    # Position so top of channel is at z_top
    channel.apply_translation([position_xy[0], position_xy[1], z_top - depth / 2])
    return channel


def compute_taper_radius(level: int, total_levels: int, r_start: float, r_end: float) -> float:
    """
    Compute radius at a given bifurcation level using exponential taper.
    
    r_k = r_0 * (r_end/r_0)^(k/total_levels)
    """
    if total_levels == 0:
        return r_start
    ratio = r_end / r_start
    return r_start * (ratio ** (level / total_levels))


def voxel_union_meshes(meshes: List[trimesh.Trimesh], pitch: float) -> trimesh.Trimesh:
    """
    Union multiple meshes using voxelization and marching cubes.
    
    This is the overlap-based merge strategy: overlapping volumes are
    automatically merged during voxelization.
    """
    from skimage.measure import marching_cubes
    
    if not meshes:
        raise ValueError("No meshes to union")
    
    if len(meshes) == 1:
        return meshes[0]
    
    # Concatenate all meshes
    combined = trimesh.util.concatenate(meshes)
    
    # Voxelize
    try:
        voxels = combined.voxelized(pitch)
        voxel_matrix = voxels.matrix
    except (MemoryError, ValueError):
        # Try with coarser pitch
        pitch *= 2
        voxels = combined.voxelized(pitch)
        voxel_matrix = voxels.matrix
    
    # Marching cubes
    verts, faces, _, _ = marching_cubes(
        volume=voxel_matrix.astype(np.uint8),
        level=0.5,
        spacing=(pitch, pitch, pitch),
        allow_degenerate=False,
    )
    
    # Transform back to world coordinates
    verts += voxels.transform[:3, 3]
    
    result = trimesh.Trimesh(
        vertices=verts,
        faces=faces.astype(np.int64),
        process=False,
    )
    
    result.remove_unreferenced_vertices()
    if result.volume < 0:
        result.invert()
    trimesh.repair.fix_normals(result)
    
    return result


def scale_mesh_to_mm(mesh: trimesh.Trimesh) -> trimesh.Trimesh:
    """Scale mesh from meters to millimeters."""
    scaled = mesh.copy()
    scaled.apply_scale(1000.0)  # m to mm
    return scaled


def export_mesh_with_units(mesh: trimesh.Trimesh, output_path: Path, units: str = "mm"):
    """Export mesh to STL with units.json sidecar file."""
    mesh.export(str(output_path))
    
    # Write units sidecar
    sidecar_path = str(output_path) + ".units.json"
    metadata = {
        "units": units,
        "stl_file": str(output_path),
        "description": "Malaria Venule Insert scaffold",
    }
    with open(sidecar_path, 'w') as f:
        json.dump(metadata, f, indent=2)
    
    print(f"  Exported: {output_path}")
    print(f"  Units sidecar: {sidecar_path}")


def embed_void_in_cylinder(
    void_mesh: trimesh.Trimesh,
    output_dir: Optional[Path] = None,
    object_name: str = "object",
    voxel_pitch: float = VOXEL_PITCH_M,
) -> trimesh.Trimesh:
    """
    Use the repo's embed_tree_as_negative_space function to carve voids from a cylinder domain.
    
    This function:
    1. Exports the void mesh to a temporary STL file (in meters)
    2. Creates a CylinderDomain matching our base cylinder
    3. Calls embed_tree_as_negative_space to carve the void
    4. Returns the domain_with_void mesh (in meters, for consistency with other functions)
    
    Parameters
    ----------
    void_mesh : trimesh.Trimesh
        The void/channel mesh to carve from the cylinder (in meters)
    output_dir : Path, optional
        Directory to save intermediate STL files
    object_name : str
        Name prefix for intermediate files
    voxel_pitch : float
        Voxel pitch for embedding (in meters)
    
    Returns
    -------
    trimesh.Trimesh
        The cylinder domain with void carved out (in meters)
    """
    import tempfile
    
    # Create temporary directory for intermediate files
    temp_dir = Path(tempfile.mkdtemp(prefix=f"embed_{object_name}_"))
    
    # Export void mesh to temporary STL (in meters, with units.json sidecar)
    void_stl_path = temp_dir / f"{object_name}_void.stl"
    void_mesh.export(str(void_stl_path))
    
    # Write units sidecar so embed_tree_as_negative_space knows the units
    sidecar_path = str(void_stl_path) + ".units.json"
    with open(sidecar_path, 'w') as f:
        json.dump({"units": "m"}, f)
    
    print(f"    Exported void mesh to: {void_stl_path}")
    
    # Also save to output_dir if provided
    if output_dir:
        intermediate_path = output_dir / "intermediate" / f"{object_name}_void_for_embedding.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(void_mesh).export(str(intermediate_path))
    
    # Create CylinderDomain matching our base cylinder
    domain = CylinderDomain(
        center=Point3D(CYLINDER_CENTER[0], CYLINDER_CENTER[1], CYLINDER_CENTER[2]),
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
    )
    
    print(f"    Using embed_tree_as_negative_space with voxel_pitch={voxel_pitch*1000000}um")
    
    # Call the repo's embedding function
    result = embed_tree_as_negative_space(
        tree_stl_path=void_stl_path,
        domain=domain,
        voxel_pitch=voxel_pitch,
        stl_units="m",  # We exported in meters
        geometry_units="m",  # Domain is in meters
        output_units="m",  # Return in meters (we'll scale to mm at final export)
        output_void=True,
        smoothing_iters=3,
    )
    
    domain_with_void = result['domain_with_void']
    
    if domain_with_void is None:
        raise RuntimeError(f"embed_tree_as_negative_space returned None for domain_with_void")
    
    print(f"    Embedding complete: {len(domain_with_void.vertices)} vertices, {len(domain_with_void.faces)} faces")
    print(f"    Watertight: {domain_with_void.is_watertight}")
    
    # Clean up temp files
    import shutil
    shutil.rmtree(temp_dir, ignore_errors=True)
    
    return domain_with_void


# =============================================================================
# OBJECT GENERATION FUNCTIONS
# =============================================================================

def generate_object1_control(output_dir: Optional[Path] = None) -> trimesh.Trimesh:
    """
    Generate Object 1: Control cylinder with ridge, no internal voids.
    
    Returns mesh in METERS (will be scaled to mm at export).
    
    Parameters
    ----------
    output_dir : Path, optional
        Directory to save intermediate STL files for debugging
    """
    print("\n" + "=" * 60)
    print("Generating Object 1: Control (solid cylinder + ridge)")
    print("=" * 60)
    
    # Create base cylinder
    print("  Creating base cylinder...")
    base_cylinder = create_cylinder_mesh(
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
        center=CYLINDER_CENTER,
    )
    print(f"    Cylinder: radius={meters_to_mm(CYLINDER_RADIUS_M)}mm, "
          f"height={meters_to_mm(CYLINDER_HEIGHT_M)}mm")
    
    # Export intermediate cylinder mesh
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object1_cylinder.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(base_cylinder).export(str(intermediate_path))
        print(f"    Exported intermediate: {intermediate_path}")
    
    # Create ridge on top face
    print("  Creating ridge...")
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2  # Top of cylinder
    ridge = create_ridge_mesh(
        outer_radius=CYLINDER_RADIUS_M,
        inner_radius=CYLINDER_RADIUS_M - RIDGE_THICKNESS_M,
        height=RIDGE_HEIGHT_M,
        z_base=z_top,
        center_xy=(CYLINDER_CENTER[0], CYLINDER_CENTER[1]),
    )
    print(f"    Ridge: outer_r={meters_to_mm(CYLINDER_RADIUS_M)}mm, "
          f"inner_r={meters_to_mm(CYLINDER_RADIUS_M - RIDGE_THICKNESS_M)}mm, "
          f"height={meters_to_mm(RIDGE_HEIGHT_M)}mm")
    
    # Export intermediate ridge mesh
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object1_ridge.stl"
        scale_mesh_to_mm(ridge).export(str(intermediate_path))
        print(f"    Exported intermediate: {intermediate_path}")
    
    # Union cylinder and ridge using FINE pitch for ridge (0.1mm ridge needs fine resolution)
    print(f"  Combining cylinder and ridge (voxel pitch: {meters_to_mm(VOXEL_PITCH_RIDGE_M)*1000:.0f}um)...")
    combined = voxel_union_meshes([base_cylinder, ridge], pitch=VOXEL_PITCH_RIDGE_M)
    
    print(f"  Object 1 complete: {len(combined.vertices)} vertices, {len(combined.faces)} faces")
    print(f"    Watertight: {combined.is_watertight}")
    
    # Run post-embedding validation
    print("  Running validation...")
    try:
        validation_config = ValidationConfig(
            voxel_pitch_m=VOXEL_PITCH_M,
            expected_outlets=0,  # No outlets for control
        )
        report = run_post_embedding_validation(mesh=combined, config=validation_config)
        print_validation_details(report)
    except Exception as e:
        print(f"    Validation error: {e}")
        import traceback
        traceback.print_exc()
    
    return combined


def generate_object2_channels(output_dir: Optional[Path] = None) -> trimesh.Trimesh:
    """
    Generate Object 2: Control + straight channels.
    
    Design choice: 4 channels in a square pattern at (+/-1.5mm, +/-1.5mm).
    Uses the repo's embed_tree_as_negative_space function for embedding.
    
    Returns mesh in METERS (will be scaled to mm at export).
    
    Parameters
    ----------
    output_dir : Path, optional
        Directory to save intermediate STL files for debugging
    """
    print("\n" + "=" * 60)
    print("Generating Object 2: Control + straight channels")
    print("=" * 60)
    
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    
    # Create channels
    print(f"  Creating {OBJ2_NUM_INLETS} straight channels...")
    
    channels = []
    for i, pos in enumerate(OBJ2_INLET_POSITIONS[:OBJ2_NUM_INLETS]):
        channel = create_channel_mesh(
            position_xy=pos,
            z_top=z_top,
            radius=OBJ2_INLET_RADIUS_M,
            depth=OBJ2_CHANNEL_DEPTH_M,
        )
        channels.append(channel)
        print(f"    Channel {i+1}: position=({meters_to_mm(pos[0]):.1f}, {meters_to_mm(pos[1]):.1f})mm, "
              f"radius={meters_to_mm(OBJ2_INLET_RADIUS_M)}mm, depth={meters_to_mm(OBJ2_CHANNEL_DEPTH_M)}mm")
    
    # Union all channels
    print("  Combining channels...")
    channel_void = voxel_union_meshes(channels, pitch=VOXEL_PITCH_UNION_M)
    
    # Export intermediate channel void mesh
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object2_channel_void.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(channel_void).export(str(intermediate_path))
        print(f"    Exported intermediate void: {intermediate_path}")
    
    # Use the repo's embed_tree_as_negative_space function to carve channels from cylinder
    print("  Carving channels using embed_tree_as_negative_space...")
    cylinder_with_void = embed_void_in_cylinder(
        void_mesh=channel_void,
        output_dir=output_dir,
        object_name="object2",
        voxel_pitch=VOXEL_PITCH_M,
    )
    
    # Export intermediate cylinder with void (before ridge)
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object2_cylinder_with_void.stl"
        scale_mesh_to_mm(cylinder_with_void).export(str(intermediate_path))
        print(f"    Exported intermediate cylinder with void: {intermediate_path}")
    
    print(f"  Cylinder with void: {len(cylinder_with_void.vertices)} vertices, {len(cylinder_with_void.faces)} faces")
    print(f"    Watertight: {cylinder_with_void.is_watertight}")
    
    # Run post-embedding validation on cylinder with void (before adding ridge)
    print("  Running validation on cylinder with void...")
    try:
        validation_config = ValidationConfig(
            voxel_pitch_m=VOXEL_PITCH_M,
            expected_outlets=OBJ2_NUM_INLETS,
        )
        report = run_post_embedding_validation(mesh=cylinder_with_void, config=validation_config)
        print_validation_details(report)
    except Exception as e:
        print(f"    Validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Return cylinder_with_void - ridge will be added at the END in main() to prevent smoothing
    return cylinder_with_void


def generate_bifurcation_tree_mesh(
    inlet_position: Tuple[float, float, float],
    inlet_radius: float,
    terminal_radius: float,
    bifurcation_depths: List[float],
    base_angle_deg: float = 30.0,
) -> trimesh.Trimesh:
    """
    Generate a bifurcating tree mesh from a single inlet.
    
    Uses recursive bifurcation with exponential radius taper.
    Overlapping branches are merged via voxel union.
    
    Parameters
    ----------
    inlet_position : tuple
        (x, y, z) position of inlet in meters
    inlet_radius : float
        Radius at inlet in meters
    terminal_radius : float
        Radius at terminals in meters
    bifurcation_depths : list
        Z-depths (from top) where bifurcations occur, in meters
    base_angle_deg : float
        Base bifurcation angle in degrees
    
    Returns
    -------
    trimesh.Trimesh
        Combined mesh of all branches
    """
    num_levels = len(bifurcation_depths)
    all_segments = []
    
    # Track current branch tips: list of (position, direction, radius, level)
    # Direction is a unit vector
    current_tips = [(
        np.array(inlet_position),
        np.array([0.0, 0.0, -1.0]),  # Downward
        inlet_radius,
        0,
    )]
    
    for level in range(num_levels):
        depth = bifurcation_depths[level]
        target_z = inlet_position[2] - depth
        
        new_tips = []
        
        for tip_pos, tip_dir, tip_radius, tip_level in current_tips:
            if tip_level != level:
                new_tips.append((tip_pos, tip_dir, tip_radius, tip_level))
                continue
            
            # Compute radius for this level
            current_radius = compute_taper_radius(level, num_levels, inlet_radius, terminal_radius)
            next_radius = compute_taper_radius(level + 1, num_levels, inlet_radius, terminal_radius)
            
            # Grow to bifurcation point
            # Distance to target z
            if abs(tip_dir[2]) > 0.1:
                dist_to_target = abs((target_z - tip_pos[2]) / tip_dir[2])
            else:
                dist_to_target = 0.0002  # Small step for horizontal branches
            
            dist_to_target = max(dist_to_target, 0.0001)  # Minimum segment length
            
            bifurc_pos = tip_pos + tip_dir * dist_to_target
            
            # Create segment to bifurcation point
            seg_mesh = _create_tapered_cylinder(
                start=tip_pos,
                end=bifurc_pos,
                radius_start=current_radius,
                radius_end=current_radius,
            )
            all_segments.append(seg_mesh)
            
            # Create two child branches
            # Compute perpendicular directions for bifurcation
            if abs(tip_dir[2]) > 0.9:
                # Mostly vertical, use X and Y for lateral spread
                perp1 = np.array([1.0, 0.0, 0.0])
                perp2 = np.array([0.0, 1.0, 0.0])
            else:
                # Compute perpendicular in XY plane
                perp1 = np.cross(tip_dir, np.array([0.0, 0.0, 1.0]))
                perp1 = perp1 / np.linalg.norm(perp1)
                perp2 = np.cross(tip_dir, perp1)
                perp2 = perp2 / np.linalg.norm(perp2)
            
            # Angle for bifurcation (decreases with level for tighter packing)
            angle_rad = math.radians(base_angle_deg * (1.0 - 0.1 * level))
            
            # Child 1: deflect in perp1 direction
            child1_dir = tip_dir * math.cos(angle_rad) + perp1 * math.sin(angle_rad)
            child1_dir = child1_dir / np.linalg.norm(child1_dir)
            
            # Child 2: deflect in opposite perp1 direction
            child2_dir = tip_dir * math.cos(angle_rad) - perp1 * math.sin(angle_rad)
            child2_dir = child2_dir / np.linalg.norm(child2_dir)
            
            new_tips.append((bifurc_pos.copy(), child1_dir, next_radius, level + 1))
            new_tips.append((bifurc_pos.copy(), child2_dir, next_radius, level + 1))
        
        current_tips = new_tips
    
    # Add final segments for terminal tips
    for tip_pos, tip_dir, tip_radius, tip_level in current_tips:
        # Short terminal segment
        end_pos = tip_pos + tip_dir * 0.0001
        seg_mesh = _create_tapered_cylinder(
            start=tip_pos,
            end=end_pos,
            radius_start=tip_radius,
            radius_end=terminal_radius,
        )
        all_segments.append(seg_mesh)
    
    # Union all segments (overlap-based merge)
    print(f"    Combining {len(all_segments)} branch segments...")
    combined = voxel_union_meshes(all_segments, pitch=VOXEL_PITCH_UNION_M)
    
    return combined


def _create_tapered_cylinder(
    start: np.ndarray,
    end: np.ndarray,
    radius_start: float,
    radius_end: float,
    sections: int = 16,
) -> trimesh.Trimesh:
    """Create a tapered cylinder (frustum) between two points."""
    direction = end - start
    length = np.linalg.norm(direction)
    
    if length < 1e-9:
        # Degenerate segment, return small sphere
        sphere = trimesh.creation.icosphere(subdivisions=1, radius=radius_start)
        sphere.apply_translation(start)
        return sphere
    
    direction = direction / length
    
    # Create frustum along Z axis
    if abs(radius_start - radius_end) < 1e-10:
        frustum = trimesh.creation.cylinder(
            radius=radius_start,
            height=length,
            sections=sections,
        )
    else:
        # Manual frustum creation
        angles = np.linspace(0, 2 * np.pi, sections, endpoint=False)
        
        z_bottom = -length / 2
        z_top = length / 2
        
        bottom_verts = np.column_stack([
            radius_start * np.cos(angles),
            radius_start * np.sin(angles),
            np.full(sections, z_bottom),
        ])
        
        top_verts = np.column_stack([
            radius_end * np.cos(angles),
            radius_end * np.sin(angles),
            np.full(sections, z_top),
        ])
        
        # Center vertices for caps
        center_bottom = np.array([[0, 0, z_bottom]])
        center_top = np.array([[0, 0, z_top]])
        
        vertices = np.vstack([bottom_verts, top_verts, center_bottom, center_top])
        
        faces = []
        # Side faces
        for i in range(sections):
            i_next = (i + 1) % sections
            faces.append([i, i_next, i + sections])
            faces.append([i_next, i_next + sections, i + sections])
        
        # Bottom cap
        center_bottom_idx = 2 * sections
        for i in range(sections):
            i_next = (i + 1) % sections
            faces.append([center_bottom_idx, i_next, i])
        
        # Top cap
        center_top_idx = 2 * sections + 1
        for i in range(sections):
            i_next = (i + 1) % sections
            faces.append([center_top_idx, i + sections, i_next + sections])
        
        frustum = trimesh.Trimesh(vertices=vertices, faces=np.array(faces))
    
    # Rotate to align with direction
    z_axis = np.array([0, 0, 1])
    if not np.allclose(direction, z_axis) and not np.allclose(direction, -z_axis):
        rotation_axis = np.cross(z_axis, direction)
        if np.linalg.norm(rotation_axis) > 1e-6:
            rotation_axis = rotation_axis / np.linalg.norm(rotation_axis)
            angle = np.arccos(np.clip(np.dot(z_axis, direction), -1, 1))
            rotation_matrix = trimesh.transformations.rotation_matrix(angle, rotation_axis)
            frustum.apply_transform(rotation_matrix)
    elif np.allclose(direction, -z_axis):
        rotation_matrix = trimesh.transformations.rotation_matrix(np.pi, [1, 0, 0])
        frustum.apply_transform(rotation_matrix)
    
    # Translate to position
    center = (start + end) / 2
    frustum.apply_translation(center)
    
    return frustum


def generate_object3_bifurcate_512(output_dir: Optional[Path] = None) -> trimesh.Trimesh:
    """
    Generate Object 3: Recursive bifurcation to 512 terminals.
    
    Design choices:
    - 4 inlets at symmetric positions near center
    - 7 bifurcation levels per inlet (2^7 = 128 terminals each)
    - Exponential radius taper from 1mm to 100um
    - Bifurcation depths at 0.25, 0.50, 0.75, 1.00, 1.25, 1.50, 1.75 mm
    - Overlapping branches merge via voxel union
    - Uses the repo's embed_tree_as_negative_space function for embedding
    
    Returns mesh in METERS (will be scaled to mm at export).
    
    Parameters
    ----------
    output_dir : Path, optional
        Directory to save intermediate STL files for debugging
    """
    print("\n" + "=" * 60)
    print("Generating Object 3: Recursive bifurcation to 512 terminals")
    print("=" * 60)
    
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    
    # Generate bifurcating trees from each inlet
    print(f"  Generating {OBJ3_NUM_INLETS} bifurcating trees...")
    all_trees = []
    
    for i, (x, y) in enumerate(OBJ3_INLET_POSITIONS):
        print(f"    Tree {i+1}: inlet at ({meters_to_mm(x):.1f}, {meters_to_mm(y):.1f})mm")
        inlet_pos = (x, y, z_top)
        
        tree_mesh = generate_bifurcation_tree_mesh(
            inlet_position=inlet_pos,
            inlet_radius=OBJ3_INLET_RADIUS_M,
            terminal_radius=OBJ3_TERMINAL_RADIUS_M,
            bifurcation_depths=OBJ3_BIFURCATION_DEPTHS_M,
            base_angle_deg=30.0,
        )
        all_trees.append(tree_mesh)
        print(f"      Generated tree with {len(tree_mesh.vertices)} vertices")
    
    # Union all trees (overlapping branches merge)
    print("  Combining all trees (overlap-based merge)...")
    combined_void = voxel_union_meshes(all_trees, pitch=VOXEL_PITCH_UNION_M)
    
    # Export intermediate tree void mesh
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object3_tree_void.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(combined_void).export(str(intermediate_path))
        print(f"    Exported intermediate void: {intermediate_path}")
    
    # Run pre-embedding validation on tree mesh
    print("  Running pre-embedding validation on tree mesh...")
    try:
        pre_report = run_pre_embedding_validation(mesh=combined_void)
        print_validation_details(pre_report)
    except Exception as e:
        print(f"    Pre-embedding validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Use the repo's embed_tree_as_negative_space function to carve voids from cylinder
    print("  Carving voids using embed_tree_as_negative_space...")
    cylinder_with_void = embed_void_in_cylinder(
        void_mesh=combined_void,
        output_dir=output_dir,
        object_name="object3",
        voxel_pitch=VOXEL_PITCH_M,
    )
    
    # Export intermediate cylinder with void (before ridge)
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object3_cylinder_with_void.stl"
        scale_mesh_to_mm(cylinder_with_void).export(str(intermediate_path))
        print(f"    Exported intermediate cylinder with void: {intermediate_path}")
    
    print(f"  Cylinder with void: {len(cylinder_with_void.vertices)} vertices, {len(cylinder_with_void.faces)} faces")
    print(f"    Watertight: {cylinder_with_void.is_watertight}")
    
    # Run post-embedding validation on cylinder with void (before adding ridge)
    print("  Running post-embedding validation on cylinder with void...")
    try:
        validation_config = ValidationConfig(
            voxel_pitch_m=VOXEL_PITCH_M,
            expected_outlets=OBJ3_TOTAL_TERMINALS,
        )
        report = run_post_embedding_validation(mesh=cylinder_with_void, config=validation_config)
        print_validation_details(report)
    except Exception as e:
        print(f"    Validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Return cylinder_with_void - ridge will be added at the END in main() to prevent smoothing
    return cylinder_with_void


def generate_object4_turn_bifurcate_merge(output_dir: Optional[Path] = None) -> trimesh.Trimesh:
    """
    Generate Object 4: Single inlet, 90-degree turn, bifurcate, merge, return.
    
    Design choices:
    - Single inlet at center top face, radius 1mm
    - Travel downward 1mm
    - Turn 90 degrees (along +X direction)
    - Bifurcate in XY plane
    - Branches merge by overlapping in space (voxel union)
    - Single trunk returns upward to exit near top face
    - Uses the repo's embed_tree_as_negative_space function for embedding
    
    Returns mesh in METERS (will be scaled to mm at export).
    
    Parameters
    ----------
    output_dir : Path, optional
        Directory to save intermediate STL files for debugging
    """
    print("\n" + "=" * 60)
    print("Generating Object 4: Turn-Bifurcate-Merge loop")
    print("=" * 60)
    
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    z_bottom = CYLINDER_CENTER[2] - CYLINDER_HEIGHT_M / 2
    
    # Build the channel network
    print("  Building channel network...")
    channel_segments = []
    
    # Inlet position (slightly offset from center to allow return path)
    inlet_x = OBJ4_INLET_POSITION[0] - 0.001  # Offset from center to allow return path
    inlet_y = OBJ4_INLET_POSITION[1]
    inlet_pos = np.array([inlet_x, inlet_y, z_top])
    
    # 1. Downward segment (1mm)
    print("    Segment 1: Downward 1mm")
    down_end = inlet_pos + np.array([0, 0, -OBJ4_DOWNWARD_LENGTH_M])
    seg1 = _create_tapered_cylinder(inlet_pos, down_end, OBJ4_INLET_RADIUS_M, OBJ4_INLET_RADIUS_M)
    channel_segments.append(seg1)
    
    # 2. 90-degree turn (horizontal along +X)
    print("    Segment 2: Horizontal turn (+X direction)")
    turn_end = down_end + np.array([OBJ4_HORIZONTAL_LENGTH_M, 0, 0])
    seg2 = _create_tapered_cylinder(down_end, turn_end, OBJ4_INLET_RADIUS_M, OBJ4_INLET_RADIUS_M * 0.9)
    channel_segments.append(seg2)
    
    # 3. Bifurcate in XY plane
    print(f"    Bifurcating {OBJ4_NUM_BIFURCATIONS} levels in XY plane")
    
    # Create bifurcating branches
    branch_tips = [(turn_end.copy(), np.array([1.0, 0.0, 0.0]), OBJ4_INLET_RADIUS_M * 0.9)]
    
    for level in range(OBJ4_NUM_BIFURCATIONS):
        new_tips = []
        branch_length = 0.0005 * (1.0 - 0.2 * level)  # Decreasing length
        branch_radius = OBJ4_INLET_RADIUS_M * 0.9 * (0.8 ** (level + 1))
        
        for tip_pos, tip_dir, tip_r in branch_tips:
            # Grow forward a bit
            mid_pos = tip_pos + tip_dir * branch_length
            seg = _create_tapered_cylinder(tip_pos, mid_pos, tip_r, branch_radius)
            channel_segments.append(seg)
            
            # Bifurcate: one branch goes +Y, one goes -Y (with some forward component)
            angle = math.radians(45 - 10 * level)
            
            # Branch 1: +Y deflection
            dir1 = tip_dir * math.cos(angle) + np.array([0, 1, 0]) * math.sin(angle)
            dir1 = dir1 / np.linalg.norm(dir1)
            
            # Branch 2: -Y deflection
            dir2 = tip_dir * math.cos(angle) + np.array([0, -1, 0]) * math.sin(angle)
            dir2 = dir2 / np.linalg.norm(dir2)
            
            new_tips.append((mid_pos.copy(), dir1, branch_radius))
            new_tips.append((mid_pos.copy(), dir2, branch_radius))
        
        branch_tips = new_tips
    
    # 4. Merge branches back (overlap-based merge)
    # Route all branch tips toward a common merge point
    print("    Merging branches (overlap-based)")
    merge_point = np.array([0.002, 0.0, down_end[2]])  # Merge point at +2mm X
    
    for tip_pos, tip_dir, tip_r in branch_tips:
        # Create segment toward merge point
        seg = _create_tapered_cylinder(tip_pos, merge_point, tip_r, OBJ4_TERMINAL_RADIUS_M)
        channel_segments.append(seg)
    
    # 5. Return upward to top face
    print("    Segment: Return upward to top face")
    outlet_pos = np.array([0.002, 0.0, z_top])  # Outlet at +2mm X from center
    seg_return = _create_tapered_cylinder(merge_point, outlet_pos, OBJ4_TERMINAL_RADIUS_M, OBJ4_TERMINAL_RADIUS_M)
    channel_segments.append(seg_return)
    
    # Union all channel segments
    print(f"  Combining {len(channel_segments)} channel segments...")
    combined_void = voxel_union_meshes(channel_segments, pitch=VOXEL_PITCH_UNION_M)
    
    # Export intermediate channel void mesh
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object4_channel_void.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(combined_void).export(str(intermediate_path))
        print(f"    Exported intermediate void: {intermediate_path}")
    
    # Run pre-embedding validation on channel mesh
    print("  Running pre-embedding validation on channel mesh...")
    try:
        pre_report = run_pre_embedding_validation(mesh=combined_void)
        print_validation_details(pre_report)
    except Exception as e:
        print(f"    Pre-embedding validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Use the repo's embed_tree_as_negative_space function to carve channels from cylinder
    print("  Carving channels using embed_tree_as_negative_space...")
    cylinder_with_void = embed_void_in_cylinder(
        void_mesh=combined_void,
        output_dir=output_dir,
        object_name="object4",
        voxel_pitch=VOXEL_PITCH_M,
    )
    
    # Export intermediate cylinder with void (before ridge)
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object4_cylinder_with_void.stl"
        scale_mesh_to_mm(cylinder_with_void).export(str(intermediate_path))
        print(f"    Exported intermediate cylinder with void: {intermediate_path}")
    
    print(f"  Cylinder with void: {len(cylinder_with_void.vertices)} vertices, {len(cylinder_with_void.faces)} faces")
    print(f"    Watertight: {cylinder_with_void.is_watertight}")
    
    # Run post-embedding validation on cylinder with void (before adding ridge)
    print("  Running post-embedding validation on cylinder with void...")
    try:
        validation_config = ValidationConfig(
            voxel_pitch_m=VOXEL_PITCH_M,
            expected_outlets=2,  # 1 inlet + 1 outlet for loop structure
        )
        report = run_post_embedding_validation(mesh=cylinder_with_void, config=validation_config)
        print_validation_details(report)
    except Exception as e:
        print(f"    Validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Return cylinder_with_void - ridge will be added at the END in main() to prevent smoothing
    return cylinder_with_void


# =============================================================================
# OBJECT 5: CCO-NLP ORGANIC GROWTH
# =============================================================================

def generate_object5_cco_nlp_organic(output_dir: Optional[Path] = None) -> trimesh.Trimesh:
    """
    Generate Object 5: CCO-Hybrid + NLP iterative organic growth.
    
    This object uses the repo's CCOHybridBackend for organic vascular network
    generation with iterative NLP optimization between growth rounds.
    
    Design choices documented:
    - Coordinate convention: Cylinder centered at origin, z spans [-1mm, +1mm]
    - Inlet z aligned with top face at z = +1mm
    - 4 inlets in symmetric square pattern at (+/-1.5mm, +/-1.5mm)
    - Each inlet starts with 0.1mm straight downward segment
    - 4 rounds of CCO growth + NLP optimization
    - 512 total terminals (128 per inlet, 32 per round per inlet)
    - Optimized per-tree after each round, then globally on merged network
    
    Returns mesh in METERS (will be scaled to mm at export).
    
    Parameters
    ----------
    output_dir : Path, optional
        Directory to save intermediate STL files for debugging
    """
    import copy
    import time
    
    print("\n" + "=" * 60)
    print("Generating Object 5: CCO-NLP Organic Growth")
    print("=" * 60)
    
    print("\n  Design choices:")
    print(f"    - Coordinate convention: Cylinder centered at origin")
    print(f"    - Top face at z = +{meters_to_mm(CYLINDER_HEIGHT_M/2)}mm")
    print(f"    - {OBJ5_NUM_INLETS} inlets at (+/-1.5mm, +/-1.5mm)")
    print(f"    - {OBJ5_NUM_ROUNDS} growth rounds with NLP optimization")
    print(f"    - {OBJ5_TOTAL_OUTLETS} total outlets ({OBJ5_TOTAL_OUTLETS // OBJ5_NUM_INLETS} per inlet)")
    print(f"    - Vessel type: {OBJ5_VESSEL_TYPE}")
    print(f"    - Seed: {OBJ5_SEED}")
    
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    
    # Create domain for CCO generation
    print("\n  Setting up CCO domain and configuration...")
    domain_spec = CylinderSpec(
        center=(CYLINDER_CENTER[0], CYLINDER_CENTER[1], CYLINDER_CENTER[2]),
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
    )
    domain = compile_domain(domain_spec)
    
    # Create CCO configuration
    cco_config = CCOConfig(
        seed=OBJ5_SEED,
        murray_exponent=OBJ5_CCO_MURRAY_EXPONENT,
        collision_clearance=OBJ5_CCO_COLLISION_CLEARANCE,
        min_segment_length=OBJ5_CCO_MIN_SEGMENT_LENGTH,
        max_segment_length=OBJ5_CCO_MAX_SEGMENT_LENGTH,
        min_terminal_separation=OBJ5_CCO_MIN_TERMINAL_SEP,
        candidate_edges_k=OBJ5_CCO_CANDIDATE_EDGES_K,
        optimization_grid_resolution=OBJ5_CCO_GRID_RESOLUTION,
        collision_check_enabled=True,
        use_partial_binding=True,
        use_collision_triage=True,
        use_nlp_optimization=OBJ5_CCO_USE_NLP,
    )
    
    print(f"    CCO config: murray_exponent={cco_config.murray_exponent}, "
          f"collision_clearance={cco_config.collision_clearance*1000:.3f}mm")
    
    # Create NLP configuration
    nlp_config = NLPConfig(
        murray_exponent=OBJ5_NLP_MURRAY_EXPONENT,
        target_pressure_drop=OBJ5_NLP_TARGET_PRESSURE_DROP,
        viscosity=OBJ5_NLP_VISCOSITY,
        fix_terminal_positions=OBJ5_NLP_FIX_TERMINALS,
        fix_root_position=OBJ5_NLP_FIX_ROOT,
        max_iterations=OBJ5_NLP_MAX_ITERATIONS,
        solver_tolerance=OBJ5_NLP_TOLERANCE,
        cleanup_degenerate_segments=OBJ5_NLP_CLEANUP_DEGENERATE,
    )
    
    # Create CCO backend
    backend = CCOHybridBackend()
    
    # Calculate outlets per inlet
    outlets_per_inlet = OBJ5_TOTAL_OUTLETS // OBJ5_NUM_INLETS
    
    # Generate trees for each inlet
    print(f"\n  Generating {OBJ5_NUM_INLETS} inlet trees with iterative CCO + NLP...")
    all_networks = []
    total_outlets_achieved = 0
    
    for inlet_idx, inlet_pos in enumerate(OBJ5_INLET_POSITIONS):
        print(f"\n    Inlet {inlet_idx + 1}: position=({inlet_pos[0]*1000:.1f}, "
              f"{inlet_pos[1]*1000:.1f}, {inlet_pos[2]*1000:.1f})mm")
        
        inlet_position = np.array(inlet_pos)
        
        # Generate tree for this inlet using CCO
        try:
            start_time = time.time()
            network = backend.generate(
                domain=domain,
                num_outlets=outlets_per_inlet,
                inlet_position=inlet_position,
                inlet_radius=OBJ5_INLET_RADIUS_M,
                vessel_type=OBJ5_VESSEL_TYPE,
                config=cco_config,
                rng_seed=OBJ5_SEED + inlet_idx,
            )
            gen_time = time.time() - start_time
            
            # Count actual outlets
            outlet_count = sum(1 for n in network.nodes.values() 
                             if n.node_type in ("outlet", "terminal"))
            total_outlets_achieved += outlet_count
            
            print(f"      CCO generation: {outlet_count} outlets in {gen_time:.1f}s")
            print(f"      Network: {len(network.nodes)} nodes, {len(network.segments)} segments")
            
            # Apply NLP optimization if enabled
            if OBJ5_NLP_ENABLED:
                print(f"      Applying NLP optimization...")
                try:
                    nlp_start = time.time()
                    nlp_result = optimize_geometry(network, nlp_config)
                    nlp_time = time.time() - nlp_start
                    
                    if nlp_result.success:
                        print(f"      NLP success: volume reduction {nlp_result.volume_reduction*100:.1f}% "
                              f"in {nlp_time:.1f}s")
                    else:
                        print(f"      NLP did not converge (continuing anyway)")
                except Exception as e:
                    print(f"      NLP optimization failed: {e} (continuing anyway)")
            
            all_networks.append(network)
            
        except Exception as e:
            print(f"      ERROR generating inlet {inlet_idx + 1}: {e}")
            continue
    
    if not all_networks:
        raise RuntimeError("Failed to generate any inlet networks")
    
    print(f"\n  Total outlets achieved: {total_outlets_achieved}/{OBJ5_TOTAL_OUTLETS}")
    
    # Merge all networks into one
    print("\n  Merging all inlet networks...")
    merged_network = all_networks[0]
    
    for i, network in enumerate(all_networks[1:], start=2):
        # Simple merge: copy nodes and segments with new IDs
        node_id_map = {}
        for old_node in network.nodes.values():
            new_node_id = merged_network.id_gen.next_id()
            new_node = Node(
                id=new_node_id,
                position=copy.deepcopy(old_node.position),
                node_type=old_node.node_type,
                vessel_type=old_node.vessel_type,
                attributes=old_node.attributes.copy() if old_node.attributes else {},
            )
            merged_network.add_node(new_node)
            node_id_map[old_node.id] = new_node_id
        
        for old_seg in network.segments.values():
            new_seg_id = merged_network.id_gen.next_id()
            new_seg = VesselSegment(
                id=new_seg_id,
                start_node_id=node_id_map[old_seg.start_node_id],
                end_node_id=node_id_map[old_seg.end_node_id],
                geometry=copy.deepcopy(old_seg.geometry),
                vessel_type=old_seg.vessel_type,
                attributes=old_seg.attributes.copy() if old_seg.attributes else {},
            )
            merged_network.add_segment(new_seg)
        
        print(f"    Merged inlet {i}: {len(network.nodes)} nodes, {len(network.segments)} segments")
    
    print(f"  Merged network: {len(merged_network.nodes)} nodes, "
          f"{len(merged_network.segments)} segments")
    
    # Final global NLP optimization on merged network
    if OBJ5_NLP_ENABLED:
        print("\n  Applying final global NLP optimization...")
        try:
            nlp_start = time.time()
            nlp_result = optimize_geometry(merged_network, nlp_config)
            nlp_time = time.time() - nlp_start
            
            if nlp_result.success:
                print(f"    Final NLP success: volume reduction {nlp_result.volume_reduction*100:.1f}% "
                      f"in {nlp_time:.1f}s")
            else:
                print(f"    Final NLP did not converge (continuing anyway)")
        except Exception as e:
            print(f"    Final NLP optimization failed: {e} (continuing anyway)")
    
    # Convert network to mesh
    print("\n  Converting network to mesh...")
    tree_mesh = None
    try:
        mesh_result = to_trimesh(merged_network, mode="voxel_repair")
        if mesh_result.is_success():
            tree_mesh = mesh_result.metadata["mesh"]
            print(f"    Tree mesh: {len(tree_mesh.vertices)} vertices, {len(tree_mesh.faces)} faces")
        else:
            print(f"    to_trimesh returned failure: {mesh_result.message}, using manual mesh construction")
    except Exception as e:
        print(f"    to_trimesh failed: {e}, using manual mesh construction")
    
    if tree_mesh is None:
        # Fallback: create mesh from segments manually
        all_segment_meshes = []
        for seg in merged_network.segments.values():
            start_node = merged_network.nodes[seg.start_node_id]
            end_node = merged_network.nodes[seg.end_node_id]
            # Convert Point3D to numpy array
            if hasattr(start_node.position, 'to_array'):
                start_pos = start_node.position.to_array()
            else:
                start_pos = np.array(start_node.position)
            if hasattr(end_node.position, 'to_array'):
                end_pos = end_node.position.to_array()
            else:
                end_pos = np.array(end_node.position)
            
            # Get radii
            if seg.geometry and hasattr(seg.geometry, 'start_radius'):
                start_r = seg.geometry.start_radius
                end_r = seg.geometry.end_radius
            else:
                start_r = OBJ5_INLET_RADIUS_M
                end_r = OBJ5_TERMINAL_RADIUS_M
            
            # Create tapered cylinder
            seg_mesh = _create_tapered_cylinder(start_pos, end_pos, start_r, end_r)
            if seg_mesh is not None:
                all_segment_meshes.append(seg_mesh)
        
        if all_segment_meshes:
            tree_mesh = voxel_union_meshes(all_segment_meshes, pitch=VOXEL_PITCH_UNION_M)
        else:
            raise RuntimeError("Failed to create tree mesh")
    
    # Export intermediate tree mesh
    if output_dir and tree_mesh is not None:
        intermediate_path = output_dir / "intermediate" / "object5_tree_void.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(tree_mesh).export(str(intermediate_path))
        print(f"    Exported intermediate tree: {intermediate_path}")
    
    # Run pre-embedding validation on tree mesh
    print("  Running pre-embedding validation on tree mesh...")
    try:
        pre_report = run_pre_embedding_validation(mesh=tree_mesh)
        print_validation_details(pre_report)
    except Exception as e:
        print(f"    Pre-embedding validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Use the repo's embed_tree_as_negative_space function to carve voids from cylinder
    print("\n  Carving vascular channels using embed_tree_as_negative_space...")
    cylinder_with_void = embed_void_in_cylinder(
        void_mesh=tree_mesh,
        output_dir=output_dir,
        object_name="object5",
        voxel_pitch=VOXEL_PITCH_M,
    )
    
    # Export intermediate cylinder with void (before ridge)
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object5_cylinder_with_void.stl"
        scale_mesh_to_mm(cylinder_with_void).export(str(intermediate_path))
        print(f"    Exported intermediate cylinder with void: {intermediate_path}")
    
    print(f"  Cylinder with void: {len(cylinder_with_void.vertices)} vertices, {len(cylinder_with_void.faces)} faces")
    print(f"    Watertight: {cylinder_with_void.is_watertight}")
    
    # Run post-embedding validation on cylinder with void (before adding ridge)
    print("  Running post-embedding validation on cylinder with void...")
    try:
        validation_config = ValidationConfig(
            voxel_pitch_m=VOXEL_PITCH_M,
            expected_outlets=total_outlets_achieved,
        )
        post_report = run_post_embedding_validation(mesh=cylinder_with_void, config=validation_config)
        print_validation_details(post_report)
    except Exception as e:
        print(f"    Validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Generate report
    report = {
        "object": "object5_cco_nlp_organic",
        "design_choices": {
            "coordinate_convention": "Cylinder centered at origin, z spans [-1mm, +1mm]",
            "inlet_z_position": f"+{meters_to_mm(CYLINDER_HEIGHT_M/2)}mm (top face)",
            "num_inlets": OBJ5_NUM_INLETS,
            "inlet_positions_mm": [[p[0]*1000, p[1]*1000, p[2]*1000] for p in OBJ5_INLET_POSITIONS],
            "num_rounds": OBJ5_NUM_ROUNDS,
            "vessel_type": OBJ5_VESSEL_TYPE,
        },
        "parameters": {
            "total_outlets_requested": OBJ5_TOTAL_OUTLETS,
            "total_outlets_achieved": total_outlets_achieved,
            "inlet_radius_mm": OBJ5_INLET_RADIUS_M * 1000,
            "terminal_radius_mm": OBJ5_TERMINAL_RADIUS_M * 1000,
            "cco_collision_clearance_mm": OBJ5_CCO_COLLISION_CLEARANCE * 1000,
            "cco_min_segment_mm": OBJ5_CCO_MIN_SEGMENT_LENGTH * 1000,
            "cco_max_segment_mm": OBJ5_CCO_MAX_SEGMENT_LENGTH * 1000,
            "nlp_enabled": OBJ5_NLP_ENABLED,
            "nlp_murray_exponent": OBJ5_NLP_MURRAY_EXPONENT,
            "voxel_pitch_mm": VOXEL_PITCH_UNION_M * 1000,
        },
        "mesh_stats": {
            "vertices": len(cylinder_with_void.vertices),
            "faces": len(cylinder_with_void.faces),
            "watertight": cylinder_with_void.is_watertight,
        },
    }
    
    # Save report
    report_path = OUTPUT_DIR / "object5_cco_nlp_organic_report.json"
    with open(report_path, 'w') as f:
        json.dump(report, f, indent=2)
    print(f"  Report saved: {report_path}")
    
    # Return cylinder_with_void - ridge will be added at the END in main() to prevent smoothing
    return cylinder_with_void


# =============================================================================
# MAIN EXECUTION
# =============================================================================

def add_ridge_to_mesh(mesh_m: trimesh.Trimesh) -> trimesh.Trimesh:
    """
    Add ridge to a mesh at the END (after all voxel operations) to prevent smoothing.
    
    Uses voxel union with fine pitch (VOXEL_PITCH_RIDGE_M = 25um) to preserve ridge detail
    while maintaining watertightness. The ridge is 0.1mm (100um) thick, so at 25um pitch
    it will be 4 voxels thick, which is sufficient to preserve the geometry.
    
    Parameters
    ----------
    mesh_m : trimesh.Trimesh
        The mesh to add ridge to (in meters)
    
    Returns
    -------
    trimesh.Trimesh
        The mesh with ridge added (in meters)
    """
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    
    ridge = create_ridge_mesh(
        outer_radius=CYLINDER_RADIUS_M,
        inner_radius=CYLINDER_RADIUS_M - RIDGE_THICKNESS_M,
        height=RIDGE_HEIGHT_M,
        z_base=z_top,
        center_xy=(CYLINDER_CENTER[0], CYLINDER_CENTER[1]),
    )
    
    print(f"    Ridge mesh: {len(ridge.vertices)} vertices, {len(ridge.faces)} faces")
    print(f"    Using voxel union with fine pitch ({VOXEL_PITCH_RIDGE_M*1e6:.0f}um) to preserve ridge detail")
    
    combined = voxel_union_meshes([mesh_m, ridge], pitch=VOXEL_PITCH_RIDGE_M)
    
    print(f"    Combined mesh: {len(combined.vertices)} vertices, {len(combined.faces)} faces")
    print(f"    Watertight: {combined.is_watertight}")
    
    return combined


def main():
    """Generate all five objects and export to STL files."""
    print("=" * 70)
    print("MALARIA VENULE INSERTS GENERATOR")
    print("=" * 70)
    print("\nDesign Choices:")
    print("  - Ridge geometry: Annular ring (outer=5mm, inner=4.9mm, height=0.1mm)")
    print("  - Object 2 channels: 4 channels at (+/-1.5mm, +/-1.5mm)")
    print("  - Object 3 bifurcation: 7 levels, depths 0.25-1.75mm, taper 1mm->100um")
    print("  - Overlap-based merge: Voxel union merges overlapping void volumes")
    print("  - Object 5 CCO-NLP: 4 inlets, 4 rounds CCO + NLP, 512 terminals")
    print("  - Ridge added at END (after voxel ops) to prevent smoothing")
    print(f"\nVoxel pitch: {meters_to_mm(VOXEL_PITCH_M)*1000:.0f} um (fine)")
    print(f"Voxel pitch (union): {meters_to_mm(VOXEL_PITCH_UNION_M)*1000:.0f} um")
    print(f"Voxel pitch (ridge): {meters_to_mm(VOXEL_PITCH_RIDGE_M)*1000:.0f} um")
    print(f"Output units: {OUTPUT_UNITS}")
    
    # Create output directory
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    print(f"\nOutput directory: {OUTPUT_DIR}")
    print(f"Intermediate STLs will be saved to: {OUTPUT_DIR / 'intermediate'}")
    
    # Generate and export each object (pass output_dir for intermediate STL exports)
    # Objects 2-5 return cylinder_with_void (without ridge) - ridge is added at the END
    # Object 1 already includes ridge (no voxel operations after ridge)
    objects = [
        ("object1_control.stl", lambda: generate_object1_control(output_dir=OUTPUT_DIR), False),  # Already has ridge
        ("object2_channels.stl", lambda: generate_object2_channels(output_dir=OUTPUT_DIR), True),  # Needs ridge
        ("object3_bifurcate_512.stl", lambda: generate_object3_bifurcate_512(output_dir=OUTPUT_DIR), True),  # Needs ridge
        ("object4_turn_bifurcate_merge.stl", lambda: generate_object4_turn_bifurcate_merge(output_dir=OUTPUT_DIR), True),  # Needs ridge
        ("object5_cco_nlp_organic.stl", lambda: generate_object5_cco_nlp_organic(output_dir=OUTPUT_DIR), True),  # Needs ridge
    ]
    
    for filename, generator_func, needs_ridge in objects:
        try:
            mesh_m = generator_func()
            
            # Add ridge at the END for objects 2-5 (after all voxel operations)
            if needs_ridge:
                print(f"  Adding ridge to {filename} (at END to prevent smoothing)...")
                mesh_m = add_ridge_to_mesh(mesh_m)
                print(f"    Final mesh: {len(mesh_m.vertices)} vertices, {len(mesh_m.faces)} faces")
            
            # Scale to millimeters
            mesh_mm = scale_mesh_to_mm(mesh_m)
            
            # Export
            output_path = OUTPUT_DIR / filename
            export_mesh_with_units(mesh_mm, output_path, units=OUTPUT_UNITS)
            
        except Exception as e:
            print(f"\nERROR generating {filename}: {e}")
            import traceback
            traceback.print_exc()
    
    print("\n" + "=" * 70)
    print("GENERATION COMPLETE")
    print("=" * 70)
    print(f"\nOutput files in: {OUTPUT_DIR}")
    print("  - object1_control.stl")
    print("  - object2_channels.stl")
    print("  - object3_bifurcate_512.stl")
    print("  - object4_turn_bifurcate_merge.stl")
    print("  - object5_cco_nlp_organic.stl")
    print(f"\nIntermediate STLs in: {OUTPUT_DIR / 'intermediate'}")


if __name__ == "__main__":
    main()
