#!/usr/bin/env python3
"""
Malaria Venule Inserts Generator

This module generates five STL files for malaria venule insert scaffolds:
1. Object 1 (Control): Solid cylinder with ridge, no internal voids
2. Object 2 (Control + Channels): Control with 4 straight channels
3. Object 3 (Bifurcation 512): 4 inlets with recursive bifurcation to 512 terminals
4. Object 4 (Turn-Bifurcate-Merge): Single inlet with 90-degree turn, bifurcation, merge, return
5. Object 5 (CCO-NLP Organic): 4 inlets with CCO hybrid growth + NLP iterative optimization

DESIGN CHOICES DOCUMENTED:
- Ridge geometry: Annular ring on perimeter (outer_radius=5mm, inner_radius=4.9mm)
  Fallback: Solid raised disk if ring creation fails
- Object 2 channel count: 4 channels (minimum specified)
- Object 2 channel placement: Square pattern at (+/-1.5mm, +/-1.5mm) from center
- Object 3 bifurcation depths: 0.25, 0.50, 0.75, 1.00, 1.25, 1.50, 1.75 mm from top
- Object 3 branch taper: Exponential from 1mm to 100um over 7 levels
- Overlap-based merge strategy: Voxel union merges overlapping void volumes
- Object 5 CCO-NLP: 4 rounds of CCO growth + NLP optimization, 512 total terminals
  - Coordinate convention: Cylinder centered at origin, z spans [-1mm, +1mm]
  - Inlet z aligned with top face at z = +1mm
  - Optimized per-tree after each round, then globally on merged network

UNITS:
- Internal computations: METERS
- Output STL files: MILLIMETERS (scaled at export)

Author: Generated by Agentic Organ Generation System
"""

import sys
import os
import math
from math import sqrt, cos, sin, radians, pi  # Explicit imports to avoid shadowing issues
import json
import numpy as np
import trimesh
from pathlib import Path
from typing import List, Tuple, Optional, Dict, Any
from dataclasses import dataclass

# Add parent directory to path for imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from generation.core.domain import CylinderDomain
from generation.core.types import Point3D, Direction3D, TubeGeometry
from generation.core.network import VascularNetwork, Node, VesselSegment
from generation.ops.build import create_network, add_inlet
from generation.ops.growth import grow_branch, grow_to_point
from generation.adapters.mesh_adapter import to_trimesh, export_stl
from generation.ops.embedding import embed_tree_as_negative_space
from generation.rules.constraints import BranchingConstraints

# Additional imports for Object 5 (CCO-NLP)
from generation.specs.design_spec import DesignSpec, CylinderSpec, TreeSpec, InletSpec
from generation.specs.compile import compile_domain
from generation.backends.cco_hybrid_backend import CCOHybridBackend, CCOConfig
from generation.optimization import optimize_geometry, NLPConfig

# Validity checking imports
from validity import run_pre_embedding_validation, run_post_embedding_validation, ValidationConfig


# =============================================================================
# HARDCODED PARAMETERS - All dimensions in METERS internally
# =============================================================================

# --- Base Cylinder Parameters (shared by all objects) ---
CYLINDER_RADIUS_M = 0.005          # 5 mm radius = 10 mm diameter
CYLINDER_HEIGHT_M = 0.002          # 2 mm height
CYLINDER_CENTER = (0.0, 0.0, 0.0)  # Centered at origin

# --- Ridge Parameters (shared by all objects) ---
RIDGE_HEIGHT_M = 0.0001            # 0.1 mm ridge height
RIDGE_THICKNESS_M = 0.0001         # 0.1 mm ridge thickness (annular ring width)
# Ridge interpretation: Annular ring on perimeter
# - Outer radius = CYLINDER_RADIUS_M (5.0 mm)
# - Inner radius = CYLINDER_RADIUS_M - RIDGE_THICKNESS_M (4.9 mm)
# - Z range = [+1.0 mm, +1.1 mm] (top of cylinder to top of ridge)
# IMPORTANT: For voxel union to work correctly, the ridge must OVERLAP with the
# cylinder (not just touch). We extend the ridge slightly INTO the cylinder.
RIDGE_OVERLAP_M = 0.00005          # 0.05 mm overlap into cylinder for voxel union

# --- Derived Parameters ---
RIDGE_INNER_RADIUS_M = CYLINDER_RADIUS_M - RIDGE_THICKNESS_M  # 4.9 mm
TOP_FACE_Z_M = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2     # +1.0 mm


# =============================================================================
# HELPER FUNCTIONS FOR PARAMETER INFERENCE
# =============================================================================

def compute_inlet_positions(
    num_inlets: int,
    inlet_radius: float,
    cylinder_radius: float = CYLINDER_RADIUS_M,
    ridge_inner_radius: float = RIDGE_INNER_RADIUS_M,
    wall_margin: float = 0.0005,  # 0.5 mm default wall margin (same as OBJ2_WALL_MARGIN_M)
    include_z: bool = False,
    z_position: float = None,
) -> List[Tuple[float, ...]]:
    """
    Compute inlet positions based on geometry parameters.
    
    Inlets are placed in a symmetric pattern inside the ridge, leaving enough
    margin from the ridge inner edge and between adjacent inlets.
    
    Parameters
    ----------
    num_inlets : int
        Number of inlets to place
    inlet_radius : float
        Radius of each inlet (in meters)
    cylinder_radius : float
        Radius of the cylinder (in meters)
    ridge_inner_radius : float
        Inner radius of the ridge (in meters)
    wall_margin : float
        Minimum margin from ridge inner edge (in meters)
    include_z : bool
        If True, return 3D positions (x, y, z); if False, return 2D (x, y)
    z_position : float
        Z coordinate for 3D positions (required if include_z=True)
    
    Returns
    -------
    List of tuples with inlet positions
    """
    if num_inlets == 0:
        return []
    
    # Maximum radius for inlet center placement
    # Must stay inside ridge inner edge with margin for inlet radius
    max_placement_radius = ridge_inner_radius - inlet_radius - wall_margin
    
    if num_inlets == 1:
        # Single inlet at center
        positions = [(0.0, 0.0)]
    elif num_inlets == 2:
        # Two inlets along X axis
        offset = max_placement_radius * INLET_PLACEMENT_FRACTION  # 70% of max radius
        positions = [(offset, 0.0), (-offset, 0.0)]
    elif num_inlets == 3:
        # Three inlets in equilateral triangle
        offset = max_placement_radius * INLET_PLACEMENT_FRACTION
        positions = [
            (0.0, offset),
            (offset * cos(radians(210)), offset * sin(radians(210))),
            (offset * cos(radians(330)), offset * sin(radians(330))),
        ]
    elif num_inlets == 4:
        # Four inlets in square pattern
        # For a square inscribed in a circle of radius r, the offset from center is r/sqrt(2)
        offset = max_placement_radius / sqrt(2)
        positions = [
            (offset, offset),
            (-offset, offset),
            (-offset, -offset),
            (offset, -offset),
        ]
    else:
        # N inlets in circular pattern
        offset = max_placement_radius * INLET_PLACEMENT_FRACTION
        positions = []
        for i in range(num_inlets):
            angle = 2 * pi * i / num_inlets
            x = offset * cos(angle)
            y = offset * sin(angle)
            positions.append((x, y))
    
    # Add Z coordinate if requested
    if include_z:
        if z_position is None:
            z_position = TOP_FACE_Z_M
        positions = [(x, y, z_position) for x, y in positions]
    
    return positions


def compute_bifurcation_depths(
    num_bifurcations: int,
    cylinder_height: float = CYLINDER_HEIGHT_M,
    top_margin_fraction: float = 0.0,
    bottom_margin_fraction: float = 0.125,
) -> List[float]:
    """
    Compute bifurcation depths based on number of bifurcations and object height.
    
    Depths are evenly spaced from near the top to near the bottom of the cylinder.
    
    Parameters
    ----------
    num_bifurcations : int
        Number of bifurcation levels
    cylinder_height : float
        Height of the cylinder (in meters)
    top_margin_fraction : float
        Fraction of height to leave as margin at top (default 0)
    bottom_margin_fraction : float
        Fraction of height to leave as margin at bottom (default 0.125 = 1/8)
    
    Returns
    -------
    List of depths (in meters) from the top face
    """
    if num_bifurcations == 0:
        return []
    
    # Usable height for bifurcations
    usable_height = cylinder_height * (1 - top_margin_fraction - bottom_margin_fraction)
    start_depth = cylinder_height * top_margin_fraction
    
    # Evenly space bifurcations
    # depth[i] = start_depth + (i + 1) / (num_bifurcations + 1) * usable_height
    depths = []
    for i in range(num_bifurcations):
        depth = start_depth + (i + 1) / (num_bifurcations + 1) * usable_height
        depths.append(depth)
    
    return depths

# =============================================================================
# OBJECT 1: Control (solid cylinder + ridge, no channels)
# =============================================================================
# Object 1 has no inlets or terminals - it's a solid control sample
OBJ1_NUM_INLETS = 0                # No inlets (solid control)
OBJ1_INLET_RADIUS_M = None         # N/A for solid control
OBJ1_TERMINAL_RADIUS_M = None      # N/A for solid control

# =============================================================================
# OBJECT 2: Straight Channels
# =============================================================================
OBJ2_NUM_INLETS = 4                # 4 straight channels (range 4-9, using minimum)
OBJ2_INLET_RADIUS_M = 0.001        # 1 mm channel/inlet radius
OBJ2_TERMINAL_RADIUS_M = 0.001     # 1 mm (same as inlet - no taper for straight channels)
OBJ2_CHANNEL_DEPTH_M = 0.001       # 1 mm channel depth (extends downward from top)
OBJ2_WALL_MARGIN_M = 0.0005        # 0.5 mm minimum wall margin from cylinder edge
# Inlet positions for Object 2 - INFERRED from geometry
OBJ2_INLET_POSITIONS = compute_inlet_positions(
    num_inlets=OBJ2_NUM_INLETS,
    inlet_radius=OBJ2_INLET_RADIUS_M,
    wall_margin=OBJ2_WALL_MARGIN_M,
)

# =============================================================================
# OBJECT 3: Recursive Bifurcation (512 terminals)
# =============================================================================
OBJ3_NUM_INLETS = 4                # 4 inlet channels
OBJ3_INLET_RADIUS_M = 0.001        # 1 mm inlet radius
OBJ3_TERMINAL_RADIUS_M = 0.0001    # 100 um terminal radius
OBJ3_TOTAL_TERMINALS = 512         # Total terminal count
OBJ3_TERMINALS_PER_INLET = 128     # 512 / 4 = 128 terminals per inlet
OBJ3_BIFURCATION_LEVELS = 7        # 2^7 = 128 terminals per inlet
OBJ3_WALL_MARGIN_M = 0.0005        # 0.5 mm minimum wall margin from cylinder edge
# Bifurcation depth schedule - INFERRED from number of bifurcations and object height
OBJ3_BIFURCATION_DEPTHS_M = compute_bifurcation_depths(
    num_bifurcations=OBJ3_BIFURCATION_LEVELS,
    cylinder_height=CYLINDER_HEIGHT_M,
)
# Inlet positions for Object 3 - INFERRED from geometry
OBJ3_INLET_POSITIONS = compute_inlet_positions(
    num_inlets=OBJ3_NUM_INLETS,
    inlet_radius=OBJ3_INLET_RADIUS_M,
    wall_margin=OBJ3_WALL_MARGIN_M,
)

# =============================================================================
# OBJECT 4: Turn-Bifurcate-Merge Loop
# =============================================================================
OBJ4_NUM_INLETS = 1                # Single inlet for loop structure
OBJ4_INLET_RADIUS_M = 0.001        # 1 mm inlet radius
OBJ4_TERMINAL_RADIUS_M = 0.0005    # 500 um terminal radius (before merge back)
OBJ4_DOWNWARD_LENGTH_M = 0.001     # 1 mm downward travel before turn
OBJ4_HORIZONTAL_LENGTH_M = 0.001   # 1 mm horizontal travel after turn
OBJ4_NUM_BIFURCATIONS = 3          # Number of bifurcation levels in lateral plane
OBJ4_MERGE_OVERLAP_M = 0.0005      # 0.5 mm overlap for merge region
OBJ4_WALL_MARGIN_M = 0.0005        # 0.5 mm minimum wall margin from cylinder edge
# Inlet position for Object 4 - INFERRED from geometry (single inlet at center)
_obj4_positions = compute_inlet_positions(
    num_inlets=OBJ4_NUM_INLETS,
    inlet_radius=OBJ4_INLET_RADIUS_M,
    wall_margin=OBJ4_WALL_MARGIN_M,
)
OBJ4_INLET_POSITION = _obj4_positions[0] if _obj4_positions else (0.0, 0.0)

# =============================================================================
# OBJECT 5: CCO-NLP Organic Growth
# =============================================================================
# Coordinate convention: Cylinder centered at origin, z spans [-1mm, +1mm]
# Top face at z = +1mm = +0.001m
OBJ5_NUM_INLETS = 4                # 4 inlet channels
OBJ5_INLET_RADIUS_M = 0.001        # 1 mm inlet radius
OBJ5_TERMINAL_RADIUS_M = 0.0001    # 100 um terminal radius (minimum)
OBJ5_TOTAL_OUTLETS = 512           # Total terminal outlets (128 per inlet)
OBJ5_NUM_ROUNDS = 4                # Number of CCO growth rounds
OBJ5_OUTLETS_PER_ROUND = 32        # 512 / 4 inlets / 4 rounds = 32 per round per inlet
OBJ5_STRAIGHT_DOWN_M = 0.0001      # 0.1 mm straight down before CCO growth
OBJ5_VESSEL_TYPE = "venous"        # Vessel type for inserts
OBJ5_SEED = 42                     # Random seed for reproducibility
OBJ5_WALL_MARGIN_M = 0.0005        # 0.5 mm minimum wall margin from cylinder edge
# Inlet positions for Object 5 - INFERRED from geometry (with Z coordinate at top face)
OBJ5_INLET_POSITIONS = compute_inlet_positions(
    num_inlets=OBJ5_NUM_INLETS,
    inlet_radius=OBJ5_INLET_RADIUS_M,
    wall_margin=OBJ5_WALL_MARGIN_M,
    include_z=True,
    z_position=TOP_FACE_Z_M,
)
# CCO configuration parameters (tuned for tiny domain)
OBJ5_CCO_COLLISION_CLEARANCE = 5e-5    # 50 um collision clearance
OBJ5_CCO_MIN_SEGMENT_LENGTH = 2e-4     # 200 um minimum segment
OBJ5_CCO_MAX_SEGMENT_LENGTH = 2e-3     # 2 mm maximum segment (within 2mm height)
OBJ5_CCO_MIN_TERMINAL_SEP = 5e-5       # 50 um between terminals
OBJ5_CCO_CANDIDATE_EDGES_K = 50        # Candidate edges for optimization
OBJ5_CCO_GRID_RESOLUTION = 10          # Grid resolution for bifurcation optimization
OBJ5_CCO_USE_NLP = True                # Enable NLP-based bifurcation optimization
OBJ5_CCO_MURRAY_EXPONENT = 3.0         # Murray's law exponent
# NLP global optimization parameters
OBJ5_NLP_ENABLED = True                # Enable global NLP optimization
OBJ5_NLP_MURRAY_EXPONENT = 3.0         # Murray's law exponent
OBJ5_NLP_TARGET_PRESSURE_DROP = 13332.0  # ~100 mmHg pressure drop
OBJ5_NLP_VISCOSITY = 0.0035            # Blood viscosity (Pa*s)
OBJ5_NLP_FIX_TERMINALS = True          # Fix terminal positions
OBJ5_NLP_FIX_ROOT = True               # Fix inlet positions
OBJ5_NLP_MAX_ITERATIONS = 500          # Max optimization iterations
OBJ5_NLP_TOLERANCE = 1e-5              # Solver tolerance
OBJ5_NLP_CLEANUP_DEGENERATE = True     # Remove degenerate segments

# =============================================================================
# VOXELIZATION PARAMETERS
# =============================================================================
VOXEL_PITCH_M = 2.5e-5             # 25 um voxel pitch (for fine resolution embedding)
VOXEL_PITCH_UNION_M = 5.0e-5       # 50 um voxel pitch (for union operations)
# Note: Ridge is 0.1mm (100um) thick, so we need at least 2 voxels across it
# Using 50um pitch gives 2 voxels across the ridge thickness for proper resolution
# 25 um pitch on 10mm x 10mm x 2mm domain = ~12.8M voxels
VOXEL_PITCH_RIDGE_M = 2.5e-5       # 25 um for ridge operations (4 voxels across 0.1mm ridge)
VOXEL_RETRY_MAX_ATTEMPTS = 4       # Max retry attempts for voxelization
VOXEL_RETRY_FACTOR = 1.5           # Pitch multiplier on retry

# =============================================================================
# MESH RESOLUTION PARAMETERS
# =============================================================================
CYLINDER_MESH_SECTIONS = 64        # Number of sections for cylinder mesh
RIDGE_MESH_POINTS = 65             # Number of points for ridge mesh ring
CHANNEL_MESH_SECTIONS = 32         # Number of sections for channel mesh
TAPERED_CYLINDER_SECTIONS = 16     # Default sections for tapered cylinders

# =============================================================================
# BRANCHING CONSTRAINTS (for VascularNetwork operations)
# =============================================================================
BRANCH_MIN_SEGMENT_LENGTH_M = 1e-5   # Minimum segment length for branching
BRANCH_MAX_SEGMENT_LENGTH_M = 0.01   # Maximum segment length for branching
BRANCH_MIN_RADIUS_M = 1e-5           # Minimum radius for branching

# =============================================================================
# BIFURCATION TREE PARAMETERS (shared by Objects 3 and 4)
# =============================================================================
BIFURC_BOTTOM_MARGIN_FRACTION = 0.125    # 12.5% margin at bottom of cylinder
BIFURC_HORIZONTAL_STEP_M = 0.0002        # Small step for horizontal branches
BIFURC_MIN_SEGMENT_LENGTH_M = 0.0001     # Minimum segment length
BIFURC_MAX_GROWTH_FRACTION = 0.8         # Max growth as fraction of available space (leave 20% for next bifurcation)
BIFURC_MIN_GROWTH_DISTANCE_M = 0.0001    # Minimum growth distance
BIFURC_ANGLE_REDUCTION_PER_LEVEL = 0.1   # Angle reduction factor per bifurcation level
BIFURC_TERMINAL_SEGMENT_LENGTH_M = 0.0001  # Length of terminal segments
BIFURC_DIRECTION_THRESHOLD = 0.1         # Threshold for detecting vertical vs horizontal direction

# =============================================================================
# OBJECT 3 ADDITIONAL PARAMETERS
# =============================================================================
OBJ3_BASE_ANGLE_DEG = 30.0               # Base bifurcation angle in degrees
OBJ3_MIN_CHANNEL_DIAMETER_MM = 0.2       # Minimum channel diameter for validation (mm)
OBJ3_MIN_WALL_THICKNESS_MM = 0.3         # Minimum wall thickness for validation (mm)

# =============================================================================
# OBJECT 4 ADDITIONAL PARAMETERS
# =============================================================================
OBJ4_INLET_OFFSET_M = 0.001              # Offset from center for return path
OBJ4_TURN_RADIUS_FACTOR = 0.9            # Radius reduction factor after turn
OBJ4_BRANCH_BASE_LENGTH_M = 0.0005       # Base branch length for bifurcations
OBJ4_BRANCH_LENGTH_DECAY = 0.2           # Length decay per bifurcation level
OBJ4_BRANCH_RADIUS_DECAY = 0.8           # Radius decay per bifurcation level
OBJ4_BASE_ANGLE_DEG = 45                 # Base bifurcation angle in degrees
OBJ4_ANGLE_DECAY_PER_LEVEL_DEG = 10       # Angle reduction per bifurcation level (degrees)
OBJ4_MERGE_POINT_X_M = 0.002             # X position of merge point
OBJ4_OUTLET_X_M = 0.002                  # X position of outlet

# =============================================================================
# GEOMETRY THRESHOLDS
# =============================================================================
DEGENERATE_LENGTH_THRESHOLD = 1e-9       # Threshold for degenerate segment detection
INLET_PLACEMENT_FRACTION = 0.7           # Fraction of max radius for inlet placement (2-3 inlets)

# =============================================================================
# OUTPUT PARAMETERS
# =============================================================================
OUTPUT_UNITS = "mm"                # Output STL files in millimeters
OUTPUT_DIR = Path(__file__).parent / "Malaria Venule Inserts"


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def meters_to_mm(value_m: float) -> float:
    """Convert meters to millimeters."""
    return value_m * 1000.0


def print_validation_details(report, indent: str = "    "):
    """
    Print detailed validation results including failure reasons.
    
    Parameters
    ----------
    report : ValidationReport
        The validation report to print details from
    indent : str
        Indentation prefix for output lines
    """
    print(f"{indent}Validation status: {report.status}")
    print(f"{indent}Passed: {report.passed}")
    
    if not report.passed or report.status != "ok":
        summary = report.summary
        print(f"{indent}Summary: {summary.get('passed_checks', '?')}/{summary.get('total_checks', '?')} checks passed, "
              f"{summary.get('failed_checks', '?')} failed, {summary.get('total_warnings', '?')} warnings")
        
        for category_name, category_report in report.reports.items():
            if not category_report.passed:
                print(f"{indent}  Category '{category_name}' FAILED:")
                for check in category_report.checks:
                    if not check.passed:
                        print(f"{indent}    - {check.check_name}: {check.message}")
                        if check.details:
                            for key, value in check.details.items():
                                print(f"{indent}        {key}: {value}")
            elif hasattr(category_report, 'checks'):
                for check in category_report.checks:
                    if check.warnings:
                        print(f"{indent}  Category '{category_name}' warnings:")
                        for warning in check.warnings:
                            print(f"{indent}    - {check.check_name}: {warning}")


def create_cylinder_mesh(radius: float, height: float, center: Tuple[float, float, float]) -> trimesh.Trimesh:
    """Create a solid cylinder mesh centered at the given point."""
    cylinder = trimesh.creation.cylinder(
        radius=radius,
        height=height,
        sections=CYLINDER_MESH_SECTIONS,
    )
    cylinder.apply_translation([center[0], center[1], center[2]])
    return cylinder

def create_ridge_mesh(
    outer_radius: float,
    inner_radius: float,
    height: float,
    z_base: float,
    center_xy: Tuple[float, float],
) -> trimesh.Trimesh:
    """
    Create a watertight annular ring (ridge) mesh via direct vertex/face construction.
    No booleans, no Blender.

    The ring is a closed solid:
      - outer wall
      - inner wall
      - top annulus
      - bottom annulus
    """
    cx, cy = center_xy

    # Choose a reasonable resolution
    n = int(globals().get("RIDGE_MESH_POINTS", 65))
    if n < 16:
        n = 16

    # Angles
    angles = np.linspace(0.0, 2.0 * np.pi, n, endpoint=False)
    c = np.cos(angles)
    s = np.sin(angles)

    z0 = float(z_base)
    z1 = float(z_base + height)

    # Vertex rings (each is length n)
    outer_bottom = np.column_stack([cx + outer_radius * c, cy + outer_radius * s, np.full(n, z0)])
    outer_top    = np.column_stack([cx + outer_radius * c, cy + outer_radius * s, np.full(n, z1)])
    inner_bottom = np.column_stack([cx + inner_radius * c, cy + inner_radius * s, np.full(n, z0)])
    inner_top    = np.column_stack([cx + inner_radius * c, cy + inner_radius * s, np.full(n, z1)])

    # Stack vertices in a known order
    # 0..n-1: outer_bottom
    # n..2n-1: outer_top
    # 2n..3n-1: inner_bottom
    # 3n..4n-1: inner_top
    vertices = np.vstack([outer_bottom, outer_top, inner_bottom, inner_top]).astype(np.float64)

    faces = []

    def idx_outer_bottom(i): return i
    def idx_outer_top(i): return n + i
    def idx_inner_bottom(i): return 2 * n + i
    def idx_inner_top(i): return 3 * n + i

    # Build quads as two triangles per segment
    for i in range(n):
        j = (i + 1) % n

        # Outer wall (winding outward)
        a = idx_outer_bottom(i)
        b = idx_outer_bottom(j)
        c1 = idx_outer_top(i)
        d = idx_outer_top(j)
        faces.append([a, c1, b])
        faces.append([b, c1, d])

        # Inner wall (winding inward => reverse compared to outer)
        a = idx_inner_bottom(i)
        b = idx_inner_bottom(j)
        c1 = idx_inner_top(i)
        d = idx_inner_top(j)
        faces.append([a, b, c1])
        faces.append([b, d, c1])

        # Top annulus (connect outer_top to inner_top)
        a = idx_outer_top(i)
        b = idx_outer_top(j)
        c1 = idx_inner_top(i)
        d = idx_inner_top(j)
        faces.append([a, b, c1])
        faces.append([b, d, c1])

        # Bottom annulus (connect outer_bottom to inner_bottom) – flip winding
        a = idx_outer_bottom(i)
        b = idx_outer_bottom(j)
        c1 = idx_inner_bottom(i)
        d = idx_inner_bottom(j)
        faces.append([a, c1, b])
        faces.append([b, c1, d])

    ring = trimesh.Trimesh(vertices=vertices, faces=np.asarray(faces, dtype=np.int64), process=True)

    # Clean + repair (light but effective)
    ring.remove_unreferenced_vertices()
    ring.merge_vertices()

    # Ensure normals and winding are consistent
    if ring.volume < 0:
        ring.invert()
    trimesh.repair.fix_normals(ring)
    trimesh.repair.fill_holes(ring)

    # Final sanity
    if not ring.is_watertight:
        # One more pass; avoids tiny cracks from numerical issues
        ring.merge_vertices()
        trimesh.repair.fill_holes(ring)
        trimesh.repair.fix_normals(ring)

    print("  Ridge: Created annular ring using direct mesh construction")
    return ring


def create_channel_mesh(
    position_xy: Tuple[float, float],
    z_top: float,
    radius: float,
    depth: float,
) -> trimesh.Trimesh:
    """Create a cylindrical channel mesh extending downward from z_top."""
    channel = trimesh.creation.cylinder(
        radius=radius,
        height=depth,
        sections=CHANNEL_MESH_SECTIONS,
    )
    # Position so top of channel is at z_top
    channel.apply_translation([position_xy[0], position_xy[1], z_top - depth / 2])
    return channel


def compute_taper_radius(level: int, total_levels: int, r_start: float, r_end: float) -> float:
    """
    Compute radius at a given bifurcation level using exponential taper.
    
    r_k = r_0 * (r_end/r_0)^(k/total_levels)
    """
    if total_levels == 0:
        return r_start
    ratio = r_end / r_start
    return r_start * (ratio ** (level / total_levels))


def voxel_union_meshes(meshes: List[trimesh.Trimesh], pitch: float) -> trimesh.Trimesh:
    """
    Union multiple meshes using voxelization and marching cubes.
    
    This is the overlap-based merge strategy: overlapping volumes are
    automatically merged during voxelization.
    
    Uses the repo's voxelized_with_retry() function for robust voxelization
    with automatic retry on memory errors.
    
    IMPORTANT: Uses trimesh's native VoxelGrid.marching_cubes property instead of
    skimage.measure.marching_cubes to avoid axis/transform seam bugs that can
    create disconnected mesh components.
    """
    from validity.mesh.voxel_utils import voxelized_with_retry
    
    if not meshes:
        raise ValueError("No meshes to union")
    
    if len(meshes) == 1:
        return meshes[0]
    
    # Concatenate all meshes
    combined = trimesh.util.concatenate(meshes)
    
    # Voxelize using repo's voxelized_with_retry for robust handling of memory errors
    voxels = voxelized_with_retry(
        combined, 
        pitch, 
        max_attempts=VOXEL_RETRY_MAX_ATTEMPTS, 
        factor=VOXEL_RETRY_FACTOR,
        log_prefix="[voxel_union_meshes] ",
    )
    
    # IMPORTANT: Fill the voxel grid to get solid volumes, not just surface shells
    # Without .fill(), voxelized() returns surface occupancy which produces fragile
    # non-manifold results and nonsense volumes when passed to marching cubes
    voxels = voxels.fill()
    
    # Use trimesh's native marching_cubes property which correctly handles
    # the voxel grid transform (axis order + translation + scaling).
    # This avoids the seam/gap bugs that occur when manually applying
    # voxels.transform[:3, 3] to skimage marching_cubes output.
    result = voxels.marching_cubes
    
    # Light cleanup pass: merge vertices and fill holes
    # Avoid aggressive face filtering that can open seams
    result.merge_vertices()
    result.remove_unreferenced_vertices()
    
    # Fill any remaining holes
    trimesh.repair.fill_holes(result)
    
    # Fix normals and winding
    if result.volume < 0:
        result.invert()
    trimesh.repair.fix_normals(result)
    
    return result


def scale_mesh_to_mm(mesh: trimesh.Trimesh) -> trimesh.Trimesh:
    """Scale mesh from meters to millimeters."""
    scaled = mesh.copy()
    scaled.apply_scale(1000.0)  # m to mm
    return scaled


def export_mesh_with_units(mesh: trimesh.Trimesh, output_path: Path, units: str = "mm"):
    """Export mesh to STL with units.json sidecar file."""
    mesh.export(str(output_path))
    
    # Write units sidecar
    sidecar_path = str(output_path) + ".units.json"
    metadata = {
        "units": units,
        "stl_file": str(output_path),
        "description": "Malaria Venule Insert scaffold",
    }
    with open(sidecar_path, 'w') as f:
        json.dump(metadata, f, indent=2)
    
    print(f"  Exported: {output_path}")
    print(f"  Units sidecar: {sidecar_path}")


def repair_mesh_for_embedding(
    mesh: trimesh.Trimesh, 
    name: str = "mesh",
    keep_largest_component: bool = True,
) -> trimesh.Trimesh:
    """
    Repair a mesh to ensure it is watertight before embedding.
    
    Uses the validity library's meshfix_repair function as the primary repair method.
    Falls back to trimesh's built-in repair functions if pymeshfix is not installed.
    
    Parameters
    ----------
    mesh : trimesh.Trimesh
        The mesh to repair
    name : str
        Name for logging purposes
    keep_largest_component : bool
        If True, keep only the largest connected component (default).
        Set to False for meshes with multiple disconnected parts that should
        all be preserved (e.g., Object 3's 4 separate inlet trees).
    
    Returns
    -------
    trimesh.Trimesh
        The repaired mesh
    """
    repaired = mesh.copy()
    
    print(f"    Repairing {name} for embedding...")
    print(f"    Before repair: {len(repaired.vertices)} vertices, {len(repaired.faces)} faces, watertight={repaired.is_watertight}")
    
    # Primary repair method: Use validity library's meshfix_repair
    try:
        from validity.mesh.repair import meshfix_repair
        print(f"    Using validity library's meshfix_repair (keep_largest_component={keep_largest_component})...")
        repaired = meshfix_repair(repaired, keep_largest_component=keep_largest_component)
        print(f"    meshfix_repair complete")
    except ImportError:
        print(f"    meshfix_repair not available (pymeshfix not installed)")
        print(f"    Falling back to trimesh repair functions...")
        
        # Fallback: Use trimesh's built-in repair functions
        try:
            trimesh.repair.fix_normals(repaired)
            print(f"    Fixed normals")
        except Exception as e:
            print(f"    Warning: fix_normals failed: {e}")
        
        try:
            trimesh.repair.fix_winding(repaired)
            print(f"    Fixed winding")
        except Exception as e:
            print(f"    Warning: fix_winding failed: {e}")
        
        if not repaired.is_watertight:
            try:
                trimesh.repair.fill_holes(repaired)
                print(f"    Filled holes")
            except Exception as e:
                print(f"    Warning: fill_holes failed: {e}")
    except Exception as e:
        print(f"    Warning: meshfix_repair failed: {e}")
        print(f"    Falling back to trimesh repair functions...")
        
        # Fallback: Use trimesh's built-in repair functions
        try:
            trimesh.repair.fix_normals(repaired)
            print(f"    Fixed normals")
        except Exception as e2:
            print(f"    Warning: fix_normals failed: {e2}")
        
        try:
            trimesh.repair.fix_winding(repaired)
            print(f"    Fixed winding")
        except Exception as e2:
            print(f"    Warning: fix_winding failed: {e2}")
        
        if not repaired.is_watertight:
            try:
                trimesh.repair.fill_holes(repaired)
                print(f"    Filled holes")
            except Exception as e2:
                print(f"    Warning: fill_holes failed: {e2}")
    
    # Final cleanup: Remove degenerate faces (version-safe)
    try:
        # Try the method name used in newer trimesh versions
        if hasattr(repaired, 'remove_degenerate_faces'):
            repaired.remove_degenerate_faces()
        elif hasattr(repaired, 'update_faces'):
            # Older versions use update_faces with a mask
            # Remove faces with zero area
            face_areas = repaired.area_faces
            valid_faces = face_areas > 0
            repaired.update_faces(valid_faces)
        repaired.remove_unreferenced_vertices()
        print(f"    Removed degenerate faces")
    except Exception as e:
        print(f"    Warning: remove_degenerate_faces failed: {e}")
    
    print(f"    After repair: {len(repaired.vertices)} vertices, {len(repaired.faces)} faces, watertight={repaired.is_watertight}")
    
    return repaired


def embed_void_in_cylinder(
    void_mesh: trimesh.Trimesh,
    output_dir: Optional[Path] = None,
    object_name: str = "object",
    voxel_pitch: float = VOXEL_PITCH_M,
    keep_largest_component: bool = True,
) -> trimesh.Trimesh:
    """
    Use the repo's embed_tree_as_negative_space function to carve voids from a cylinder domain.
    
    This function:
    1. Exports the void mesh to a temporary STL file (in meters)
    2. Creates a CylinderDomain matching our base cylinder
    3. Calls embed_tree_as_negative_space to carve the void
    4. Returns the domain_with_void mesh (in meters, for consistency with other functions)
    
    If the repo's embedding function fails or returns an empty result, falls back to
    direct voxel-based subtraction.
    
    Parameters
    ----------
    void_mesh : trimesh.Trimesh
        The void/channel mesh to carve from the cylinder (in meters)
    output_dir : Path, optional
        Directory to save intermediate STL files
    object_name : str
        Name prefix for intermediate files
    voxel_pitch : float
        Voxel pitch for embedding (in meters)
    keep_largest_component : bool
        If True, keep only the largest connected component during repair (default).
        Set to False for meshes with multiple disconnected parts that should
        all be preserved (e.g., Object 3's 4 separate inlet trees).
    
    Returns
    -------
    trimesh.Trimesh
        The cylinder domain with void carved out (in meters)
    """
    import tempfile
    from skimage.measure import marching_cubes
    from scipy import ndimage
    
    # Repair the void mesh before embedding to ensure watertightness
    void_mesh = repair_mesh_for_embedding(
        void_mesh, 
        name=f"{object_name}_void",
        keep_largest_component=keep_largest_component,
    )
    
    # Print diagnostic info about the void mesh
    void_bounds = void_mesh.bounds
    print(f"    Void mesh bounds: min={void_bounds[0]}, max={void_bounds[1]}")
    print(f"    Void mesh volume: {void_mesh.volume:.9f} m^3")
    print(f"    Void mesh watertight: {void_mesh.is_watertight}")
    
    # Print diagnostic info about the cylinder domain
    cyl_z_min = CYLINDER_CENTER[2] - CYLINDER_HEIGHT_M / 2
    cyl_z_max = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    print(f"    Cylinder domain: center={CYLINDER_CENTER}, radius={CYLINDER_RADIUS_M}m, height={CYLINDER_HEIGHT_M}m")
    print(f"    Cylinder Z range: [{cyl_z_min}, {cyl_z_max}]")
    
    # Create temporary directory for intermediate files
    temp_dir = Path(tempfile.mkdtemp(prefix=f"embed_{object_name}_"))
    
    # Export void mesh to temporary STL (in meters, with units.json sidecar)
    void_stl_path = temp_dir / f"{object_name}_void.stl"
    void_mesh.export(str(void_stl_path))
    
    # Write units sidecar so embed_tree_as_negative_space knows the units
    sidecar_path = str(void_stl_path) + ".units.json"
    with open(sidecar_path, 'w') as f:
        json.dump({"units": "m"}, f)
    
    print(f"    Exported void mesh to: {void_stl_path}")
    
    # Also save to output_dir if provided
    if output_dir:
        intermediate_path = output_dir / "intermediate" / f"{object_name}_void_for_embedding.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(void_mesh).export(str(intermediate_path))
        print(f"    Saved intermediate void mesh: {intermediate_path}")
    
    # Create CylinderDomain matching our base cylinder
    domain = CylinderDomain(
        center=Point3D(CYLINDER_CENTER[0], CYLINDER_CENTER[1], CYLINDER_CENTER[2]),
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
    )
    
    print(f"    Using embed_tree_as_negative_space with voxel_pitch={voxel_pitch*1e6:.1f}um")
    
    try:
        # Call the repo's embedding function
        # IMPORTANT: smoothing_iters=0 to prevent voxelization from smoothing over the embedding
        # The embedding function applies binary closing/opening which can smooth out void edges
        result = embed_tree_as_negative_space(
            tree_stl_path=void_stl_path,
            domain=domain,
            voxel_pitch=voxel_pitch,
            stl_units="m",  # We exported in meters
            geometry_units="m",  # Domain is in meters
            output_units="m",  # Return in meters (we'll scale to mm at final export)
            output_void=True,
            smoothing_iters=0,  # NO smoothing to preserve void shape exactly
        )
        
        domain_with_void = result['domain_with_void']
        
        if domain_with_void is None:
            raise RuntimeError("embed_tree_as_negative_space returned None for domain_with_void")
        
        # FIX 1 & 6: Use mask-based test instead of volume comparison
        # Void meshes often have unreliable/zero volume (uncapped tubes, self-intersections)
        # so volume comparison is unreliable. Use voxel counts from metadata instead.
        metadata = result.get('metadata', {})
        voxel_counts = metadata.get('voxel_counts', {})
        
        domain_voxels = voxel_counts.get('domain', 0)
        void_voxels = voxel_counts.get('void', 0)
        solid_voxels = voxel_counts.get('solid', 0)
        
        # Debug artifact: Print mask counts (Fix 6)
        print(f"    Voxel counts from embedding:")
        print(f"      Domain mask: {domain_voxels} voxels")
        print(f"      Void mask: {void_voxels} voxels")
        print(f"      Solid mask: {solid_voxels} voxels")
        
        # Save debug artifacts if output_dir provided (Fix 6)
        if output_dir:
            debug_path = output_dir / "intermediate" / f"{object_name}_embedding_debug.json"
            debug_path.parent.mkdir(parents=True, exist_ok=True)
            debug_info = {
                "voxel_counts": voxel_counts,
                "void_bounds": void_bounds.tolist() if hasattr(void_bounds, 'tolist') else list(void_bounds),
                "domain_bounds": {
                    "center": list(CYLINDER_CENTER),
                    "radius": CYLINDER_RADIUS_M,
                    "height": CYLINDER_HEIGHT_M,
                },
                "voxel_pitch": voxel_pitch,
                "metadata": {k: v for k, v in metadata.items() if k != 'voxel_counts'},
            }
            with open(debug_path, 'w') as f:
                json.dump(debug_info, f, indent=2, default=str)
            print(f"    Saved debug info: {debug_path}")
        
        # Mask-based carving check (Fix 1):
        # Carving is successful if:
        # 1. void_mask.sum() > 0 (void was voxelized)
        # 2. solid_mask.sum() < domain_mask.sum() - epsilon (material was removed)
        epsilon = max(1, int(domain_voxels * 0.001))  # 0.1% tolerance
        
        carving_successful = (void_voxels > 0) and (solid_voxels < domain_voxels - epsilon)
        
        if not carving_successful:
            if void_voxels == 0:
                print(f"    WARNING: Void mask is empty - void was not voxelized!")
            elif solid_voxels >= domain_voxels - epsilon:
                print(f"    WARNING: Solid mask ({solid_voxels}) ≈ domain mask ({domain_voxels}) - void may not have been carved!")
            print(f"    Falling back to direct voxel subtraction...")
            raise RuntimeError("Void not carved (mask-based check failed) - falling back to direct subtraction")
        
        print(f"    Carving verified: {domain_voxels - solid_voxels} voxels removed ({(domain_voxels - solid_voxels) / domain_voxels * 100:.1f}%)")
        print(f"    Embedding complete: {len(domain_with_void.vertices)} vertices, {len(domain_with_void.faces)} faces")
        print(f"    Watertight: {domain_with_void.is_watertight}")
        
    except Exception as e:
        print(f"    embed_tree_as_negative_space failed or void not carved: {e}")
        print(f"    Using direct voxel subtraction fallback...")
        
        # Fallback: Direct voxel-based subtraction
        # Create cylinder mesh
        cylinder = create_cylinder_mesh(
            radius=CYLINDER_RADIUS_M,
            height=CYLINDER_HEIGHT_M,
            center=CYLINDER_CENTER,
        )
        
        # Compute domain bounds with padding
        domain_min = np.array([
            CYLINDER_CENTER[0] - CYLINDER_RADIUS_M,
            CYLINDER_CENTER[1] - CYLINDER_RADIUS_M,
            CYLINDER_CENTER[2] - CYLINDER_HEIGHT_M / 2
        ])
        domain_max = np.array([
            CYLINDER_CENTER[0] + CYLINDER_RADIUS_M,
            CYLINDER_CENTER[1] + CYLINDER_RADIUS_M,
            CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
        ])
        
        padding = 2
        grid_shape = np.ceil((domain_max - domain_min) / voxel_pitch).astype(int) + 2 * padding
        domain_min_padded = domain_min - padding * voxel_pitch
        
        print(f"    Voxel grid shape: {grid_shape}")
        
        # Voxelize cylinder
        try:
            cyl_voxels = cylinder.voxelized(voxel_pitch)
            cyl_matrix = cyl_voxels.matrix
            cyl_origin = cyl_voxels.transform[:3, 3]
        except Exception as ve:
            print(f"    Cylinder voxelization failed: {ve}")
            raise
        
        # Voxelize void
        try:
            void_voxels = void_mesh.voxelized(voxel_pitch)
            void_matrix = void_voxels.matrix
            void_origin = void_voxels.transform[:3, 3]
        except Exception as ve:
            print(f"    Void voxelization failed: {ve}")
            raise
        
        # Create aligned grids
        aligned_cyl = np.zeros(grid_shape, dtype=bool)
        aligned_void = np.zeros(grid_shape, dtype=bool)
        
        # Copy cylinder voxels to aligned grid
        cyl_offset = np.round((cyl_origin - domain_min_padded) / voxel_pitch).astype(int)
        cyl_shape = np.array(cyl_matrix.shape)
        cyl_src_start = np.maximum(-cyl_offset, 0)
        cyl_dst_start = np.maximum(cyl_offset, 0)
        cyl_copy_size = np.minimum(cyl_shape - cyl_src_start, grid_shape - cyl_dst_start)
        cyl_copy_size = np.maximum(cyl_copy_size, 0)
        
        if np.all(cyl_copy_size > 0):
            aligned_cyl[
                cyl_dst_start[0]:cyl_dst_start[0] + cyl_copy_size[0],
                cyl_dst_start[1]:cyl_dst_start[1] + cyl_copy_size[1],
                cyl_dst_start[2]:cyl_dst_start[2] + cyl_copy_size[2]
            ] = cyl_matrix[
                cyl_src_start[0]:cyl_src_start[0] + cyl_copy_size[0],
                cyl_src_start[1]:cyl_src_start[1] + cyl_copy_size[1],
                cyl_src_start[2]:cyl_src_start[2] + cyl_copy_size[2]
            ]
        
        # Copy void voxels to aligned grid
        void_offset = np.round((void_origin - domain_min_padded) / voxel_pitch).astype(int)
        void_shape = np.array(void_matrix.shape)
        void_src_start = np.maximum(-void_offset, 0)
        void_dst_start = np.maximum(void_offset, 0)
        void_copy_size = np.minimum(void_shape - void_src_start, grid_shape - void_dst_start)
        void_copy_size = np.maximum(void_copy_size, 0)
        
        if np.all(void_copy_size > 0):
            aligned_void[
                void_dst_start[0]:void_dst_start[0] + void_copy_size[0],
                void_dst_start[1]:void_dst_start[1] + void_copy_size[1],
                void_dst_start[2]:void_dst_start[2] + void_copy_size[2]
            ] = void_matrix[
                void_src_start[0]:void_src_start[0] + void_copy_size[0],
                void_src_start[1]:void_src_start[1] + void_copy_size[1],
                void_src_start[2]:void_src_start[2] + void_copy_size[2]
            ]
        
        print(f"    Cylinder voxels: {aligned_cyl.sum()}")
        print(f"    Void voxels: {aligned_void.sum()}")
        
        # Subtract void from cylinder
        result_mask = aligned_cyl & (~aligned_void)
        print(f"    Result voxels: {result_mask.sum()}")
        
        # NO smoothing to preserve void shape exactly
        # Binary closing/opening can smooth out void edges, so we skip it
        
        # Generate mesh with marching cubes
        if result_mask.any():
            verts, faces, _, _ = marching_cubes(
                volume=result_mask.astype(np.uint8),
                level=0.5,
                spacing=(voxel_pitch, voxel_pitch, voxel_pitch),
                allow_degenerate=False,
            )
            
            # Transform to world coordinates
            # NOTE: Do NOT swap axes here. The voxel matrix from trimesh.voxelized()
            # is already in (x, y, z) order, and marching_cubes returns vertices
            # in the same order. Swapping axes would rotate the cylinder 90 degrees,
            # making it perpendicular to the ridge and branches.
            verts += domain_min_padded
            
            domain_with_void = trimesh.Trimesh(
                vertices=verts,
                faces=faces.astype(np.int64),
                process=False,
            )
            
            domain_with_void.remove_unreferenced_vertices()
            if domain_with_void.volume < 0:
                domain_with_void.invert()
            trimesh.repair.fix_normals(domain_with_void)
            
            if not domain_with_void.is_watertight:
                trimesh.repair.fill_holes(domain_with_void)
            
            print(f"    Fallback complete: {len(domain_with_void.vertices)} vertices, {len(domain_with_void.faces)} faces")
            print(f"    Watertight: {domain_with_void.is_watertight}")
        else:
            raise RuntimeError("Result mask is empty after voxel subtraction")
    
    # Clean up temp files
    import shutil
    shutil.rmtree(temp_dir, ignore_errors=True)
    
    # Export intermediate result if output_dir provided
    if output_dir:
        intermediate_path = output_dir / "intermediate" / f"{object_name}_cylinder_with_void.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(domain_with_void).export(str(intermediate_path))
        print(f"    Saved intermediate cylinder with void: {intermediate_path}")
    
    return domain_with_void


# =============================================================================
# OBJECT GENERATION FUNCTIONS
# =============================================================================

def generate_object1_control(output_dir: Optional[Path] = None) -> trimesh.Trimesh:
    """
    Generate Object 1: Solid cylinder + ridge (no internal voids).

    Key fix:
      - Ridge MUST overlap into cylinder (not just touch) to ensure voxel union merges it.
      - We reuse the same 'add_ridge_to_mesh' pipeline used for other objects to avoid regressions.
    """
    print("\n" + "=" * 60)
    print("Generating Object 1: Control (solid cylinder + ridge)")
    print("=" * 60)

    # Base cylinder
    print("  Creating base cylinder...")
    base_cylinder = create_cylinder_mesh(
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
        center=CYLINDER_CENTER,
    )
    print(f"    Cylinder: radius={meters_to_mm(CYLINDER_RADIUS_M):.1f}mm, height={meters_to_mm(CYLINDER_HEIGHT_M):.1f}mm")

    # Save intermediate cylinder
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object1_cylinder.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(base_cylinder).export(str(intermediate_path))
        print(f"    Exported intermediate: {intermediate_path}")

    # Add ridge using the centralized ridge adder if available
    # (this uses RIDGE_OVERLAP_M and VOXEL_PITCH_RIDGE_M)
    if "add_ridge_to_mesh" in globals():
        print("  Adding ridge (using add_ridge_to_mesh with overlap)...")
        combined = add_ridge_to_mesh(base_cylinder)
    else:
        # Fallback inline ridge add (still uses overlap)
        print("  Adding ridge (inline fallback)...")
        z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
        overlap = float(globals().get("RIDGE_OVERLAP_M", 0.0))
        ridge_z_base = z_top - overlap
        ridge_total_height = RIDGE_HEIGHT_M + overlap

        ridge = create_ridge_mesh(
            outer_radius=CYLINDER_RADIUS_M,
            inner_radius=CYLINDER_RADIUS_M - RIDGE_THICKNESS_M,
            height=ridge_total_height,
            z_base=ridge_z_base,
            center_xy=(CYLINDER_CENTER[0], CYLINDER_CENTER[1]),
        )

        if output_dir:
            ridge_path = output_dir / "intermediate" / "object1_ridge.stl"
            scale_mesh_to_mm(ridge).export(str(ridge_path))
            print(f"    Exported intermediate: {ridge_path}")

        print(f"  Combining cylinder and ridge (voxel pitch: {meters_to_mm(VOXEL_PITCH_RIDGE_M)*1000:.0f}um)...")
        combined = voxel_union_meshes([base_cylinder, ridge], pitch=VOXEL_PITCH_RIDGE_M)

    print(f"  Object 1 complete: {len(combined.vertices)} vertices, {len(combined.faces)} faces")
    print(f"    Watertight: {combined.is_watertight}")
    print(f"    Bounds (m): {combined.bounds}")

    # OPTIONAL: validation for Object 1 is often misleading (it runs channel checks on a control).
    # If you still want it, keep it, but it should not be used to judge ridge success.
    try:
        if "ValidationConfig" in globals() and "run_post_embedding_validation" in globals():
            print("  Running validation (control object)...")
            validation_config = ValidationConfig(
                voxel_pitch_m=VOXEL_PITCH_M,
                expected_outlets=0,
            )
            report = run_post_embedding_validation(mesh=combined, config=validation_config)
            print_validation_details(report)
    except Exception as e:
        print(f"    Validation error (ignored for control object): {e}")

    return combined


def generate_object2_channels(output_dir: Optional[Path] = None) -> trimesh.Trimesh:
    """
    Generate Object 2: Control + straight channels.
    
    Design choice: 4 channels in a square pattern at (+/-1.5mm, +/-1.5mm).
    Uses the repo's embed_tree_as_negative_space function for embedding.
    
    Returns mesh in METERS (will be scaled to mm at export).
    
    Parameters
    ----------
    output_dir : Path, optional
        Directory to save intermediate STL files for debugging
    """
    print("\n" + "=" * 60)
    print("Generating Object 2: Control + straight channels")
    print("=" * 60)
    
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    
    # Create channels
    print(f"  Creating {OBJ2_NUM_INLETS} straight channels...")
    
    channels = []
    for i, pos in enumerate(OBJ2_INLET_POSITIONS[:OBJ2_NUM_INLETS]):
        channel = create_channel_mesh(
            position_xy=pos,
            z_top=z_top,
            radius=OBJ2_INLET_RADIUS_M,
            depth=OBJ2_CHANNEL_DEPTH_M,
        )
        channels.append(channel)
        print(f"    Channel {i+1}: position=({meters_to_mm(pos[0]):.1f}, {meters_to_mm(pos[1]):.1f})mm, "
              f"radius={meters_to_mm(OBJ2_INLET_RADIUS_M)}mm, depth={meters_to_mm(OBJ2_CHANNEL_DEPTH_M)}mm")
    
    # Union all channels
    print("  Combining channels...")
    channel_void = voxel_union_meshes(channels, pitch=VOXEL_PITCH_UNION_M)
    
    # Export intermediate channel void mesh
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object2_channel_void.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(channel_void).export(str(intermediate_path))
        print(f"    Exported intermediate void: {intermediate_path}")
    
    # Run pre-embedding validation on channel void mesh
    print("  Running pre-embedding validation on channel void mesh...")
    try:
        pre_report = run_pre_embedding_validation(mesh=channel_void)
        print_validation_details(pre_report)
    except Exception as e:
        print(f"    Pre-embedding validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Use the repo's embed_tree_as_negative_space function to carve channels from cylinder
    print("  Carving channels using embed_tree_as_negative_space...")
    cylinder_with_void = embed_void_in_cylinder(
        void_mesh=channel_void,
        output_dir=output_dir,
        object_name="object2",
        voxel_pitch=VOXEL_PITCH_M,
    )
    
    # Export intermediate cylinder with void (before ridge)
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object2_cylinder_with_void.stl"
        scale_mesh_to_mm(cylinder_with_void).export(str(intermediate_path))
        print(f"    Exported intermediate cylinder with void: {intermediate_path}")
    
    print(f"  Cylinder with void: {len(cylinder_with_void.vertices)} vertices, {len(cylinder_with_void.faces)} faces")
    print(f"    Watertight: {cylinder_with_void.is_watertight}")
    
    # Run post-embedding validation on cylinder with void (before adding ridge)
    print("  Running validation on cylinder with void...")
    try:
        validation_config = ValidationConfig(
            voxel_pitch_m=VOXEL_PITCH_M,
            expected_outlets=OBJ2_NUM_INLETS,
        )
        report = run_post_embedding_validation(mesh=cylinder_with_void, config=validation_config)
        print_validation_details(report)
    except Exception as e:
        print(f"    Validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Return cylinder_with_void - ridge will be added at the END in main() to prevent smoothing
    return cylinder_with_void


def generate_bifurcation_tree_mesh(
    inlet_position: Tuple[float, float, float],
    inlet_radius: float,
    terminal_radius: float,
    bifurcation_depths: List[float],
    base_angle_deg: float = 30.0,
    rng_seed: Optional[int] = None,
    growth_fraction_range: Tuple[float, float] = (0.3, 0.7),
) -> trimesh.Trimesh:
    """
    Generate a bifurcating tree mesh from a single inlet.
    
    Uses the pre-built grow_to_point and bifurcate tools from the generation library.
    Implements grow -> bifurcate -> grow pattern where branches grow for an RNG-based
    distance before bifurcating, ensuring proper separation between branches.
    
    Parameters
    ----------
    inlet_position : tuple
        (x, y, z) position of inlet in meters
    inlet_radius : float
        Radius at inlet in meters
    terminal_radius : float
        Radius at terminals in meters
    bifurcation_depths : list
        Z-depths (from top) where bifurcations occur, in meters
    base_angle_deg : float
        Base bifurcation angle in degrees
    rng_seed : int, optional
        Random seed for reproducible growth distances
    growth_fraction_range : tuple
        (min, max) fraction of available distance for post-bifurcation growth.
        Growth distance is calculated as: fraction * distance_to_next_bifurcation
        This ensures branches separate before the next bifurcation while leaving
        enough space to bifurcate before reaching the base height or edge.
    
    Returns
    -------
    trimesh.Trimesh
        Combined mesh of all branches
    """
    from generation.ops.growth import grow_to_point, bifurcate
    from generation.rules.constraints import BranchingConstraints
    
    num_levels = len(bifurcation_depths)
    rng = np.random.default_rng(rng_seed)
    
    # Create a VascularNetwork with a cylinder domain for the tree
    domain = CylinderDomain(
        center=CYLINDER_CENTER,
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
    )
    network = create_network(domain, seed=rng_seed)
    
    # Set up constraints with relaxed limits for small geometry
    constraints = BranchingConstraints(
        min_segment_length=BRANCH_MIN_SEGMENT_LENGTH_M,
        max_segment_length=BRANCH_MAX_SEGMENT_LENGTH_M,
        min_radius=BRANCH_MIN_RADIUS_M,
    )
    
    # Add inlet node
    inlet_result = add_inlet(
        network,
        position=inlet_position,
        direction=(0.0, 0.0, -1.0),  # Downward
        radius=inlet_radius,
        vessel_type="venous",
    )
    if not inlet_result.is_success():
        print(f"    Warning: Failed to add inlet: {inlet_result.message}")
        return trimesh.Trimesh()
    
    inlet_node_id = inlet_result.new_ids["node"]
    
    # Track current branch tips: list of (node_id, level)
    current_tips = [(inlet_node_id, 0)]
    
    for level in range(num_levels):
        depth = bifurcation_depths[level]
        target_z = inlet_position[2] - depth
        
        # Calculate distance to next bifurcation level (for growth distance calculation)
        if level + 1 < num_levels:
            next_depth = bifurcation_depths[level + 1]
            distance_between_levels = next_depth - depth
        else:
            # Last level: use remaining distance to bottom (with margin)
            bottom_z = inlet_position[2] - CYLINDER_HEIGHT_M * (1.0 - BIFURC_BOTTOM_MARGIN_FRACTION)  # Leave margin
            distance_between_levels = depth - (inlet_position[2] - bottom_z)
            distance_between_levels = max(distance_between_levels, BIFURC_MIN_SEGMENT_LENGTH_M)
        
        new_tips = []
        
        for tip_node_id, tip_level in current_tips:
            if tip_level != level:
                new_tips.append((tip_node_id, tip_level))
                continue
            
            # Get current node position and direction
            tip_node = network.get_node(tip_node_id)
            if tip_node is None:
                continue
            
            tip_pos = np.array([tip_node.position.x, tip_node.position.y, tip_node.position.z])
            tip_dir_dict = tip_node.attributes.get("direction", {"dx": 0, "dy": 0, "dz": -1})
            tip_dir = np.array([tip_dir_dict.get("dx", 0), tip_dir_dict.get("dy", 0), tip_dir_dict.get("dz", -1)])
            
            # Compute radius for this level
            current_radius = compute_taper_radius(level, num_levels, inlet_radius, terminal_radius)
            next_radius = compute_taper_radius(level + 1, num_levels, inlet_radius, terminal_radius)
            
            # Calculate distance to target z for grow_to_point
            if abs(tip_dir[2]) > BIFURC_DIRECTION_THRESHOLD:
                dist_to_target = abs((target_z - tip_pos[2]) / tip_dir[2])
            else:
                dist_to_target = BIFURC_HORIZONTAL_STEP_M  # Small step for horizontal branches
            
            dist_to_target = max(dist_to_target, BIFURC_MIN_SEGMENT_LENGTH_M)  # Minimum segment length
            
            # Calculate bifurcation point
            bifurc_pos = tip_pos + tip_dir * dist_to_target
            
            # Use grow_to_point to grow to bifurcation point
            grow_result = grow_to_point(
                network,
                from_node_id=tip_node_id,
                target_point=tuple(bifurc_pos),
                target_radius=current_radius,
                constraints=constraints,
                check_collisions=False,
                fail_on_collision=False,
            )
            
            if not grow_result.is_success():
                print(f"    Warning: grow_to_point failed at level {level}: {grow_result.message}")
                continue
            
            bifurc_node_id = grow_result.new_ids["node"]
            
            # Calculate RNG-based growth distances for child branches
            # This implements the grow -> bifurcate -> grow pattern
            max_growth = distance_between_levels * BIFURC_MAX_GROWTH_FRACTION  # Leave room for next bifurcation approach
            
            growth_fraction1 = rng.uniform(growth_fraction_range[0], growth_fraction_range[1])
            growth_distance1 = min(growth_fraction1 * distance_between_levels, max_growth)
            growth_distance1 = max(growth_distance1, BIFURC_MIN_GROWTH_DISTANCE_M)
            
            growth_fraction2 = rng.uniform(growth_fraction_range[0], growth_fraction_range[1])
            growth_distance2 = min(growth_fraction2 * distance_between_levels, max_growth)
            growth_distance2 = max(growth_distance2, BIFURC_MIN_GROWTH_DISTANCE_M)
            
            # Angle for bifurcation (decreases with level for tighter packing)
            angle_deg = base_angle_deg * (1.0 - BIFURC_ANGLE_REDUCTION_PER_LEVEL * level)
            
            # Use bifurcate to create two child branches with RNG-based growth lengths
            # The bifurcate function creates growth segments for each child
            bifurc_result = bifurcate(
                network,
                at_node_id=bifurc_node_id,
                child_lengths=(growth_distance1, growth_distance2),
                angle_deg=angle_deg,
                constraints=constraints,
                check_collisions=False,
                seed=rng_seed,
            )
            
            if not bifurc_result.is_success():
                print(f"    Warning: bifurcate failed at level {level}: {bifurc_result.message}")
                continue
            
            # Get the child node IDs from bifurcation result
            child_node_ids = bifurc_result.new_ids.get("nodes", [])
            for child_node_id in child_node_ids:
                # Update child node radius for next level
                child_node = network.get_node(child_node_id)
                if child_node:
                    child_node.attributes["radius"] = next_radius
                new_tips.append((child_node_id, level + 1))
        
        current_tips = new_tips
    
    # Add final short terminal segments for remaining tips
    for tip_node_id, tip_level in current_tips:
        tip_node = network.get_node(tip_node_id)
        if tip_node is None:
            continue
        
        tip_pos = np.array([tip_node.position.x, tip_node.position.y, tip_node.position.z])
        tip_dir_dict = tip_node.attributes.get("direction", {"dx": 0, "dy": 0, "dz": -1})
        tip_dir = np.array([tip_dir_dict.get("dx", 0), tip_dir_dict.get("dy", 0), tip_dir_dict.get("dz", -1)])
        
        # Short terminal segment
        end_pos = tip_pos + tip_dir * BIFURC_TERMINAL_SEGMENT_LENGTH_M
        
        grow_result = grow_to_point(
            network,
            from_node_id=tip_node_id,
            target_point=tuple(end_pos),
            target_radius=terminal_radius,
            constraints=constraints,
            check_collisions=False,
            fail_on_collision=False,
        )
    
    # Convert network to mesh using the mesh adapter
    print(f"    Converting network to mesh ({len(network.segments)} segments)...")
    mesh_result = to_trimesh(network, mode="fast", include_caps=True, include_node_spheres=False)
    
    if mesh_result.is_success():
        return mesh_result.metadata["mesh"]
    else:
        print(f"    Warning: to_trimesh failed: {mesh_result.message}")
        return trimesh.Trimesh()


def _create_tapered_cylinder(
    start: np.ndarray,
    end: np.ndarray,
    radius_start: float,
    radius_end: float,
    sections: int = TAPERED_CYLINDER_SECTIONS,
) -> trimesh.Trimesh:
    """Create a tapered cylinder (frustum) between two points."""
    direction = end - start
    length = np.linalg.norm(direction)
    
    if length < DEGENERATE_LENGTH_THRESHOLD:
        # Degenerate segment, return small sphere
        sphere = trimesh.creation.icosphere(subdivisions=1, radius=radius_start)
        sphere.apply_translation(start)
        return sphere
    
    direction = direction / length
    
    # Create frustum along Z axis
    if abs(radius_start - radius_end) < 1e-10:
        frustum = trimesh.creation.cylinder(
            radius=radius_start,
            height=length,
            sections=sections,
        )
    else:
        # Manual frustum creation
        angles = np.linspace(0, 2 * np.pi, sections, endpoint=False)
        
        z_bottom = -length / 2
        z_top = length / 2
        
        bottom_verts = np.column_stack([
            radius_start * np.cos(angles),
            radius_start * np.sin(angles),
            np.full(sections, z_bottom),
        ])
        
        top_verts = np.column_stack([
            radius_end * np.cos(angles),
            radius_end * np.sin(angles),
            np.full(sections, z_top),
        ])
        
        # Center vertices for caps
        center_bottom = np.array([[0, 0, z_bottom]])
        center_top = np.array([[0, 0, z_top]])
        
        vertices = np.vstack([bottom_verts, top_verts, center_bottom, center_top])
        
        faces = []
        # Side faces
        for i in range(sections):
            i_next = (i + 1) % sections
            faces.append([i, i_next, i + sections])
            faces.append([i_next, i_next + sections, i + sections])
        
        # Bottom cap
        center_bottom_idx = 2 * sections
        for i in range(sections):
            i_next = (i + 1) % sections
            faces.append([center_bottom_idx, i_next, i])
        
        # Top cap
        center_top_idx = 2 * sections + 1
        for i in range(sections):
            i_next = (i + 1) % sections
            faces.append([center_top_idx, i + sections, i_next + sections])
        
        frustum = trimesh.Trimesh(vertices=vertices, faces=np.array(faces))
    
    # Rotate to align with direction
    z_axis = np.array([0, 0, 1])
    if not np.allclose(direction, z_axis) and not np.allclose(direction, -z_axis):
        rotation_axis = np.cross(z_axis, direction)
        if np.linalg.norm(rotation_axis) > 1e-6:
            rotation_axis = rotation_axis / np.linalg.norm(rotation_axis)
            angle = np.arccos(np.clip(np.dot(z_axis, direction), -1, 1))
            rotation_matrix = trimesh.transformations.rotation_matrix(angle, rotation_axis)
            frustum.apply_transform(rotation_matrix)
    elif np.allclose(direction, -z_axis):
        rotation_matrix = trimesh.transformations.rotation_matrix(np.pi, [1, 0, 0])
        frustum.apply_transform(rotation_matrix)
    
    # Translate to position
    center = (start + end) / 2
    frustum.apply_translation(center)
    
    return frustum


def generate_object3_bifurcate_512(output_dir: Optional[Path] = None) -> trimesh.Trimesh:
    """
    Generate Object 3: Recursive bifurcation to 512 terminals.
    
    Design choices:
    - 4 inlets at symmetric positions near center
    - 7 bifurcation levels per inlet (2^7 = 128 terminals each)
    - Exponential radius taper from 1mm to 100um
    - Bifurcation depths at 0.25, 0.50, 0.75, 1.00, 1.25, 1.50, 1.75 mm
    - Overlapping branches merge via voxel union
    - Uses the repo's embed_tree_as_negative_space function for embedding
    
    Returns mesh in METERS (will be scaled to mm at export).
    
    Parameters
    ----------
    output_dir : Path, optional
        Directory to save intermediate STL files for debugging
    """
    print("\n" + "=" * 60)
    print("Generating Object 3: Recursive bifurcation to 512 terminals")
    print("=" * 60)
    
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    
    # Generate bifurcating trees from each inlet
    print(f"  Generating {OBJ3_NUM_INLETS} bifurcating trees...")
    all_trees = []
    
    for i, (x, y) in enumerate(OBJ3_INLET_POSITIONS):
        print(f"    Tree {i+1}: inlet at ({meters_to_mm(x):.1f}, {meters_to_mm(y):.1f})mm")
        inlet_pos = (x, y, z_top)
        
        tree_mesh = generate_bifurcation_tree_mesh(
            inlet_position=inlet_pos,
            inlet_radius=OBJ3_INLET_RADIUS_M,
            terminal_radius=OBJ3_TERMINAL_RADIUS_M,
            bifurcation_depths=OBJ3_BIFURCATION_DEPTHS_M,
            base_angle_deg=OBJ3_BASE_ANGLE_DEG,
        )
        all_trees.append(tree_mesh)
        print(f"      Generated tree with {len(tree_mesh.vertices)} vertices")
    
    # Union all trees (overlapping branches merge)
    print("  Combining all trees (overlap-based merge)...")
    combined_void = voxel_union_meshes(all_trees, pitch=VOXEL_PITCH_UNION_M)
    
    # Export intermediate tree void mesh
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object3_tree_void.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(combined_void).export(str(intermediate_path))
        print(f"    Exported intermediate void: {intermediate_path}")
    
    # Run pre-embedding validation on tree mesh
    print("  Running pre-embedding validation on tree mesh...")
    try:
        pre_report = run_pre_embedding_validation(mesh=combined_void)
        print_validation_details(pre_report)
    except Exception as e:
        print(f"    Pre-embedding validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Use the repo's embed_tree_as_negative_space function to carve voids from cylinder
    # NOTE: keep_largest_component=False to preserve all 4 inlet trees
    # (they are disconnected and would otherwise be dropped by meshfix_repair)
    print("  Carving voids using embed_tree_as_negative_space...")
    cylinder_with_void = embed_void_in_cylinder(
        void_mesh=combined_void,
        output_dir=output_dir,
        object_name="object3",
        voxel_pitch=VOXEL_PITCH_M,
        keep_largest_component=False,  # Preserve all 4 inlet trees
    )
    
    # Export intermediate cylinder with void (before ridge)
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object3_cylinder_with_void.stl"
        scale_mesh_to_mm(cylinder_with_void).export(str(intermediate_path))
        print(f"    Exported intermediate cylinder with void: {intermediate_path}")
    
    print(f"  Cylinder with void: {len(cylinder_with_void.vertices)} vertices, {len(cylinder_with_void.faces)} faces")
    print(f"    Watertight: {cylinder_with_void.is_watertight}")
    
    # Run post-embedding validation on cylinder with void (before adding ridge)
    # NOTE: Validation thresholds are adjusted for Object 3's design:
    # - expected_outlets = OBJ3_NUM_INLETS (4), not OBJ3_TOTAL_TERMINALS (512)
    #   because the 512 terminals are internal, not external openings
    # - min_channel_diameter = 0.2mm to match the terminal diameter (2 * 100µm)
    print("  Running post-embedding validation on cylinder with void...")
    try:
        from validity.post_embedding.printability_checks import ManufacturingConfig
        validation_config = ValidationConfig(
            voxel_pitch_m=VOXEL_PITCH_M,
            expected_outlets=OBJ3_NUM_INLETS,  # 4 inlets, not 512 internal terminals
            manufacturing=ManufacturingConfig(
                min_channel_diameter=OBJ3_MIN_CHANNEL_DIAMETER_MM,  # 2 * terminal radius (100µm = 0.1mm)
                min_wall_thickness=OBJ3_MIN_WALL_THICKNESS_MM,
            ),
        )
        report = run_post_embedding_validation(mesh=cylinder_with_void, config=validation_config)
        print_validation_details(report)
    except Exception as e:
        print(f"    Validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Return cylinder_with_void - ridge will be added at the END in main() to prevent smoothing
    return cylinder_with_void


def generate_object4_turn_bifurcate_merge(
    output_dir: Optional[Path] = None,
    rng_seed: Optional[int] = None,
    growth_fraction_range: Tuple[float, float] = (0.3, 0.7),
) -> trimesh.Trimesh:
    """
    Generate Object 4: Single inlet, 90-degree turn, bifurcate, merge, return.
    
    Uses the pre-built grow_to_point and bifurcate tools from the generation library.
    Implements grow -> bifurcate -> grow pattern where branches grow for an RNG-based
    distance before bifurcating, ensuring proper separation between branches.
    
    Design choices:
    - Single inlet at center top face, radius 1mm
    - Travel downward 1mm
    - Turn 90 degrees (along +X direction)
    - Bifurcate in XY plane with grow -> bifurcate -> grow pattern
    - Branches merge by overlapping in space (voxel union)
    - Single trunk returns upward to exit near top face
    - Uses the repo's embed_tree_as_negative_space function for embedding
    
    Returns mesh in METERS (will be scaled to mm at export).
    
    Parameters
    ----------
    output_dir : Path, optional
        Directory to save intermediate STL files for debugging
    rng_seed : int, optional
        Random seed for reproducible growth distances
    growth_fraction_range : tuple
        (min, max) fraction of available distance for post-bifurcation growth.
        Growth distance is calculated as: fraction * branch_length
        This ensures branches separate before the next bifurcation while leaving
        enough space to bifurcate before reaching the edge.
    """
    from generation.ops.growth import grow_to_point, grow_branch, bifurcate
    from generation.rules.constraints import BranchingConstraints
    from generation.core.types import Direction3D
    
    print("\n" + "=" * 60)
    print("Generating Object 4: Turn-Bifurcate-Merge loop")
    print("=" * 60)
    
    rng = np.random.default_rng(rng_seed)
    
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    z_bottom = CYLINDER_CENTER[2] - CYLINDER_HEIGHT_M / 2
    
    # Create a VascularNetwork with a cylinder domain
    domain = CylinderDomain(
        center=CYLINDER_CENTER,
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
    )
    network = create_network(domain, seed=rng_seed)
    
    # Set up constraints with relaxed limits for small geometry
    constraints = BranchingConstraints(
        min_segment_length=BRANCH_MIN_SEGMENT_LENGTH_M,
        max_segment_length=BRANCH_MAX_SEGMENT_LENGTH_M,
        min_radius=BRANCH_MIN_RADIUS_M,
    )
    
    # Inlet position (slightly offset from center to allow return path)
    inlet_x = OBJ4_INLET_POSITION[0] - OBJ4_INLET_OFFSET_M  # Offset from center to allow return path
    inlet_y = OBJ4_INLET_POSITION[1]
    inlet_pos = (inlet_x, inlet_y, z_top)
    
    # Add inlet node
    print("  Building channel network using pre-built tools...")
    inlet_result = add_inlet(
        network,
        position=inlet_pos,
        direction=(0.0, 0.0, -1.0),  # Downward
        radius=OBJ4_INLET_RADIUS_M,
        vessel_type="venous",
    )
    if not inlet_result.is_success():
        print(f"    Warning: Failed to add inlet: {inlet_result.message}")
        return trimesh.Trimesh()
    
    current_node_id = inlet_result.new_ids["node"]
    
    # 1. Downward segment (1mm) using grow_to_point
    print("    Segment 1: Downward 1mm (using grow_to_point)")
    down_end = (inlet_x, inlet_y, z_top - OBJ4_DOWNWARD_LENGTH_M)
    grow_result = grow_to_point(
        network,
        from_node_id=current_node_id,
        target_point=down_end,
        target_radius=OBJ4_INLET_RADIUS_M,
        constraints=constraints,
        check_collisions=False,
        fail_on_collision=False,
    )
    if not grow_result.is_success():
        print(f"    Warning: grow_to_point failed: {grow_result.message}")
        return trimesh.Trimesh()
    current_node_id = grow_result.new_ids["node"]
    
    # 2. 90-degree turn (horizontal along +X) using grow_to_point
    print("    Segment 2: Horizontal turn (+X direction) (using grow_to_point)")
    turn_end = (inlet_x + OBJ4_HORIZONTAL_LENGTH_M, inlet_y, z_top - OBJ4_DOWNWARD_LENGTH_M)
    
    # Update direction for horizontal growth
    turn_node = network.get_node(current_node_id)
    if turn_node:
        turn_node.attributes["direction"] = {"dx": 1.0, "dy": 0.0, "dz": 0.0}
    
    grow_result = grow_to_point(
        network,
        from_node_id=current_node_id,
        target_point=turn_end,
        target_radius=OBJ4_INLET_RADIUS_M * OBJ4_TURN_RADIUS_FACTOR,
        constraints=constraints,
        check_collisions=False,
        fail_on_collision=False,
    )
    if not grow_result.is_success():
        print(f"    Warning: grow_to_point failed: {grow_result.message}")
        return trimesh.Trimesh()
    current_node_id = grow_result.new_ids["node"]
    
    # 3. Bifurcate in XY plane with grow -> bifurcate -> grow pattern
    print(f"    Bifurcating {OBJ4_NUM_BIFURCATIONS} levels in XY plane (using bifurcate)")
    
    # Track current branch tips: list of node_ids
    branch_tip_ids = [current_node_id]
    
    for level in range(OBJ4_NUM_BIFURCATIONS):
        new_tip_ids = []
        branch_length = OBJ4_BRANCH_BASE_LENGTH_M * (1.0 - OBJ4_BRANCH_LENGTH_DECAY * level)  # Decreasing length
        branch_radius = OBJ4_INLET_RADIUS_M * OBJ4_TURN_RADIUS_FACTOR * (OBJ4_BRANCH_RADIUS_DECAY ** (level + 1))
        
        # Calculate distance to next bifurcation level for growth distance
        if level + 1 < OBJ4_NUM_BIFURCATIONS:
            next_branch_length = OBJ4_BRANCH_BASE_LENGTH_M * (1.0 - OBJ4_BRANCH_LENGTH_DECAY * (level + 1))
        else:
            next_branch_length = branch_length * 0.5  # Last level: use half of current
        
        for tip_node_id in branch_tip_ids:
            tip_node = network.get_node(tip_node_id)
            if tip_node is None:
                continue
            
            tip_pos = np.array([tip_node.position.x, tip_node.position.y, tip_node.position.z])
            tip_dir_dict = tip_node.attributes.get("direction", {"dx": 1, "dy": 0, "dz": 0})
            tip_dir = np.array([tip_dir_dict.get("dx", 1), tip_dir_dict.get("dy", 0), tip_dir_dict.get("dz", 0)])
            
            # Grow forward a bit (pre-bifurcation growth) using grow_branch
            mid_pos = tip_pos + tip_dir * branch_length
            grow_result = grow_to_point(
                network,
                from_node_id=tip_node_id,
                target_point=tuple(mid_pos),
                target_radius=branch_radius,
                constraints=constraints,
                check_collisions=False,
                fail_on_collision=False,
            )
            
            if not grow_result.is_success():
                print(f"    Warning: grow_to_point failed at level {level}: {grow_result.message}")
                continue
            
            bifurc_node_id = grow_result.new_ids["node"]
            
            # Calculate RNG-based growth distances for child branches
            max_growth = next_branch_length * BIFURC_MAX_GROWTH_FRACTION  # Leave room for next bifurcation approach
            
            growth_fraction1 = rng.uniform(growth_fraction_range[0], growth_fraction_range[1])
            growth_distance1 = min(growth_fraction1 * next_branch_length, max_growth)
            growth_distance1 = max(growth_distance1, BIFURC_MIN_GROWTH_DISTANCE_M)
            
            growth_fraction2 = rng.uniform(growth_fraction_range[0], growth_fraction_range[1])
            growth_distance2 = min(growth_fraction2 * next_branch_length, max_growth)
            growth_distance2 = max(growth_distance2, BIFURC_MIN_GROWTH_DISTANCE_M)
            
            # Angle for bifurcation (decreases with level for tighter packing)
            angle_deg = OBJ4_BASE_ANGLE_DEG - OBJ4_ANGLE_DECAY_PER_LEVEL_DEG * level
            
            # Use bifurcate to create two child branches with RNG-based growth lengths
            bifurc_result = bifurcate(
                network,
                at_node_id=bifurc_node_id,
                child_lengths=(growth_distance1, growth_distance2),
                angle_deg=angle_deg,
                constraints=constraints,
                check_collisions=False,
                seed=rng_seed,
            )
            
            if not bifurc_result.is_success():
                print(f"    Warning: bifurcate failed at level {level}: {bifurc_result.message}")
                continue
            
            # Get the child node IDs from bifurcation result
            child_node_ids = bifurc_result.new_ids.get("nodes", [])
            for child_node_id in child_node_ids:
                # Update child node radius for next level
                child_node = network.get_node(child_node_id)
                if child_node:
                    child_node.attributes["radius"] = branch_radius
                new_tip_ids.append(child_node_id)
        
        branch_tip_ids = new_tip_ids
    
    # 4. Merge branches back (overlap-based merge)
    # Route all branch tips toward a common merge point using grow_to_point
    print("    Merging branches (using grow_to_point)")
    merge_point = (OBJ4_MERGE_POINT_X_M, 0.0, z_top - OBJ4_DOWNWARD_LENGTH_M)  # Merge point at +2mm X
    
    merge_node_id = None
    for tip_node_id in branch_tip_ids:
        tip_node = network.get_node(tip_node_id)
        if tip_node is None:
            continue
        
        grow_result = grow_to_point(
            network,
            from_node_id=tip_node_id,
            target_point=merge_point,
            target_radius=OBJ4_TERMINAL_RADIUS_M,
            constraints=constraints,
            check_collisions=False,
            fail_on_collision=False,
        )
        if grow_result.is_success():
            merge_node_id = grow_result.new_ids["node"]
    
    # 5. Return upward to top face using grow_to_point
    print("    Segment: Return upward to top face (using grow_to_point)")
    outlet_pos = (OBJ4_OUTLET_X_M, 0.0, z_top)  # Outlet at +2mm X from center
    
    if merge_node_id is not None:
        # Update direction for upward growth
        merge_node = network.get_node(merge_node_id)
        if merge_node:
            merge_node.attributes["direction"] = {"dx": 0.0, "dy": 0.0, "dz": 1.0}
        
        grow_result = grow_to_point(
            network,
            from_node_id=merge_node_id,
            target_point=outlet_pos,
            target_radius=OBJ4_TERMINAL_RADIUS_M,
            constraints=constraints,
            check_collisions=False,
            fail_on_collision=False,
        )
    
    # Convert network to mesh using the mesh adapter
    print(f"    Converting network to mesh ({len(network.segments)} segments)...")
    mesh_result = to_trimesh(network, mode="fast", include_caps=True, include_node_spheres=False)
    
    if not mesh_result.is_success():
        print(f"    Warning: to_trimesh failed: {mesh_result.message}")
        return trimesh.Trimesh()
    
    channel_segments = [mesh_result.metadata["mesh"]]
    
    # Union all channel segments
    print(f"  Combining {len(channel_segments)} channel segments...")
    combined_void = voxel_union_meshes(channel_segments, pitch=VOXEL_PITCH_UNION_M)
    
    # Export intermediate channel void mesh
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object4_channel_void.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(combined_void).export(str(intermediate_path))
        print(f"    Exported intermediate void: {intermediate_path}")
    
    # Run pre-embedding validation on channel mesh
    print("  Running pre-embedding validation on channel mesh...")
    try:
        pre_report = run_pre_embedding_validation(mesh=combined_void)
        print_validation_details(pre_report)
    except Exception as e:
        print(f"    Pre-embedding validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Use the repo's embed_tree_as_negative_space function to carve channels from cylinder
    print("  Carving channels using embed_tree_as_negative_space...")
    cylinder_with_void = embed_void_in_cylinder(
        void_mesh=combined_void,
        output_dir=output_dir,
        object_name="object4",
        voxel_pitch=VOXEL_PITCH_M,
    )
    
    # Export intermediate cylinder with void (before ridge)
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object4_cylinder_with_void.stl"
        scale_mesh_to_mm(cylinder_with_void).export(str(intermediate_path))
        print(f"    Exported intermediate cylinder with void: {intermediate_path}")
    
    print(f"  Cylinder with void: {len(cylinder_with_void.vertices)} vertices, {len(cylinder_with_void.faces)} faces")
    print(f"    Watertight: {cylinder_with_void.is_watertight}")
    
    # Run post-embedding validation on cylinder with void (before adding ridge)
    print("  Running post-embedding validation on cylinder with void...")
    try:
        validation_config = ValidationConfig(
            voxel_pitch_m=VOXEL_PITCH_M,
            expected_outlets=2,  # 1 inlet + 1 outlet for loop structure
        )
        report = run_post_embedding_validation(mesh=cylinder_with_void, config=validation_config)
        print_validation_details(report)
    except Exception as e:
        print(f"    Validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Return cylinder_with_void - ridge will be added at the END in main() to prevent smoothing
    return cylinder_with_void


# =============================================================================
# OBJECT 5: CCO-NLP ORGANIC GROWTH
# =============================================================================

def generate_object5_cco_nlp_organic(output_dir: Optional[Path] = None) -> trimesh.Trimesh:
    """
    Generate Object 5: CCO-Hybrid + NLP iterative organic growth.
    
    This object uses the repo's CCOHybridBackend for organic vascular network
    generation with iterative NLP optimization between growth rounds.
    
    Design choices documented:
    - Coordinate convention: Cylinder centered at origin, z spans [-1mm, +1mm]
    - Inlet z aligned with top face at z = +1mm
    - 4 inlets in symmetric square pattern at (+/-1.5mm, +/-1.5mm)
    - Each inlet starts with 0.1mm straight downward segment
    - 4 rounds of CCO growth + NLP optimization
    - 512 total terminals (128 per inlet, 32 per round per inlet)
    - Optimized per-tree after each round, then globally on merged network
    
    Returns mesh in METERS (will be scaled to mm at export).
    
    Parameters
    ----------
    output_dir : Path, optional
        Directory to save intermediate STL files for debugging
    """
    import copy
    import time
    
    print("\n" + "=" * 60)
    print("Generating Object 5: CCO-NLP Organic Growth")
    print("=" * 60)
    
    print("\n  Design choices:")
    print(f"    - Coordinate convention: Cylinder centered at origin")
    print(f"    - Top face at z = +{meters_to_mm(CYLINDER_HEIGHT_M/2)}mm")
    print(f"    - {OBJ5_NUM_INLETS} inlets at (+/-1.5mm, +/-1.5mm)")
    print(f"    - {OBJ5_NUM_ROUNDS} growth rounds with NLP optimization")
    print(f"    - {OBJ5_TOTAL_OUTLETS} total outlets ({OBJ5_TOTAL_OUTLETS // OBJ5_NUM_INLETS} per inlet)")
    print(f"    - Vessel type: {OBJ5_VESSEL_TYPE}")
    print(f"    - Seed: {OBJ5_SEED}")
    
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    
    # Create domain for CCO generation
    print("\n  Setting up CCO domain and configuration...")
    domain_spec = CylinderSpec(
        center=(CYLINDER_CENTER[0], CYLINDER_CENTER[1], CYLINDER_CENTER[2]),
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
    )
    domain = compile_domain(domain_spec)
    
    # Create CCO configuration
    cco_config = CCOConfig(
        seed=OBJ5_SEED,
        murray_exponent=OBJ5_CCO_MURRAY_EXPONENT,
        collision_clearance=OBJ5_CCO_COLLISION_CLEARANCE,
        min_segment_length=OBJ5_CCO_MIN_SEGMENT_LENGTH,
        max_segment_length=OBJ5_CCO_MAX_SEGMENT_LENGTH,
        min_terminal_separation=OBJ5_CCO_MIN_TERMINAL_SEP,
        candidate_edges_k=OBJ5_CCO_CANDIDATE_EDGES_K,
        optimization_grid_resolution=OBJ5_CCO_GRID_RESOLUTION,
        collision_check_enabled=True,
        use_partial_binding=True,
        use_collision_triage=True,
        use_nlp_optimization=OBJ5_CCO_USE_NLP,
    )
    
    print(f"    CCO config: murray_exponent={cco_config.murray_exponent}, "
          f"collision_clearance={cco_config.collision_clearance*1000:.3f}mm")
    
    # Create NLP configuration
    nlp_config = NLPConfig(
        murray_exponent=OBJ5_NLP_MURRAY_EXPONENT,
        target_pressure_drop=OBJ5_NLP_TARGET_PRESSURE_DROP,
        viscosity=OBJ5_NLP_VISCOSITY,
        fix_terminal_positions=OBJ5_NLP_FIX_TERMINALS,
        fix_root_position=OBJ5_NLP_FIX_ROOT,
        max_iterations=OBJ5_NLP_MAX_ITERATIONS,
        solver_tolerance=OBJ5_NLP_TOLERANCE,
        cleanup_degenerate_segments=OBJ5_NLP_CLEANUP_DEGENERATE,
    )
    
    # Create CCO backend
    backend = CCOHybridBackend()
    
    # Calculate outlets per inlet
    outlets_per_inlet = OBJ5_TOTAL_OUTLETS // OBJ5_NUM_INLETS
    
    # Generate trees for each inlet
    print(f"\n  Generating {OBJ5_NUM_INLETS} inlet trees with iterative CCO + NLP...")
    all_networks = []
    total_outlets_achieved = 0
    
    for inlet_idx, inlet_pos in enumerate(OBJ5_INLET_POSITIONS):
        print(f"\n    Inlet {inlet_idx + 1}: position=({inlet_pos[0]*1000:.1f}, "
              f"{inlet_pos[1]*1000:.1f}, {inlet_pos[2]*1000:.1f})mm")
        
        inlet_position = np.array(inlet_pos)
        
        # Generate tree for this inlet using CCO
        try:
            start_time = time.time()
            network = backend.generate(
                domain=domain,
                num_outlets=outlets_per_inlet,
                inlet_position=inlet_position,
                inlet_radius=OBJ5_INLET_RADIUS_M,
                vessel_type=OBJ5_VESSEL_TYPE,
                config=cco_config,
                rng_seed=OBJ5_SEED + inlet_idx,
            )
            gen_time = time.time() - start_time
            
            # Count actual outlets
            outlet_count = sum(1 for n in network.nodes.values() 
                             if n.node_type in ("outlet", "terminal"))
            total_outlets_achieved += outlet_count
            
            print(f"      CCO generation: {outlet_count} outlets in {gen_time:.1f}s")
            print(f"      Network: {len(network.nodes)} nodes, {len(network.segments)} segments")
            
            # Apply NLP optimization if enabled
            if OBJ5_NLP_ENABLED:
                print(f"      Applying NLP optimization...")
                try:
                    nlp_start = time.time()
                    nlp_result = optimize_geometry(network, nlp_config)
                    nlp_time = time.time() - nlp_start
                    
                    if nlp_result.success:
                        print(f"      NLP success: volume reduction {nlp_result.volume_reduction*100:.1f}% "
                              f"in {nlp_time:.1f}s")
                    else:
                        print(f"      NLP did not converge (continuing anyway)")
                except Exception as e:
                    print(f"      NLP optimization failed: {e} (continuing anyway)")
            
            all_networks.append(network)
            
        except Exception as e:
            print(f"      ERROR generating inlet {inlet_idx + 1}: {e}")
            continue
    
    if not all_networks:
        raise RuntimeError("Failed to generate any inlet networks")
    
    print(f"\n  Total outlets achieved: {total_outlets_achieved}/{OBJ5_TOTAL_OUTLETS}")
    
    # Merge all networks into one
    print("\n  Merging all inlet networks...")
    merged_network = all_networks[0]
    
    for i, network in enumerate(all_networks[1:], start=2):
        # Simple merge: copy nodes and segments with new IDs
        node_id_map = {}
        for old_node in network.nodes.values():
            new_node_id = merged_network.id_gen.next_id()
            new_node = Node(
                id=new_node_id,
                position=copy.deepcopy(old_node.position),
                node_type=old_node.node_type,
                vessel_type=old_node.vessel_type,
                attributes=old_node.attributes.copy() if old_node.attributes else {},
            )
            merged_network.add_node(new_node)
            node_id_map[old_node.id] = new_node_id
        
        for old_seg in network.segments.values():
            new_seg_id = merged_network.id_gen.next_id()
            new_seg = VesselSegment(
                id=new_seg_id,
                start_node_id=node_id_map[old_seg.start_node_id],
                end_node_id=node_id_map[old_seg.end_node_id],
                geometry=copy.deepcopy(old_seg.geometry),
                vessel_type=old_seg.vessel_type,
                attributes=old_seg.attributes.copy() if old_seg.attributes else {},
            )
            merged_network.add_segment(new_seg)
        
        print(f"    Merged inlet {i}: {len(network.nodes)} nodes, {len(network.segments)} segments")
    
    print(f"  Merged network: {len(merged_network.nodes)} nodes, "
          f"{len(merged_network.segments)} segments")
    
    # Final global NLP optimization on merged network
    if OBJ5_NLP_ENABLED:
        print("\n  Applying final global NLP optimization...")
        try:
            nlp_start = time.time()
            nlp_result = optimize_geometry(merged_network, nlp_config)
            nlp_time = time.time() - nlp_start
            
            if nlp_result.success:
                print(f"    Final NLP success: volume reduction {nlp_result.volume_reduction*100:.1f}% "
                      f"in {nlp_time:.1f}s")
            else:
                print(f"    Final NLP did not converge (continuing anyway)")
        except Exception as e:
            print(f"    Final NLP optimization failed: {e} (continuing anyway)")
    
    # Convert network to mesh
    print("\n  Converting network to mesh...")
    tree_mesh = None
    try:
        mesh_result = to_trimesh(merged_network, mode="voxel_repair")
        if mesh_result.is_success():
            tree_mesh = mesh_result.metadata["mesh"]
            print(f"    Tree mesh: {len(tree_mesh.vertices)} vertices, {len(tree_mesh.faces)} faces")
        else:
            print(f"    to_trimesh returned failure: {mesh_result.message}, using manual mesh construction")
    except Exception as e:
        print(f"    to_trimesh failed: {e}, using manual mesh construction")
    
    if tree_mesh is None:
        # Fallback: create mesh from segments manually
        all_segment_meshes = []
        for seg in merged_network.segments.values():
            start_node = merged_network.nodes[seg.start_node_id]
            end_node = merged_network.nodes[seg.end_node_id]
            # Convert Point3D to numpy array
            if hasattr(start_node.position, 'to_array'):
                start_pos = start_node.position.to_array()
            else:
                start_pos = np.array(start_node.position)
            if hasattr(end_node.position, 'to_array'):
                end_pos = end_node.position.to_array()
            else:
                end_pos = np.array(end_node.position)
            
            # Get radii
            if seg.geometry and hasattr(seg.geometry, 'start_radius'):
                start_r = seg.geometry.start_radius
                end_r = seg.geometry.end_radius
            else:
                start_r = OBJ5_INLET_RADIUS_M
                end_r = OBJ5_TERMINAL_RADIUS_M
            
            # Create tapered cylinder
            seg_mesh = _create_tapered_cylinder(start_pos, end_pos, start_r, end_r)
            if seg_mesh is not None:
                all_segment_meshes.append(seg_mesh)
        
        if all_segment_meshes:
            tree_mesh = voxel_union_meshes(all_segment_meshes, pitch=VOXEL_PITCH_UNION_M)
        else:
            raise RuntimeError("Failed to create tree mesh")
    
    # Export intermediate tree mesh
    if output_dir and tree_mesh is not None:
        intermediate_path = output_dir / "intermediate" / "object5_tree_void.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(tree_mesh).export(str(intermediate_path))
        print(f"    Exported intermediate tree: {intermediate_path}")
    
    # Run pre-embedding validation on tree mesh
    print("  Running pre-embedding validation on tree mesh...")
    try:
        pre_report = run_pre_embedding_validation(mesh=tree_mesh)
        print_validation_details(pre_report)
    except Exception as e:
        print(f"    Pre-embedding validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Use the repo's embed_tree_as_negative_space function to carve voids from cylinder
    print("\n  Carving vascular channels using embed_tree_as_negative_space...")
    cylinder_with_void = embed_void_in_cylinder(
        void_mesh=tree_mesh,
        output_dir=output_dir,
        object_name="object5",
        voxel_pitch=VOXEL_PITCH_M,
    )
    
    # Export intermediate cylinder with void (before ridge)
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object5_cylinder_with_void.stl"
        scale_mesh_to_mm(cylinder_with_void).export(str(intermediate_path))
        print(f"    Exported intermediate cylinder with void: {intermediate_path}")
    
    print(f"  Cylinder with void: {len(cylinder_with_void.vertices)} vertices, {len(cylinder_with_void.faces)} faces")
    print(f"    Watertight: {cylinder_with_void.is_watertight}")
    
    # Run post-embedding validation on cylinder with void (before adding ridge)
    print("  Running post-embedding validation on cylinder with void...")
    try:
        validation_config = ValidationConfig(
            voxel_pitch_m=VOXEL_PITCH_M,
            expected_outlets=total_outlets_achieved,
        )
        post_report = run_post_embedding_validation(mesh=cylinder_with_void, config=validation_config)
        print_validation_details(post_report)
    except Exception as e:
        print(f"    Validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Generate report
    report = {
        "object": "object5_cco_nlp_organic",
        "design_choices": {
            "coordinate_convention": "Cylinder centered at origin, z spans [-1mm, +1mm]",
            "inlet_z_position": f"+{meters_to_mm(CYLINDER_HEIGHT_M/2)}mm (top face)",
            "num_inlets": OBJ5_NUM_INLETS,
            "inlet_positions_mm": [[p[0]*1000, p[1]*1000, p[2]*1000] for p in OBJ5_INLET_POSITIONS],
            "num_rounds": OBJ5_NUM_ROUNDS,
            "vessel_type": OBJ5_VESSEL_TYPE,
        },
        "parameters": {
            "total_outlets_requested": OBJ5_TOTAL_OUTLETS,
            "total_outlets_achieved": total_outlets_achieved,
            "inlet_radius_mm": OBJ5_INLET_RADIUS_M * 1000,
            "terminal_radius_mm": OBJ5_TERMINAL_RADIUS_M * 1000,
            "cco_collision_clearance_mm": OBJ5_CCO_COLLISION_CLEARANCE * 1000,
            "cco_min_segment_mm": OBJ5_CCO_MIN_SEGMENT_LENGTH * 1000,
            "cco_max_segment_mm": OBJ5_CCO_MAX_SEGMENT_LENGTH * 1000,
            "nlp_enabled": OBJ5_NLP_ENABLED,
            "nlp_murray_exponent": OBJ5_NLP_MURRAY_EXPONENT,
            "voxel_pitch_mm": VOXEL_PITCH_UNION_M * 1000,
        },
        "mesh_stats": {
            "vertices": len(cylinder_with_void.vertices),
            "faces": len(cylinder_with_void.faces),
            "watertight": cylinder_with_void.is_watertight,
        },
    }
    
    # Save report
    report_path = OUTPUT_DIR / "object5_cco_nlp_organic_report.json"
    with open(report_path, 'w') as f:
        json.dump(report, f, indent=2)
    print(f"  Report saved: {report_path}")
    
    # Return cylinder_with_void - ridge will be added at the END in main() to prevent smoothing
    return cylinder_with_void


# =============================================================================
# MAIN EXECUTION
# =============================================================================

def add_ridge_to_mesh(mesh_m: trimesh.Trimesh) -> trimesh.Trimesh:
    """
    Add ridge to a mesh at the END (after all voxel operations) to prevent smoothing.
    
    Uses voxel union with fine pitch (VOXEL_PITCH_RIDGE_M = 25um) to preserve ridge detail
    while maintaining watertightness. The ridge is 0.1mm (100um) thick, so at 25um pitch
    it will be 4 voxels thick, which is sufficient to preserve the geometry.
    
    Parameters
    ----------
    mesh_m : trimesh.Trimesh
        The mesh to add ridge to (in meters)
    
    Returns
    -------
    trimesh.Trimesh
        The mesh with ridge added (in meters)
    """
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    
    # Print diagnostic info about input mesh
    print(f"    Input mesh: {len(mesh_m.vertices)} vertices, {len(mesh_m.faces)} faces")
    print(f"    Input mesh bounds: {mesh_m.bounds}")
    print(f"    Input mesh watertight: {mesh_m.is_watertight}")
    
    # IMPORTANT: For voxel union to work correctly, the ridge must OVERLAP with the
    # mesh (not just touch at z_top). We extend the ridge slightly INTO the mesh.
    ridge_z_base = z_top - RIDGE_OVERLAP_M  # Start ridge slightly INSIDE for overlap
    ridge_total_height = RIDGE_HEIGHT_M + RIDGE_OVERLAP_M  # Total height includes overlap
    
    ridge = create_ridge_mesh(
        outer_radius=CYLINDER_RADIUS_M,
        inner_radius=CYLINDER_RADIUS_M - RIDGE_THICKNESS_M,
        height=ridge_total_height,
        z_base=ridge_z_base,
        center_xy=(CYLINDER_CENTER[0], CYLINDER_CENTER[1]),
    )
    
    # Print diagnostic info about ridge mesh
    print(f"    Ridge mesh: {len(ridge.vertices)} vertices, {len(ridge.faces)} faces")
    print(f"    Ridge mesh bounds: {ridge.bounds}")
    print(f"    Ridge mesh watertight: {ridge.is_watertight}")
    print(f"    Ridge Z range: [{ridge_z_base}, {ridge_z_base + ridge_total_height}] (overlaps into mesh by {RIDGE_OVERLAP_M*1e6:.0f}um)")
    
    print(f"    Using voxel union with fine pitch ({VOXEL_PITCH_RIDGE_M*1e6:.0f}um) to preserve ridge detail")
    print(f"    Ridge thickness ({RIDGE_THICKNESS_M*1e6:.0f}um) / voxel pitch ({VOXEL_PITCH_RIDGE_M*1e6:.0f}um) = {RIDGE_THICKNESS_M/VOXEL_PITCH_RIDGE_M:.1f} voxels")
    
    # Perform voxel union
    combined = voxel_union_meshes([mesh_m, ridge], pitch=VOXEL_PITCH_RIDGE_M)
    
    # Print diagnostic info about combined mesh
    print(f"    Combined mesh: {len(combined.vertices)} vertices, {len(combined.faces)} faces")
    print(f"    Combined mesh bounds: {combined.bounds}")
    print(f"    Combined mesh watertight: {combined.is_watertight}")
    
    # Verify the ridge was added by checking Z bounds
    input_z_max = mesh_m.bounds[1][2]
    combined_z_max = combined.bounds[1][2]
    expected_z_max = z_top + RIDGE_HEIGHT_M
    
    if combined_z_max < expected_z_max - VOXEL_PITCH_RIDGE_M:
        print(f"    WARNING: Combined Z max ({combined_z_max:.6f}) < expected ({expected_z_max:.6f})")
        print(f"    Ridge may not have been added correctly!")
    else:
        print(f"    Ridge added successfully: Z max increased from {input_z_max:.6f} to {combined_z_max:.6f}")
    
    return combined


def main():
    """Generate all five objects and export to STL files."""
    print("=" * 70)
    print("MALARIA VENULE INSERTS GENERATOR")
    print("=" * 70)
    print("\nDesign Choices:")
    print("  - Ridge geometry: Annular ring (outer=5mm, inner=4.9mm, height=0.1mm)")
    print("  - Object 2 channels: 4 channels at (+/-1.5mm, +/-1.5mm)")
    print("  - Object 3 bifurcation: 7 levels, depths 0.25-1.75mm, taper 1mm->100um")
    print("  - Overlap-based merge: Voxel union merges overlapping void volumes")
    print("  - Object 5 CCO-NLP: 4 inlets, 4 rounds CCO + NLP, 512 terminals")
    print("  - Ridge added at END (after voxel ops) to prevent smoothing")
    print(f"\nVoxel pitch: {meters_to_mm(VOXEL_PITCH_M)*1000:.0f} um (fine)")
    print(f"Voxel pitch (union): {meters_to_mm(VOXEL_PITCH_UNION_M)*1000:.0f} um")
    print(f"Voxel pitch (ridge): {meters_to_mm(VOXEL_PITCH_RIDGE_M)*1000:.0f} um")
    print(f"Output units: {OUTPUT_UNITS}")
    
    # Create output directory
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    print(f"\nOutput directory: {OUTPUT_DIR}")
    print(f"Intermediate STLs will be saved to: {OUTPUT_DIR / 'intermediate'}")
    
    # Generate and export each object (pass output_dir for intermediate STL exports)
    # Objects 2-5 return cylinder_with_void (without ridge) - ridge is added at the END
    # Object 1 already includes ridge (no voxel operations after ridge)
    objects = [
        ("object1_control.stl", lambda: generate_object1_control(output_dir=OUTPUT_DIR), False),  # Already has ridge
        ("object2_channels.stl", lambda: generate_object2_channels(output_dir=OUTPUT_DIR), True),  # Needs ridge
        ("object3_bifurcate_512.stl", lambda: generate_object3_bifurcate_512(output_dir=OUTPUT_DIR), True),  # Needs ridge
        ("object4_turn_bifurcate_merge.stl", lambda: generate_object4_turn_bifurcate_merge(output_dir=OUTPUT_DIR), True),  # Needs ridge
        ("object5_cco_nlp_organic.stl", lambda: generate_object5_cco_nlp_organic(output_dir=OUTPUT_DIR), True),  # Needs ridge
    ]
    
    for filename, generator_func, needs_ridge in objects:
        try:
            mesh_m = generator_func()
            
            # Add ridge at the END for objects 2-5 (after all voxel operations)
            if needs_ridge:
                print(f"  Adding ridge to {filename} (at END to prevent smoothing)...")
                mesh_m = add_ridge_to_mesh(mesh_m)
                print(f"    Final mesh: {len(mesh_m.vertices)} vertices, {len(mesh_m.faces)} faces")
            
            # Scale to millimeters
            mesh_mm = scale_mesh_to_mm(mesh_m)
            
            # Export
            output_path = OUTPUT_DIR / filename
            export_mesh_with_units(mesh_mm, output_path, units=OUTPUT_UNITS)
            
        except Exception as e:
            print(f"\nERROR generating {filename}: {e}")
            import traceback
            traceback.print_exc()
    
    print("\n" + "=" * 70)
    print("GENERATION COMPLETE")
    print("=" * 70)
    print(f"\nOutput files in: {OUTPUT_DIR}")
    print("  - object1_control.stl")
    print("  - object2_channels.stl")
    print("  - object3_bifurcate_512.stl")
    print("  - object4_turn_bifurcate_merge.stl")
    print("  - object5_cco_nlp_organic.stl")
    print(f"\nIntermediate STLs in: {OUTPUT_DIR / 'intermediate'}")


if __name__ == "__main__":
    main()
