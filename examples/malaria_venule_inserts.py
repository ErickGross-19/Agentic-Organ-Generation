#!/usr/bin/env python3
"""
Malaria Venule Inserts Generator

This module generates five STL files for malaria venule insert scaffolds:
1. Object 1 (Control): Solid cylinder with ridge, no internal voids
2. Object 2 (Control + Channels): Control with 4 straight channels
3. Object 3 (Bifurcation 512): 4 inlets with recursive bifurcation to 512 terminals
4. Object 4 (Turn-Bifurcate-Merge): Single inlet with 90-degree turn, bifurcation, merge, return
5. Object 5 (CCO-NLP Organic): 4 inlets with CCO hybrid growth + NLP iterative optimization

DESIGN CHOICES DOCUMENTED:
- Ridge geometry: Annular ring on perimeter (outer_radius=5mm, inner_radius=4.9mm)
  Fallback: Solid raised disk if ring creation fails
- Object 2 channel count: 4 channels (minimum specified)
- Object 2 channel placement: Square pattern at (+/-1.5mm, +/-1.5mm) from center
- Object 3 bifurcation depths: 0.25, 0.50, 0.75, 1.00, 1.25, 1.50, 1.75 mm from top
- Object 3 branch taper: Exponential from 1mm to 100um over 7 levels
- Overlap-based merge strategy: Voxel union merges overlapping void volumes
- Object 5 CCO-NLP: 4 rounds of CCO growth + NLP optimization, 512 total terminals
  - Coordinate convention: Cylinder centered at origin, z spans [-1mm, +1mm]
  - Inlet z aligned with top face at z = +1mm
  - Optimized per-tree after each round, then globally on merged network

UNITS:
- Internal computations: METERS
- Output STL files: MILLIMETERS (scaled at export)

Author: Generated by Agentic Organ Generation System
"""

import sys
import os
import math
import json
import numpy as np
import trimesh
from pathlib import Path
from typing import List, Tuple, Optional, Dict, Any
from dataclasses import dataclass

# Add parent directory to path for imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from generation.core.domain import CylinderDomain
from generation.core.types import Point3D, Direction3D, TubeGeometry
from generation.core.network import VascularNetwork, Node, VesselSegment
from generation.ops.build import create_network, add_inlet
from generation.ops.growth import grow_branch, grow_to_point
from generation.adapters.mesh_adapter import to_trimesh, export_stl
from generation.ops.embedding import embed_tree_as_negative_space
from generation.rules.constraints import BranchingConstraints

# Additional imports for Object 5 (CCO-NLP)
from generation.specs.design_spec import DesignSpec, CylinderSpec, TreeSpec, InletSpec
from generation.specs.compile import compile_domain
from generation.backends.cco_hybrid_backend import CCOHybridBackend, CCOConfig
from generation.optimization import optimize_geometry, NLPConfig


# =============================================================================
# HARDCODED PARAMETERS - All dimensions in METERS internally
# =============================================================================

# --- Base Cylinder Parameters (shared by all objects) ---
CYLINDER_RADIUS_M = 0.005          # 5 mm radius = 10 mm diameter
CYLINDER_HEIGHT_M = 0.002          # 2 mm height
CYLINDER_CENTER = (0.0, 0.0, 0.0)  # Centered at origin

# --- Ridge Parameters (shared by all objects) ---
RIDGE_HEIGHT_M = 0.0001            # 0.1 mm ridge height
RIDGE_THICKNESS_M = 0.0001         # 0.1 mm ridge thickness (annular ring width)
# Ridge interpretation: Annular ring on perimeter
# - Outer radius = CYLINDER_RADIUS_M (5.0 mm)
# - Inner radius = CYLINDER_RADIUS_M - RIDGE_THICKNESS_M (4.9 mm)
# - Z range = [+1.0 mm, +1.1 mm] (top of cylinder to top of ridge)

# =============================================================================
# OBJECT 1: Control (solid cylinder + ridge, no channels)
# =============================================================================
# Object 1 has no inlets or terminals - it's a solid control sample
OBJ1_NUM_INLETS = 0                # No inlets (solid control)
OBJ1_INLET_RADIUS_M = None         # N/A for solid control
OBJ1_TERMINAL_RADIUS_M = None      # N/A for solid control

# =============================================================================
# OBJECT 2: Straight Channels
# =============================================================================
OBJ2_NUM_INLETS = 4                # 4 straight channels (range 4-9, using minimum)
OBJ2_INLET_RADIUS_M = 0.001        # 1 mm channel/inlet radius
OBJ2_TERMINAL_RADIUS_M = 0.001     # 1 mm (same as inlet - no taper for straight channels)
OBJ2_CHANNEL_DEPTH_M = 0.001       # 1 mm channel depth (extends downward from top)
OBJ2_CHANNEL_OFFSET_M = 0.0015     # 1.5 mm offset from center for channel placement
OBJ2_WALL_MARGIN_M = 0.0005        # 0.5 mm minimum wall margin from cylinder edge
# Inlet positions for Object 2 (symmetric near center)
OBJ2_INLET_POSITIONS = [
    (0.0015, 0.0015),   # +1.5mm, +1.5mm
    (-0.0015, 0.0015),  # -1.5mm, +1.5mm
    (-0.0015, -0.0015), # -1.5mm, -1.5mm
    (0.0015, -0.0015),  # +1.5mm, -1.5mm
]

# =============================================================================
# OBJECT 3: Recursive Bifurcation (512 terminals)
# =============================================================================
OBJ3_NUM_INLETS = 4                # 4 inlet channels
OBJ3_INLET_RADIUS_M = 0.001        # 1 mm inlet radius
OBJ3_TERMINAL_RADIUS_M = 0.0001    # 100 um terminal radius
OBJ3_TOTAL_TERMINALS = 512         # Total terminal count
OBJ3_TERMINALS_PER_INLET = 128     # 512 / 4 = 128 terminals per inlet
OBJ3_BIFURCATION_LEVELS = 7        # 2^7 = 128 terminals per inlet
# Bifurcation depth schedule (mm from top face, converted to meters)
OBJ3_BIFURCATION_DEPTHS_M = [
    0.00025,  # 0.25 mm
    0.00050,  # 0.50 mm
    0.00075,  # 0.75 mm
    0.00100,  # 1.00 mm
    0.00125,  # 1.25 mm
    0.00150,  # 1.50 mm
    0.00175,  # 1.75 mm
]
# Inlet positions for Object 3 (symmetric near center)
OBJ3_INLET_POSITIONS = [
    (0.0015, 0.0015),   # +1.5mm, +1.5mm
    (-0.0015, 0.0015),  # -1.5mm, +1.5mm
    (-0.0015, -0.0015), # -1.5mm, -1.5mm
    (0.0015, -0.0015),  # +1.5mm, -1.5mm
]

# =============================================================================
# OBJECT 4: Turn-Bifurcate-Merge Loop
# =============================================================================
OBJ4_NUM_INLETS = 1                # Single inlet for loop structure
OBJ4_INLET_RADIUS_M = 0.001        # 1 mm inlet radius
OBJ4_TERMINAL_RADIUS_M = 0.0005    # 500 um terminal radius (before merge back)
OBJ4_DOWNWARD_LENGTH_M = 0.001     # 1 mm downward travel before turn
OBJ4_HORIZONTAL_LENGTH_M = 0.001   # 1 mm horizontal travel after turn
OBJ4_NUM_BIFURCATIONS = 3          # Number of bifurcation levels in lateral plane
OBJ4_MERGE_OVERLAP_M = 0.0005      # 0.5 mm overlap for merge region
# Inlet position for Object 4 (center of top face)
OBJ4_INLET_POSITION = (0.0, 0.0)   # Center of cylinder

# =============================================================================
# OBJECT 5: CCO-NLP Organic Growth
# =============================================================================
# Coordinate convention: Cylinder centered at origin, z spans [-1mm, +1mm]
# Top face at z = +1mm = +0.001m
OBJ5_NUM_INLETS = 4                # 4 inlet channels
OBJ5_INLET_RADIUS_M = 0.001        # 1 mm inlet radius
OBJ5_TERMINAL_RADIUS_M = 0.0001    # 100 um terminal radius (minimum)
OBJ5_TOTAL_OUTLETS = 512           # Total terminal outlets (128 per inlet)
OBJ5_NUM_ROUNDS = 4                # Number of CCO growth rounds
OBJ5_OUTLETS_PER_ROUND = 32        # 512 / 4 inlets / 4 rounds = 32 per round per inlet
OBJ5_STRAIGHT_DOWN_M = 0.0001      # 0.1 mm straight down before CCO growth
OBJ5_VESSEL_TYPE = "venous"        # Vessel type for inserts
OBJ5_SEED = 42                     # Random seed for reproducibility
# Inlet positions for Object 5 (symmetric square at +/-1.5mm, at top face z=+1mm)
OBJ5_INLET_POSITIONS = [
    (0.0015, 0.0015, 0.001),    # +1.5mm, +1.5mm, +1mm (top face)
    (0.0015, -0.0015, 0.001),   # +1.5mm, -1.5mm, +1mm
    (-0.0015, 0.0015, 0.001),   # -1.5mm, +1.5mm, +1mm
    (-0.0015, -0.0015, 0.001),  # -1.5mm, -1.5mm, +1mm
]
# CCO configuration parameters (tuned for tiny domain)
OBJ5_CCO_COLLISION_CLEARANCE = 5e-5    # 50 um collision clearance
OBJ5_CCO_MIN_SEGMENT_LENGTH = 2e-4     # 200 um minimum segment
OBJ5_CCO_MAX_SEGMENT_LENGTH = 2e-3     # 2 mm maximum segment (within 2mm height)
OBJ5_CCO_MIN_TERMINAL_SEP = 5e-5       # 50 um between terminals
OBJ5_CCO_CANDIDATE_EDGES_K = 50        # Candidate edges for optimization
OBJ5_CCO_GRID_RESOLUTION = 10          # Grid resolution for bifurcation optimization
OBJ5_CCO_USE_NLP = True                # Enable NLP-based bifurcation optimization
OBJ5_CCO_MURRAY_EXPONENT = 3.0         # Murray's law exponent
# NLP global optimization parameters
OBJ5_NLP_ENABLED = True                # Enable global NLP optimization
OBJ5_NLP_MURRAY_EXPONENT = 3.0         # Murray's law exponent
OBJ5_NLP_TARGET_PRESSURE_DROP = 13332.0  # ~100 mmHg pressure drop
OBJ5_NLP_VISCOSITY = 0.0035            # Blood viscosity (Pa*s)
OBJ5_NLP_FIX_TERMINALS = True          # Fix terminal positions
OBJ5_NLP_FIX_ROOT = True               # Fix inlet positions
OBJ5_NLP_MAX_ITERATIONS = 500          # Max optimization iterations
OBJ5_NLP_TOLERANCE = 1e-5              # Solver tolerance
OBJ5_NLP_CLEANUP_DEGENERATE = True     # Remove degenerate segments

# =============================================================================
# VOXELIZATION PARAMETERS
# =============================================================================
VOXEL_PITCH_M = 2.5e-5             # 25 um voxel pitch (for fine resolution embedding)
VOXEL_PITCH_UNION_M = 1.0e-4       # 100 um voxel pitch (for union operations - coarser to save memory)
# Note: 25 um pitch on 10mm x 10mm x 2mm domain = ~12.8M voxels
# For union operations, we use 100 um to reduce memory usage (~200K voxels)

# =============================================================================
# OUTPUT PARAMETERS
# =============================================================================
OUTPUT_UNITS = "mm"                # Output STL files in millimeters
OUTPUT_DIR = Path(__file__).parent / "Malaria Venule Inserts"


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def meters_to_mm(value_m: float) -> float:
    """Convert meters to millimeters."""
    return value_m * 1000.0


def create_cylinder_mesh(radius: float, height: float, center: Tuple[float, float, float]) -> trimesh.Trimesh:
    """Create a solid cylinder mesh centered at the given point."""
    cylinder = trimesh.creation.cylinder(
        radius=radius,
        height=height,
        sections=64,
    )
    cylinder.apply_translation([center[0], center[1], center[2]])
    return cylinder


def create_ridge_mesh(
    outer_radius: float,
    inner_radius: float,
    height: float,
    z_base: float,
    center_xy: Tuple[float, float],
) -> trimesh.Trimesh:
    """
    Create an annular ring (ridge) mesh.
    
    Design choice: Ridge is an annular ring on the perimeter of the top face.
    If boolean operations fail, falls back to a solid disk.
    """
    try:
        # Create outer cylinder
        outer_cyl = trimesh.creation.cylinder(
            radius=outer_radius,
            height=height,
            sections=64,
        )
        outer_cyl.apply_translation([center_xy[0], center_xy[1], z_base + height / 2])
        
        # Create inner cylinder (to subtract)
        inner_cyl = trimesh.creation.cylinder(
            radius=inner_radius,
            height=height * 1.1,  # Slightly taller to ensure clean subtraction
            sections=64,
        )
        inner_cyl.apply_translation([center_xy[0], center_xy[1], z_base + height / 2])
        
        # Try boolean difference
        try:
            ring = outer_cyl.difference(inner_cyl, engine='blender')
            if ring is not None and len(ring.vertices) > 0:
                print("  Ridge: Created annular ring using boolean difference")
                return ring
        except Exception as e:
            print(f"  Ridge: Boolean difference failed ({e}), using fallback")
        
        # Fallback: Create ring using path extrusion
        # Generate annular cross-section
        angles = np.linspace(0, 2 * np.pi, 65)
        outer_points = np.column_stack([
            outer_radius * np.cos(angles),
            outer_radius * np.sin(angles),
        ])
        inner_points = np.column_stack([
            inner_radius * np.cos(angles[::-1]),
            inner_radius * np.sin(angles[::-1]),
        ])
        
        # Create top and bottom faces
        n_outer = len(outer_points) - 1
        n_inner = len(inner_points) - 1
        
        # Build vertices for top and bottom rings
        top_z = z_base + height
        bottom_z = z_base
        
        vertices = []
        # Bottom outer ring
        for i in range(n_outer):
            vertices.append([outer_points[i, 0] + center_xy[0], 
                           outer_points[i, 1] + center_xy[1], bottom_z])
        # Bottom inner ring
        for i in range(n_inner):
            vertices.append([inner_points[i, 0] + center_xy[0], 
                           inner_points[i, 1] + center_xy[1], bottom_z])
        # Top outer ring
        for i in range(n_outer):
            vertices.append([outer_points[i, 0] + center_xy[0], 
                           outer_points[i, 1] + center_xy[1], top_z])
        # Top inner ring
        for i in range(n_inner):
            vertices.append([inner_points[i, 0] + center_xy[0], 
                           inner_points[i, 1] + center_xy[1], top_z])
        
        vertices = np.array(vertices)
        
        # Build faces
        faces = []
        # Outer wall faces
        for i in range(n_outer):
            i_next = (i + 1) % n_outer
            # Bottom outer, top outer
            faces.append([i, i_next, i + 2 * n_outer])
            faces.append([i_next, i_next + 2 * n_outer, i + 2 * n_outer])
        
        # Inner wall faces
        for i in range(n_inner):
            i_next = (i + 1) % n_inner
            base = n_outer
            top_base = 3 * n_outer
            # Bottom inner, top inner (reversed winding)
            faces.append([base + i, base + i + 2 * n_outer, base + i_next])
            faces.append([base + i_next, base + i + 2 * n_outer, base + i_next + 2 * n_outer])
        
        # Top and bottom annular faces
        for i in range(n_outer):
            i_next = (i + 1) % n_outer
            # Bottom face
            faces.append([i, n_outer + i, i_next])
            faces.append([i_next, n_outer + i, n_outer + i_next])
            # Top face
            faces.append([2 * n_outer + i, 2 * n_outer + i_next, 3 * n_outer + i])
            faces.append([2 * n_outer + i_next, 3 * n_outer + i_next, 3 * n_outer + i])
        
        ring = trimesh.Trimesh(vertices=vertices, faces=np.array(faces))
        ring.fix_normals()
        print("  Ridge: Created annular ring using manual mesh construction")
        return ring
        
    except Exception as e:
        print(f"  Ridge: Annular ring creation failed ({e}), using solid disk fallback")
        # Fallback: Solid disk
        disk = trimesh.creation.cylinder(
            radius=outer_radius,
            height=height,
            sections=64,
        )
        disk.apply_translation([center_xy[0], center_xy[1], z_base + height / 2])
        print("  Ridge: Created solid disk (fallback)")
        return disk


def create_channel_mesh(
    position_xy: Tuple[float, float],
    z_top: float,
    radius: float,
    depth: float,
) -> trimesh.Trimesh:
    """Create a cylindrical channel mesh extending downward from z_top."""
    channel = trimesh.creation.cylinder(
        radius=radius,
        height=depth,
        sections=32,
    )
    # Position so top of channel is at z_top
    channel.apply_translation([position_xy[0], position_xy[1], z_top - depth / 2])
    return channel


def compute_taper_radius(level: int, total_levels: int, r_start: float, r_end: float) -> float:
    """
    Compute radius at a given bifurcation level using exponential taper.
    
    r_k = r_0 * (r_end/r_0)^(k/total_levels)
    """
    if total_levels == 0:
        return r_start
    ratio = r_end / r_start
    return r_start * (ratio ** (level / total_levels))


def voxel_union_meshes(meshes: List[trimesh.Trimesh], pitch: float) -> trimesh.Trimesh:
    """
    Union multiple meshes using voxelization and marching cubes.
    
    This is the overlap-based merge strategy: overlapping volumes are
    automatically merged during voxelization.
    """
    from skimage.measure import marching_cubes
    
    if not meshes:
        raise ValueError("No meshes to union")
    
    if len(meshes) == 1:
        return meshes[0]
    
    # Concatenate all meshes
    combined = trimesh.util.concatenate(meshes)
    
    # Voxelize
    try:
        voxels = combined.voxelized(pitch)
        voxel_matrix = voxels.matrix
    except (MemoryError, ValueError):
        # Try with coarser pitch
        pitch *= 2
        voxels = combined.voxelized(pitch)
        voxel_matrix = voxels.matrix
    
    # Marching cubes
    verts, faces, _, _ = marching_cubes(
        volume=voxel_matrix.astype(np.uint8),
        level=0.5,
        spacing=(pitch, pitch, pitch),
        allow_degenerate=False,
    )
    
    # Transform back to world coordinates
    verts += voxels.transform[:3, 3]
    
    result = trimesh.Trimesh(
        vertices=verts,
        faces=faces.astype(np.int64),
        process=False,
    )
    
    result.remove_unreferenced_vertices()
    if result.volume < 0:
        result.invert()
    trimesh.repair.fix_normals(result)
    
    return result


def scale_mesh_to_mm(mesh: trimesh.Trimesh) -> trimesh.Trimesh:
    """Scale mesh from meters to millimeters."""
    scaled = mesh.copy()
    scaled.apply_scale(1000.0)  # m to mm
    return scaled


def export_mesh_with_units(mesh: trimesh.Trimesh, output_path: Path, units: str = "mm"):
    """Export mesh to STL with units.json sidecar file."""
    mesh.export(str(output_path))
    
    # Write units sidecar
    sidecar_path = str(output_path) + ".units.json"
    metadata = {
        "units": units,
        "stl_file": str(output_path),
        "description": "Malaria Venule Insert scaffold",
    }
    with open(sidecar_path, 'w') as f:
        json.dump(metadata, f, indent=2)
    
    print(f"  Exported: {output_path}")
    print(f"  Units sidecar: {sidecar_path}")


# =============================================================================
# OBJECT GENERATION FUNCTIONS
# =============================================================================

def generate_object1_control() -> trimesh.Trimesh:
    """
    Generate Object 1: Control cylinder with ridge, no internal voids.
    
    Returns mesh in METERS (will be scaled to mm at export).
    """
    print("\n" + "=" * 60)
    print("Generating Object 1: Control (solid cylinder + ridge)")
    print("=" * 60)
    
    # Create base cylinder
    print("  Creating base cylinder...")
    base_cylinder = create_cylinder_mesh(
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
        center=CYLINDER_CENTER,
    )
    print(f"    Cylinder: radius={meters_to_mm(CYLINDER_RADIUS_M)}mm, "
          f"height={meters_to_mm(CYLINDER_HEIGHT_M)}mm")
    
    # Create ridge on top face
    print("  Creating ridge...")
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2  # Top of cylinder
    ridge = create_ridge_mesh(
        outer_radius=CYLINDER_RADIUS_M,
        inner_radius=CYLINDER_RADIUS_M - RIDGE_THICKNESS_M,
        height=RIDGE_HEIGHT_M,
        z_base=z_top,
        center_xy=(CYLINDER_CENTER[0], CYLINDER_CENTER[1]),
    )
    print(f"    Ridge: outer_r={meters_to_mm(CYLINDER_RADIUS_M)}mm, "
          f"inner_r={meters_to_mm(CYLINDER_RADIUS_M - RIDGE_THICKNESS_M)}mm, "
          f"height={meters_to_mm(RIDGE_HEIGHT_M)}mm")
    
    # Union cylinder and ridge (use coarser pitch for memory efficiency)
    print("  Combining cylinder and ridge...")
    combined = voxel_union_meshes([base_cylinder, ridge], pitch=VOXEL_PITCH_UNION_M)
    
    print(f"  Object 1 complete: {len(combined.vertices)} vertices, {len(combined.faces)} faces")
    print(f"    Watertight: {combined.is_watertight}")
    
    return combined


def generate_object2_channels() -> trimesh.Trimesh:
    """
    Generate Object 2: Control + straight channels.
    
    Design choice: 4 channels in a square pattern at (+/-1.5mm, +/-1.5mm).
    
    Returns mesh in METERS (will be scaled to mm at export).
    """
    print("\n" + "=" * 60)
    print("Generating Object 2: Control + straight channels")
    print("=" * 60)
    
    # Create base (same as Object 1)
    print("  Creating base cylinder with ridge...")
    base_cylinder = create_cylinder_mesh(
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
        center=CYLINDER_CENTER,
    )
    
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    ridge = create_ridge_mesh(
        outer_radius=CYLINDER_RADIUS_M,
        inner_radius=CYLINDER_RADIUS_M - RIDGE_THICKNESS_M,
        height=RIDGE_HEIGHT_M,
        z_base=z_top,
        center_xy=(CYLINDER_CENTER[0], CYLINDER_CENTER[1]),
    )
    
    base = voxel_union_meshes([base_cylinder, ridge], pitch=VOXEL_PITCH_UNION_M)
    
    # Create channels
    print(f"  Creating {OBJ2_NUM_INLETS} straight channels...")
    
    channels = []
    for i, pos in enumerate(OBJ2_INLET_POSITIONS[:OBJ2_NUM_INLETS]):
        channel = create_channel_mesh(
            position_xy=pos,
            z_top=z_top,
            radius=OBJ2_INLET_RADIUS_M,
            depth=OBJ2_CHANNEL_DEPTH_M,
        )
        channels.append(channel)
        print(f"    Channel {i+1}: position=({meters_to_mm(pos[0]):.1f}, {meters_to_mm(pos[1]):.1f})mm, "
              f"radius={meters_to_mm(OBJ2_INLET_RADIUS_M)}mm, depth={meters_to_mm(OBJ2_CHANNEL_DEPTH_M)}mm")
    
    # Union all channels
    print("  Combining channels...")
    channel_void = voxel_union_meshes(channels, pitch=VOXEL_PITCH_UNION_M)
    
    # Subtract channels from base
    print("  Carving channels from base...")
    try:
        result = base.difference(channel_void, engine='blender')
        if result is None or len(result.vertices) == 0:
            raise ValueError("Boolean difference returned empty mesh")
        print("    Used Blender boolean difference")
    except Exception as e:
        print(f"    Blender boolean failed ({e}), using voxel-based subtraction")
        # Voxel-based subtraction
        from skimage.measure import marching_cubes
        
        # Voxelize both meshes
        pitch = VOXEL_PITCH_M
        
        # Get combined bounds
        all_bounds = np.vstack([base.bounds, channel_void.bounds])
        min_bound = all_bounds.min(axis=0) - pitch * 2
        max_bound = all_bounds.max(axis=0) + pitch * 2
        
        grid_shape = np.ceil((max_bound - min_bound) / pitch).astype(int)
        
        # Voxelize base
        base_vox = base.voxelized(pitch)
        base_matrix = np.zeros(grid_shape, dtype=bool)
        base_origin = base_vox.transform[:3, 3]
        base_offset = np.round((base_origin - min_bound) / pitch).astype(int)
        
        bm = base_vox.matrix
        for i in range(3):
            if base_offset[i] < 0:
                bm = bm[-base_offset[i]:]
                base_offset[i] = 0
        
        end_idx = np.minimum(base_offset + np.array(bm.shape), grid_shape)
        copy_size = end_idx - base_offset
        copy_size = np.minimum(copy_size, np.array(bm.shape))
        
        if np.all(copy_size > 0):
            base_matrix[
                base_offset[0]:base_offset[0]+copy_size[0],
                base_offset[1]:base_offset[1]+copy_size[1],
                base_offset[2]:base_offset[2]+copy_size[2]
            ] = bm[:copy_size[0], :copy_size[1], :copy_size[2]]
        
        # Voxelize channels
        chan_vox = channel_void.voxelized(pitch)
        chan_matrix = np.zeros(grid_shape, dtype=bool)
        chan_origin = chan_vox.transform[:3, 3]
        chan_offset = np.round((chan_origin - min_bound) / pitch).astype(int)
        
        cm = chan_vox.matrix
        for i in range(3):
            if chan_offset[i] < 0:
                cm = cm[-chan_offset[i]:]
                chan_offset[i] = 0
        
        end_idx = np.minimum(chan_offset + np.array(cm.shape), grid_shape)
        copy_size = end_idx - chan_offset
        copy_size = np.minimum(copy_size, np.array(cm.shape))
        
        if np.all(copy_size > 0):
            chan_matrix[
                chan_offset[0]:chan_offset[0]+copy_size[0],
                chan_offset[1]:chan_offset[1]+copy_size[1],
                chan_offset[2]:chan_offset[2]+copy_size[2]
            ] = cm[:copy_size[0], :copy_size[1], :copy_size[2]]
        
        # Subtract
        result_matrix = base_matrix & ~chan_matrix
        
        # Marching cubes
        verts, faces, _, _ = marching_cubes(
            volume=result_matrix.astype(np.uint8),
            level=0.5,
            spacing=(pitch, pitch, pitch),
            allow_degenerate=False,
        )
        verts += min_bound
        
        result = trimesh.Trimesh(vertices=verts, faces=faces.astype(np.int64), process=False)
        result.remove_unreferenced_vertices()
        if result.volume < 0:
            result.invert()
        trimesh.repair.fix_normals(result)
    
    print(f"  Object 2 complete: {len(result.vertices)} vertices, {len(result.faces)} faces")
    print(f"    Watertight: {result.is_watertight}")
    
    return result


def generate_bifurcation_tree_mesh(
    inlet_position: Tuple[float, float, float],
    inlet_radius: float,
    terminal_radius: float,
    bifurcation_depths: List[float],
    base_angle_deg: float = 30.0,
) -> trimesh.Trimesh:
    """
    Generate a bifurcating tree mesh from a single inlet.
    
    Uses recursive bifurcation with exponential radius taper.
    Overlapping branches are merged via voxel union.
    
    Parameters
    ----------
    inlet_position : tuple
        (x, y, z) position of inlet in meters
    inlet_radius : float
        Radius at inlet in meters
    terminal_radius : float
        Radius at terminals in meters
    bifurcation_depths : list
        Z-depths (from top) where bifurcations occur, in meters
    base_angle_deg : float
        Base bifurcation angle in degrees
    
    Returns
    -------
    trimesh.Trimesh
        Combined mesh of all branches
    """
    num_levels = len(bifurcation_depths)
    all_segments = []
    
    # Track current branch tips: list of (position, direction, radius, level)
    # Direction is a unit vector
    current_tips = [(
        np.array(inlet_position),
        np.array([0.0, 0.0, -1.0]),  # Downward
        inlet_radius,
        0,
    )]
    
    for level in range(num_levels):
        depth = bifurcation_depths[level]
        target_z = inlet_position[2] - depth
        
        new_tips = []
        
        for tip_pos, tip_dir, tip_radius, tip_level in current_tips:
            if tip_level != level:
                new_tips.append((tip_pos, tip_dir, tip_radius, tip_level))
                continue
            
            # Compute radius for this level
            current_radius = compute_taper_radius(level, num_levels, inlet_radius, terminal_radius)
            next_radius = compute_taper_radius(level + 1, num_levels, inlet_radius, terminal_radius)
            
            # Grow to bifurcation point
            # Distance to target z
            if abs(tip_dir[2]) > 0.1:
                dist_to_target = abs((target_z - tip_pos[2]) / tip_dir[2])
            else:
                dist_to_target = 0.0002  # Small step for horizontal branches
            
            dist_to_target = max(dist_to_target, 0.0001)  # Minimum segment length
            
            bifurc_pos = tip_pos + tip_dir * dist_to_target
            
            # Create segment to bifurcation point
            seg_mesh = _create_tapered_cylinder(
                start=tip_pos,
                end=bifurc_pos,
                radius_start=current_radius,
                radius_end=current_radius,
            )
            all_segments.append(seg_mesh)
            
            # Create two child branches
            # Compute perpendicular directions for bifurcation
            if abs(tip_dir[2]) > 0.9:
                # Mostly vertical, use X and Y for lateral spread
                perp1 = np.array([1.0, 0.0, 0.0])
                perp2 = np.array([0.0, 1.0, 0.0])
            else:
                # Compute perpendicular in XY plane
                perp1 = np.cross(tip_dir, np.array([0.0, 0.0, 1.0]))
                perp1 = perp1 / np.linalg.norm(perp1)
                perp2 = np.cross(tip_dir, perp1)
                perp2 = perp2 / np.linalg.norm(perp2)
            
            # Angle for bifurcation (decreases with level for tighter packing)
            angle_rad = math.radians(base_angle_deg * (1.0 - 0.1 * level))
            
            # Child 1: deflect in perp1 direction
            child1_dir = tip_dir * math.cos(angle_rad) + perp1 * math.sin(angle_rad)
            child1_dir = child1_dir / np.linalg.norm(child1_dir)
            
            # Child 2: deflect in opposite perp1 direction
            child2_dir = tip_dir * math.cos(angle_rad) - perp1 * math.sin(angle_rad)
            child2_dir = child2_dir / np.linalg.norm(child2_dir)
            
            new_tips.append((bifurc_pos.copy(), child1_dir, next_radius, level + 1))
            new_tips.append((bifurc_pos.copy(), child2_dir, next_radius, level + 1))
        
        current_tips = new_tips
    
    # Add final segments for terminal tips
    for tip_pos, tip_dir, tip_radius, tip_level in current_tips:
        # Short terminal segment
        end_pos = tip_pos + tip_dir * 0.0001
        seg_mesh = _create_tapered_cylinder(
            start=tip_pos,
            end=end_pos,
            radius_start=tip_radius,
            radius_end=terminal_radius,
        )
        all_segments.append(seg_mesh)
    
    # Union all segments (overlap-based merge)
    print(f"    Combining {len(all_segments)} branch segments...")
    combined = voxel_union_meshes(all_segments, pitch=VOXEL_PITCH_UNION_M)
    
    return combined


def _create_tapered_cylinder(
    start: np.ndarray,
    end: np.ndarray,
    radius_start: float,
    radius_end: float,
    sections: int = 16,
) -> trimesh.Trimesh:
    """Create a tapered cylinder (frustum) between two points."""
    direction = end - start
    length = np.linalg.norm(direction)
    
    if length < 1e-9:
        # Degenerate segment, return small sphere
        sphere = trimesh.creation.icosphere(subdivisions=1, radius=radius_start)
        sphere.apply_translation(start)
        return sphere
    
    direction = direction / length
    
    # Create frustum along Z axis
    if abs(radius_start - radius_end) < 1e-10:
        frustum = trimesh.creation.cylinder(
            radius=radius_start,
            height=length,
            sections=sections,
        )
    else:
        # Manual frustum creation
        angles = np.linspace(0, 2 * np.pi, sections, endpoint=False)
        
        z_bottom = -length / 2
        z_top = length / 2
        
        bottom_verts = np.column_stack([
            radius_start * np.cos(angles),
            radius_start * np.sin(angles),
            np.full(sections, z_bottom),
        ])
        
        top_verts = np.column_stack([
            radius_end * np.cos(angles),
            radius_end * np.sin(angles),
            np.full(sections, z_top),
        ])
        
        # Center vertices for caps
        center_bottom = np.array([[0, 0, z_bottom]])
        center_top = np.array([[0, 0, z_top]])
        
        vertices = np.vstack([bottom_verts, top_verts, center_bottom, center_top])
        
        faces = []
        # Side faces
        for i in range(sections):
            i_next = (i + 1) % sections
            faces.append([i, i_next, i + sections])
            faces.append([i_next, i_next + sections, i + sections])
        
        # Bottom cap
        center_bottom_idx = 2 * sections
        for i in range(sections):
            i_next = (i + 1) % sections
            faces.append([center_bottom_idx, i_next, i])
        
        # Top cap
        center_top_idx = 2 * sections + 1
        for i in range(sections):
            i_next = (i + 1) % sections
            faces.append([center_top_idx, i + sections, i_next + sections])
        
        frustum = trimesh.Trimesh(vertices=vertices, faces=np.array(faces))
    
    # Rotate to align with direction
    z_axis = np.array([0, 0, 1])
    if not np.allclose(direction, z_axis) and not np.allclose(direction, -z_axis):
        rotation_axis = np.cross(z_axis, direction)
        if np.linalg.norm(rotation_axis) > 1e-6:
            rotation_axis = rotation_axis / np.linalg.norm(rotation_axis)
            angle = np.arccos(np.clip(np.dot(z_axis, direction), -1, 1))
            rotation_matrix = trimesh.transformations.rotation_matrix(angle, rotation_axis)
            frustum.apply_transform(rotation_matrix)
    elif np.allclose(direction, -z_axis):
        rotation_matrix = trimesh.transformations.rotation_matrix(np.pi, [1, 0, 0])
        frustum.apply_transform(rotation_matrix)
    
    # Translate to position
    center = (start + end) / 2
    frustum.apply_translation(center)
    
    return frustum


def generate_object3_bifurcate_512() -> trimesh.Trimesh:
    """
    Generate Object 3: Recursive bifurcation to 512 terminals.
    
    Design choices:
    - 4 inlets at symmetric positions near center
    - 7 bifurcation levels per inlet (2^7 = 128 terminals each)
    - Exponential radius taper from 1mm to 100um
    - Bifurcation depths at 0.25, 0.50, 0.75, 1.00, 1.25, 1.50, 1.75 mm
    - Overlapping branches merge via voxel union
    
    Returns mesh in METERS (will be scaled to mm at export).
    """
    print("\n" + "=" * 60)
    print("Generating Object 3: Recursive bifurcation to 512 terminals")
    print("=" * 60)
    
    # Create base (same as Object 1)
    print("  Creating base cylinder with ridge...")
    base_cylinder = create_cylinder_mesh(
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
        center=CYLINDER_CENTER,
    )
    
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    ridge = create_ridge_mesh(
        outer_radius=CYLINDER_RADIUS_M,
        inner_radius=CYLINDER_RADIUS_M - RIDGE_THICKNESS_M,
        height=RIDGE_HEIGHT_M,
        z_base=z_top,
        center_xy=(CYLINDER_CENTER[0], CYLINDER_CENTER[1]),
    )
    
    base = voxel_union_meshes([base_cylinder, ridge], pitch=VOXEL_PITCH_UNION_M)
    
    # Generate bifurcating trees from each inlet
    print(f"  Generating {OBJ3_NUM_INLETS} bifurcating trees...")
    all_trees = []
    
    for i, (x, y) in enumerate(OBJ3_INLET_POSITIONS):
        print(f"    Tree {i+1}: inlet at ({meters_to_mm(x):.1f}, {meters_to_mm(y):.1f})mm")
        inlet_pos = (x, y, z_top)
        
        tree_mesh = generate_bifurcation_tree_mesh(
            inlet_position=inlet_pos,
            inlet_radius=OBJ3_INLET_RADIUS_M,
            terminal_radius=OBJ3_TERMINAL_RADIUS_M,
            bifurcation_depths=OBJ3_BIFURCATION_DEPTHS_M,
            base_angle_deg=30.0,
        )
        all_trees.append(tree_mesh)
        print(f"      Generated tree with {len(tree_mesh.vertices)} vertices")
    
    # Union all trees (overlapping branches merge)
    print("  Combining all trees (overlap-based merge)...")
    combined_void = voxel_union_meshes(all_trees, pitch=VOXEL_PITCH_UNION_M)
    
    # Subtract from base
    print("  Carving voids from base...")
    try:
        result = base.difference(combined_void, engine='blender')
        if result is None or len(result.vertices) == 0:
            raise ValueError("Boolean difference returned empty mesh")
        print("    Used Blender boolean difference")
    except Exception as e:
        print(f"    Blender boolean failed ({e}), using voxel-based subtraction")
        # Voxel-based subtraction (same as Object 2)
        from skimage.measure import marching_cubes
        
        pitch = VOXEL_PITCH_M * 2  # Coarser for large mesh
        
        all_bounds = np.vstack([base.bounds, combined_void.bounds])
        min_bound = all_bounds.min(axis=0) - pitch * 2
        max_bound = all_bounds.max(axis=0) + pitch * 2
        
        grid_shape = np.ceil((max_bound - min_bound) / pitch).astype(int)
        grid_shape = np.minimum(grid_shape, 500)  # Cap grid size
        
        # Voxelize base
        base_vox = base.voxelized(pitch)
        base_matrix = np.zeros(grid_shape, dtype=bool)
        base_origin = base_vox.transform[:3, 3]
        base_offset = np.round((base_origin - min_bound) / pitch).astype(int)
        base_offset = np.maximum(base_offset, 0)
        
        bm = base_vox.matrix
        end_idx = np.minimum(base_offset + np.array(bm.shape), grid_shape)
        copy_size = end_idx - base_offset
        copy_size = np.minimum(copy_size, np.array(bm.shape))
        copy_size = np.maximum(copy_size, 0)
        
        if np.all(copy_size > 0):
            base_matrix[
                base_offset[0]:base_offset[0]+copy_size[0],
                base_offset[1]:base_offset[1]+copy_size[1],
                base_offset[2]:base_offset[2]+copy_size[2]
            ] = bm[:copy_size[0], :copy_size[1], :copy_size[2]]
        
        # Voxelize void
        void_vox = combined_void.voxelized(pitch)
        void_matrix = np.zeros(grid_shape, dtype=bool)
        void_origin = void_vox.transform[:3, 3]
        void_offset = np.round((void_origin - min_bound) / pitch).astype(int)
        void_offset = np.maximum(void_offset, 0)
        
        vm = void_vox.matrix
        end_idx = np.minimum(void_offset + np.array(vm.shape), grid_shape)
        copy_size = end_idx - void_offset
        copy_size = np.minimum(copy_size, np.array(vm.shape))
        copy_size = np.maximum(copy_size, 0)
        
        if np.all(copy_size > 0):
            void_matrix[
                void_offset[0]:void_offset[0]+copy_size[0],
                void_offset[1]:void_offset[1]+copy_size[1],
                void_offset[2]:void_offset[2]+copy_size[2]
            ] = vm[:copy_size[0], :copy_size[1], :copy_size[2]]
        
        # Subtract
        result_matrix = base_matrix & ~void_matrix
        
        if not result_matrix.any():
            print("    WARNING: Result matrix is empty, using base mesh")
            result = base
        else:
            verts, faces, _, _ = marching_cubes(
                volume=result_matrix.astype(np.uint8),
                level=0.5,
                spacing=(pitch, pitch, pitch),
                allow_degenerate=False,
            )
            verts += min_bound
            
            result = trimesh.Trimesh(vertices=verts, faces=faces.astype(np.int64), process=False)
            result.remove_unreferenced_vertices()
            if result.volume < 0:
                result.invert()
            trimesh.repair.fix_normals(result)
    
    print(f"  Object 3 complete: {len(result.vertices)} vertices, {len(result.faces)} faces")
    print(f"    Watertight: {result.is_watertight}")
    
    return result


def generate_object4_turn_bifurcate_merge() -> trimesh.Trimesh:
    """
    Generate Object 4: Single inlet, 90-degree turn, bifurcate, merge, return.
    
    Design choices:
    - Single inlet at center top face, radius 1mm
    - Travel downward 1mm
    - Turn 90 degrees (along +X direction)
    - Bifurcate in XY plane
    - Branches merge by overlapping in space (voxel union)
    - Single trunk returns upward to exit near top face
    
    Returns mesh in METERS (will be scaled to mm at export).
    """
    print("\n" + "=" * 60)
    print("Generating Object 4: Turn-Bifurcate-Merge loop")
    print("=" * 60)
    
    # Create base (same as Object 1)
    print("  Creating base cylinder with ridge...")
    base_cylinder = create_cylinder_mesh(
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
        center=CYLINDER_CENTER,
    )
    
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    z_bottom = CYLINDER_CENTER[2] - CYLINDER_HEIGHT_M / 2
    ridge = create_ridge_mesh(
        outer_radius=CYLINDER_RADIUS_M,
        inner_radius=CYLINDER_RADIUS_M - RIDGE_THICKNESS_M,
        height=RIDGE_HEIGHT_M,
        z_base=z_top,
        center_xy=(CYLINDER_CENTER[0], CYLINDER_CENTER[1]),
    )
    
    base = voxel_union_meshes([base_cylinder, ridge], pitch=VOXEL_PITCH_UNION_M)
    
    # Build the channel network
    print("  Building channel network...")
    channel_segments = []
    
    # Inlet position (slightly offset from center to allow return path)
    inlet_x = OBJ4_INLET_POSITION[0] - 0.001  # Offset from center to allow return path
    inlet_y = OBJ4_INLET_POSITION[1]
    inlet_pos = np.array([inlet_x, inlet_y, z_top])
    
    # 1. Downward segment (1mm)
    print("    Segment 1: Downward 1mm")
    down_end = inlet_pos + np.array([0, 0, -OBJ4_DOWNWARD_LENGTH_M])
    seg1 = _create_tapered_cylinder(inlet_pos, down_end, OBJ4_INLET_RADIUS_M, OBJ4_INLET_RADIUS_M)
    channel_segments.append(seg1)
    
    # 2. 90-degree turn (horizontal along +X)
    print("    Segment 2: Horizontal turn (+X direction)")
    turn_end = down_end + np.array([OBJ4_HORIZONTAL_LENGTH_M, 0, 0])
    seg2 = _create_tapered_cylinder(down_end, turn_end, OBJ4_INLET_RADIUS_M, OBJ4_INLET_RADIUS_M * 0.9)
    channel_segments.append(seg2)
    
    # 3. Bifurcate in XY plane
    print(f"    Bifurcating {OBJ4_NUM_BIFURCATIONS} levels in XY plane")
    
    # Create bifurcating branches
    branch_tips = [(turn_end.copy(), np.array([1.0, 0.0, 0.0]), OBJ4_INLET_RADIUS_M * 0.9)]
    
    for level in range(OBJ4_NUM_BIFURCATIONS):
        new_tips = []
        branch_length = 0.0005 * (1.0 - 0.2 * level)  # Decreasing length
        branch_radius = OBJ4_INLET_RADIUS_M * 0.9 * (0.8 ** (level + 1))
        
        for tip_pos, tip_dir, tip_r in branch_tips:
            # Grow forward a bit
            mid_pos = tip_pos + tip_dir * branch_length
            seg = _create_tapered_cylinder(tip_pos, mid_pos, tip_r, branch_radius)
            channel_segments.append(seg)
            
            # Bifurcate: one branch goes +Y, one goes -Y (with some forward component)
            angle = math.radians(45 - 10 * level)
            
            # Branch 1: +Y deflection
            dir1 = tip_dir * math.cos(angle) + np.array([0, 1, 0]) * math.sin(angle)
            dir1 = dir1 / np.linalg.norm(dir1)
            
            # Branch 2: -Y deflection
            dir2 = tip_dir * math.cos(angle) + np.array([0, -1, 0]) * math.sin(angle)
            dir2 = dir2 / np.linalg.norm(dir2)
            
            new_tips.append((mid_pos.copy(), dir1, branch_radius))
            new_tips.append((mid_pos.copy(), dir2, branch_radius))
        
        branch_tips = new_tips
    
    # 4. Merge branches back (overlap-based merge)
    # Route all branch tips toward a common merge point
    print("    Merging branches (overlap-based)")
    merge_point = np.array([0.002, 0.0, down_end[2]])  # Merge point at +2mm X
    
    for tip_pos, tip_dir, tip_r in branch_tips:
        # Create segment toward merge point
        seg = _create_tapered_cylinder(tip_pos, merge_point, tip_r, OBJ4_TERMINAL_RADIUS_M)
        channel_segments.append(seg)
    
    # 5. Return upward to top face
    print("    Segment: Return upward to top face")
    outlet_pos = np.array([0.002, 0.0, z_top])  # Outlet at +2mm X from center
    seg_return = _create_tapered_cylinder(merge_point, outlet_pos, OBJ4_TERMINAL_RADIUS_M, OBJ4_TERMINAL_RADIUS_M)
    channel_segments.append(seg_return)
    
    # Union all channel segments
    print(f"  Combining {len(channel_segments)} channel segments...")
    combined_void = voxel_union_meshes(channel_segments, pitch=VOXEL_PITCH_UNION_M)
    
    # Subtract from base
    print("  Carving channels from base...")
    try:
        result = base.difference(combined_void, engine='blender')
        if result is None or len(result.vertices) == 0:
            raise ValueError("Boolean difference returned empty mesh")
        print("    Used Blender boolean difference")
    except Exception as e:
        print(f"    Blender boolean failed ({e}), using voxel-based subtraction")
        # Voxel-based subtraction
        from skimage.measure import marching_cubes
        
        pitch = VOXEL_PITCH_M
        
        all_bounds = np.vstack([base.bounds, combined_void.bounds])
        min_bound = all_bounds.min(axis=0) - pitch * 2
        max_bound = all_bounds.max(axis=0) + pitch * 2
        
        grid_shape = np.ceil((max_bound - min_bound) / pitch).astype(int)
        grid_shape = np.minimum(grid_shape, 500)
        
        # Voxelize base
        base_vox = base.voxelized(pitch)
        base_matrix = np.zeros(grid_shape, dtype=bool)
        base_origin = base_vox.transform[:3, 3]
        base_offset = np.round((base_origin - min_bound) / pitch).astype(int)
        base_offset = np.maximum(base_offset, 0)
        
        bm = base_vox.matrix
        end_idx = np.minimum(base_offset + np.array(bm.shape), grid_shape)
        copy_size = end_idx - base_offset
        copy_size = np.minimum(copy_size, np.array(bm.shape))
        copy_size = np.maximum(copy_size, 0)
        
        if np.all(copy_size > 0):
            base_matrix[
                base_offset[0]:base_offset[0]+copy_size[0],
                base_offset[1]:base_offset[1]+copy_size[1],
                base_offset[2]:base_offset[2]+copy_size[2]
            ] = bm[:copy_size[0], :copy_size[1], :copy_size[2]]
        
        # Voxelize void
        void_vox = combined_void.voxelized(pitch)
        void_matrix = np.zeros(grid_shape, dtype=bool)
        void_origin = void_vox.transform[:3, 3]
        void_offset = np.round((void_origin - min_bound) / pitch).astype(int)
        void_offset = np.maximum(void_offset, 0)
        
        vm = void_vox.matrix
        end_idx = np.minimum(void_offset + np.array(vm.shape), grid_shape)
        copy_size = end_idx - void_offset
        copy_size = np.minimum(copy_size, np.array(vm.shape))
        copy_size = np.maximum(copy_size, 0)
        
        if np.all(copy_size > 0):
            void_matrix[
                void_offset[0]:void_offset[0]+copy_size[0],
                void_offset[1]:void_offset[1]+copy_size[1],
                void_offset[2]:void_offset[2]+copy_size[2]
            ] = vm[:copy_size[0], :copy_size[1], :copy_size[2]]
        
        # Subtract
        result_matrix = base_matrix & ~void_matrix
        
        if not result_matrix.any():
            print("    WARNING: Result matrix is empty, using base mesh")
            result = base
        else:
            verts, faces, _, _ = marching_cubes(
                volume=result_matrix.astype(np.uint8),
                level=0.5,
                spacing=(pitch, pitch, pitch),
                allow_degenerate=False,
            )
            verts += min_bound
            
            result = trimesh.Trimesh(vertices=verts, faces=faces.astype(np.int64), process=False)
            result.remove_unreferenced_vertices()
            if result.volume < 0:
                result.invert()
            trimesh.repair.fix_normals(result)
    
    print(f"  Object 4 complete: {len(result.vertices)} vertices, {len(result.faces)} faces")
    print(f"    Watertight: {result.is_watertight}")
    
    return result


# =============================================================================
# OBJECT 5: CCO-NLP ORGANIC GROWTH
# =============================================================================

def generate_object5_cco_nlp_organic() -> trimesh.Trimesh:
    """
    Generate Object 5: CCO-Hybrid + NLP iterative organic growth.
    
    This object uses the repo's CCOHybridBackend for organic vascular network
    generation with iterative NLP optimization between growth rounds.
    
    Design choices documented:
    - Coordinate convention: Cylinder centered at origin, z spans [-1mm, +1mm]
    - Inlet z aligned with top face at z = +1mm
    - 4 inlets in symmetric square pattern at (+/-1.5mm, +/-1.5mm)
    - Each inlet starts with 0.1mm straight downward segment
    - 4 rounds of CCO growth + NLP optimization
    - 512 total terminals (128 per inlet, 32 per round per inlet)
    - Optimized per-tree after each round, then globally on merged network
    
    Returns mesh in METERS (will be scaled to mm at export).
    """
    import copy
    import time
    
    print("\n" + "=" * 60)
    print("Generating Object 5: CCO-NLP Organic Growth")
    print("=" * 60)
    
    print("\n  Design choices:")
    print(f"    - Coordinate convention: Cylinder centered at origin")
    print(f"    - Top face at z = +{meters_to_mm(CYLINDER_HEIGHT_M/2)}mm")
    print(f"    - {OBJ5_NUM_INLETS} inlets at (+/-1.5mm, +/-1.5mm)")
    print(f"    - {OBJ5_NUM_ROUNDS} growth rounds with NLP optimization")
    print(f"    - {OBJ5_TOTAL_OUTLETS} total outlets ({OBJ5_TOTAL_OUTLETS // OBJ5_NUM_INLETS} per inlet)")
    print(f"    - Vessel type: {OBJ5_VESSEL_TYPE}")
    print(f"    - Seed: {OBJ5_SEED}")
    
    # Create base cylinder with ridge
    print("\n  Creating base cylinder with ridge...")
    base_cylinder = create_cylinder_mesh(
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
        center=CYLINDER_CENTER,
    )
    
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    ridge = create_ridge_mesh(
        outer_radius=CYLINDER_RADIUS_M,
        inner_radius=CYLINDER_RADIUS_M - RIDGE_THICKNESS_M,
        height=RIDGE_HEIGHT_M,
        z_base=z_top,
        center_xy=(CYLINDER_CENTER[0], CYLINDER_CENTER[1]),
    )
    
    base = voxel_union_meshes([base_cylinder, ridge], pitch=VOXEL_PITCH_UNION_M)
    
    # Create domain for CCO generation
    print("\n  Setting up CCO domain and configuration...")
    domain_spec = CylinderSpec(
        center=(CYLINDER_CENTER[0], CYLINDER_CENTER[1], CYLINDER_CENTER[2]),
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
    )
    domain = compile_domain(domain_spec)
    
    # Create CCO configuration
    cco_config = CCOConfig(
        seed=OBJ5_SEED,
        murray_exponent=OBJ5_CCO_MURRAY_EXPONENT,
        collision_clearance=OBJ5_CCO_COLLISION_CLEARANCE,
        min_segment_length=OBJ5_CCO_MIN_SEGMENT_LENGTH,
        max_segment_length=OBJ5_CCO_MAX_SEGMENT_LENGTH,
        min_terminal_separation=OBJ5_CCO_MIN_TERMINAL_SEP,
        candidate_edges_k=OBJ5_CCO_CANDIDATE_EDGES_K,
        optimization_grid_resolution=OBJ5_CCO_GRID_RESOLUTION,
        collision_check_enabled=True,
        use_partial_binding=True,
        use_collision_triage=True,
        use_nlp_optimization=OBJ5_CCO_USE_NLP,
    )
    
    print(f"    CCO config: murray_exponent={cco_config.murray_exponent}, "
          f"collision_clearance={cco_config.collision_clearance*1000:.3f}mm")
    
    # Create NLP configuration
    nlp_config = NLPConfig(
        murray_exponent=OBJ5_NLP_MURRAY_EXPONENT,
        target_pressure_drop=OBJ5_NLP_TARGET_PRESSURE_DROP,
        viscosity=OBJ5_NLP_VISCOSITY,
        fix_terminal_positions=OBJ5_NLP_FIX_TERMINALS,
        fix_root_position=OBJ5_NLP_FIX_ROOT,
        max_iterations=OBJ5_NLP_MAX_ITERATIONS,
        solver_tolerance=OBJ5_NLP_TOLERANCE,
        cleanup_degenerate_segments=OBJ5_NLP_CLEANUP_DEGENERATE,
    )
    
    # Create CCO backend
    backend = CCOHybridBackend()
    
    # Calculate outlets per inlet
    outlets_per_inlet = OBJ5_TOTAL_OUTLETS // OBJ5_NUM_INLETS
    
    # Generate trees for each inlet
    print(f"\n  Generating {OBJ5_NUM_INLETS} inlet trees with iterative CCO + NLP...")
    all_networks = []
    total_outlets_achieved = 0
    
    for inlet_idx, inlet_pos in enumerate(OBJ5_INLET_POSITIONS):
        print(f"\n    Inlet {inlet_idx + 1}: position=({inlet_pos[0]*1000:.1f}, "
              f"{inlet_pos[1]*1000:.1f}, {inlet_pos[2]*1000:.1f})mm")
        
        inlet_position = np.array(inlet_pos)
        
        # Generate tree for this inlet using CCO
        try:
            start_time = time.time()
            network = backend.generate(
                domain=domain,
                num_outlets=outlets_per_inlet,
                inlet_position=inlet_position,
                inlet_radius=OBJ5_INLET_RADIUS_M,
                vessel_type=OBJ5_VESSEL_TYPE,
                config=cco_config,
                rng_seed=OBJ5_SEED + inlet_idx,
            )
            gen_time = time.time() - start_time
            
            # Count actual outlets
            outlet_count = sum(1 for n in network.nodes.values() 
                             if n.node_type in ("outlet", "terminal"))
            total_outlets_achieved += outlet_count
            
            print(f"      CCO generation: {outlet_count} outlets in {gen_time:.1f}s")
            print(f"      Network: {len(network.nodes)} nodes, {len(network.segments)} segments")
            
            # Apply NLP optimization if enabled
            if OBJ5_NLP_ENABLED:
                print(f"      Applying NLP optimization...")
                try:
                    nlp_start = time.time()
                    nlp_result = optimize_geometry(network, nlp_config)
                    nlp_time = time.time() - nlp_start
                    
                    if nlp_result.success:
                        print(f"      NLP success: volume reduction {nlp_result.volume_reduction*100:.1f}% "
                              f"in {nlp_time:.1f}s")
                    else:
                        print(f"      NLP did not converge (continuing anyway)")
                except Exception as e:
                    print(f"      NLP optimization failed: {e} (continuing anyway)")
            
            all_networks.append(network)
            
        except Exception as e:
            print(f"      ERROR generating inlet {inlet_idx + 1}: {e}")
            continue
    
    if not all_networks:
        raise RuntimeError("Failed to generate any inlet networks")
    
    print(f"\n  Total outlets achieved: {total_outlets_achieved}/{OBJ5_TOTAL_OUTLETS}")
    
    # Merge all networks into one
    print("\n  Merging all inlet networks...")
    merged_network = all_networks[0]
    
    for i, network in enumerate(all_networks[1:], start=2):
        # Simple merge: copy nodes and segments with new IDs
        node_id_map = {}
        for old_node in network.nodes.values():
            new_node_id = merged_network.id_gen.next_id()
            new_node = Node(
                id=new_node_id,
                position=copy.deepcopy(old_node.position),
                node_type=old_node.node_type,
                vessel_type=old_node.vessel_type,
                attributes=old_node.attributes.copy() if old_node.attributes else {},
            )
            merged_network.add_node(new_node)
            node_id_map[old_node.id] = new_node_id
        
        for old_seg in network.segments.values():
            new_seg_id = merged_network.id_gen.next_id()
            new_seg = VesselSegment(
                id=new_seg_id,
                start_node_id=node_id_map[old_seg.start_node_id],
                end_node_id=node_id_map[old_seg.end_node_id],
                geometry=copy.deepcopy(old_seg.geometry),
                vessel_type=old_seg.vessel_type,
                attributes=old_seg.attributes.copy() if old_seg.attributes else {},
            )
            merged_network.add_segment(new_seg)
        
        print(f"    Merged inlet {i}: {len(network.nodes)} nodes, {len(network.segments)} segments")
    
    print(f"  Merged network: {len(merged_network.nodes)} nodes, "
          f"{len(merged_network.segments)} segments")
    
    # Final global NLP optimization on merged network
    if OBJ5_NLP_ENABLED:
        print("\n  Applying final global NLP optimization...")
        try:
            nlp_start = time.time()
            nlp_result = optimize_geometry(merged_network, nlp_config)
            nlp_time = time.time() - nlp_start
            
            if nlp_result.success:
                print(f"    Final NLP success: volume reduction {nlp_result.volume_reduction*100:.1f}% "
                      f"in {nlp_time:.1f}s")
            else:
                print(f"    Final NLP did not converge (continuing anyway)")
        except Exception as e:
            print(f"    Final NLP optimization failed: {e} (continuing anyway)")
    
    # Convert network to mesh
    print("\n  Converting network to mesh...")
    tree_mesh = None
    try:
        mesh_result = to_trimesh(merged_network, mode="voxel_repair")
        if mesh_result.is_success():
            tree_mesh = mesh_result.metadata["mesh"]
            print(f"    Tree mesh: {len(tree_mesh.vertices)} vertices, {len(tree_mesh.faces)} faces")
        else:
            print(f"    to_trimesh returned failure: {mesh_result.message}, using manual mesh construction")
    except Exception as e:
        print(f"    to_trimesh failed: {e}, using manual mesh construction")
    
    if tree_mesh is None:
        # Fallback: create mesh from segments manually
        all_segment_meshes = []
        for seg in merged_network.segments.values():
            start_node = merged_network.nodes[seg.start_node_id]
            end_node = merged_network.nodes[seg.end_node_id]
            # Convert Point3D to numpy array
            if hasattr(start_node.position, 'to_array'):
                start_pos = start_node.position.to_array()
            else:
                start_pos = np.array(start_node.position)
            if hasattr(end_node.position, 'to_array'):
                end_pos = end_node.position.to_array()
            else:
                end_pos = np.array(end_node.position)
            
            # Get radii
            if seg.geometry and hasattr(seg.geometry, 'start_radius'):
                start_r = seg.geometry.start_radius
                end_r = seg.geometry.end_radius
            else:
                start_r = OBJ5_INLET_RADIUS_M
                end_r = OBJ5_TERMINAL_RADIUS_M
            
            # Create tapered cylinder
            seg_mesh = _create_tapered_cylinder(start_pos, end_pos, start_r, end_r)
            if seg_mesh is not None:
                all_segment_meshes.append(seg_mesh)
        
        if all_segment_meshes:
            tree_mesh = voxel_union_meshes(all_segment_meshes, pitch=VOXEL_PITCH_UNION_M)
        else:
            raise RuntimeError("Failed to create tree mesh")
    
    # Subtract tree from base (carve voids)
    print("\n  Carving vascular channels from base...")
    try:
        result = base.difference(tree_mesh, engine='blender')
        if result is None or len(result.vertices) == 0:
            raise ValueError("Boolean difference returned empty mesh")
        print(f"    Blender boolean successful")
    except Exception as e:
        print(f"    Blender boolean failed ({e}), using voxel-based subtraction")
        # Voxel-based subtraction
        from skimage.measure import marching_cubes
        
        pitch = VOXEL_PITCH_UNION_M
        
        # Voxelize both meshes
        try:
            base_voxels = base.voxelized(pitch)
            tree_voxels = tree_mesh.voxelized(pitch)
        except (MemoryError, ValueError):
            pitch *= 2
            base_voxels = base.voxelized(pitch)
            tree_voxels = tree_mesh.voxelized(pitch)
        
        # Compute bounds union
        all_bounds = np.vstack([base.bounds, tree_mesh.bounds])
        min_bound = all_bounds.min(axis=0) - pitch
        max_bound = all_bounds.max(axis=0) + pitch
        
        # Create unified grid
        grid_shape = np.ceil((max_bound - min_bound) / pitch).astype(int) + 1
        base_grid = np.zeros(grid_shape, dtype=bool)
        tree_grid = np.zeros(grid_shape, dtype=bool)
        
        # Fill grids
        for vox in base_voxels.sparse_indices:
            world_pos = base_voxels.transform[:3, 3] + vox * pitch
            grid_idx = np.floor((world_pos - min_bound) / pitch).astype(int)
            if np.all(grid_idx >= 0) and np.all(grid_idx < grid_shape):
                base_grid[tuple(grid_idx)] = True
        
        for vox in tree_voxels.sparse_indices:
            world_pos = tree_voxels.transform[:3, 3] + vox * pitch
            grid_idx = np.floor((world_pos - min_bound) / pitch).astype(int)
            if np.all(grid_idx >= 0) and np.all(grid_idx < grid_shape):
                tree_grid[tuple(grid_idx)] = True
        
        # Subtract: base AND NOT tree
        result_grid = base_grid & ~tree_grid
        
        # Marching cubes
        if result_grid.sum() > 0:
            verts, faces, _, _ = marching_cubes(
                volume=result_grid.astype(np.uint8),
                level=0.5,
                spacing=(pitch, pitch, pitch),
                allow_degenerate=False,
            )
            verts += min_bound
            
            result = trimesh.Trimesh(
                vertices=verts,
                faces=faces.astype(np.int64),
                process=False,
            )
            result.remove_unreferenced_vertices()
            if result.volume < 0:
                result.invert()
            trimesh.repair.fix_normals(result)
        else:
            result = base
    
    print(f"\n  Object 5 complete: {len(result.vertices)} vertices, {len(result.faces)} faces")
    print(f"    Watertight: {result.is_watertight}")
    
    # Generate report
    report = {
        "object": "object5_cco_nlp_organic",
        "design_choices": {
            "coordinate_convention": "Cylinder centered at origin, z spans [-1mm, +1mm]",
            "inlet_z_position": f"+{meters_to_mm(CYLINDER_HEIGHT_M/2)}mm (top face)",
            "num_inlets": OBJ5_NUM_INLETS,
            "inlet_positions_mm": [[p[0]*1000, p[1]*1000, p[2]*1000] for p in OBJ5_INLET_POSITIONS],
            "num_rounds": OBJ5_NUM_ROUNDS,
            "vessel_type": OBJ5_VESSEL_TYPE,
        },
        "parameters": {
            "total_outlets_requested": OBJ5_TOTAL_OUTLETS,
            "total_outlets_achieved": total_outlets_achieved,
            "inlet_radius_mm": OBJ5_INLET_RADIUS_M * 1000,
            "terminal_radius_mm": OBJ5_TERMINAL_RADIUS_M * 1000,
            "cco_collision_clearance_mm": OBJ5_CCO_COLLISION_CLEARANCE * 1000,
            "cco_min_segment_mm": OBJ5_CCO_MIN_SEGMENT_LENGTH * 1000,
            "cco_max_segment_mm": OBJ5_CCO_MAX_SEGMENT_LENGTH * 1000,
            "nlp_enabled": OBJ5_NLP_ENABLED,
            "nlp_murray_exponent": OBJ5_NLP_MURRAY_EXPONENT,
            "voxel_pitch_mm": VOXEL_PITCH_UNION_M * 1000,
        },
        "mesh_stats": {
            "vertices": len(result.vertices),
            "faces": len(result.faces),
            "watertight": result.is_watertight,
        },
    }
    
    # Save report
    report_path = OUTPUT_DIR / "object5_cco_nlp_organic_report.json"
    with open(report_path, 'w') as f:
        json.dump(report, f, indent=2)
    print(f"  Report saved: {report_path}")
    
    return result


# =============================================================================
# MAIN EXECUTION
# =============================================================================

def main():
    """Generate all five objects and export to STL files."""
    print("=" * 70)
    print("MALARIA VENULE INSERTS GENERATOR")
    print("=" * 70)
    print("\nDesign Choices:")
    print("  - Ridge geometry: Annular ring (outer=5mm, inner=4.9mm, height=0.1mm)")
    print("  - Object 2 channels: 4 channels at (+/-1.5mm, +/-1.5mm)")
    print("  - Object 3 bifurcation: 7 levels, depths 0.25-1.75mm, taper 1mm->100um")
    print("  - Overlap-based merge: Voxel union merges overlapping void volumes")
    print("  - Object 5 CCO-NLP: 4 inlets, 4 rounds CCO + NLP, 512 terminals")
    print(f"\nVoxel pitch: {meters_to_mm(VOXEL_PITCH_M)*1000:.0f} um")
    print(f"Output units: {OUTPUT_UNITS}")
    
    # Create output directory
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    print(f"\nOutput directory: {OUTPUT_DIR}")
    
    # Generate and export each object
    objects = [
        ("object1_control.stl", generate_object1_control),
        ("object2_channels.stl", generate_object2_channels),
        ("object3_bifurcate_512.stl", generate_object3_bifurcate_512),
        ("object4_turn_bifurcate_merge.stl", generate_object4_turn_bifurcate_merge),
        ("object5_cco_nlp_organic.stl", generate_object5_cco_nlp_organic),
    ]
    
    for filename, generator_func in objects:
        try:
            mesh_m = generator_func()
            
            # Scale to millimeters
            mesh_mm = scale_mesh_to_mm(mesh_m)
            
            # Export
            output_path = OUTPUT_DIR / filename
            export_mesh_with_units(mesh_mm, output_path, units=OUTPUT_UNITS)
            
        except Exception as e:
            print(f"\nERROR generating {filename}: {e}")
            import traceback
            traceback.print_exc()
    
    print("\n" + "=" * 70)
    print("GENERATION COMPLETE")
    print("=" * 70)
    print(f"\nOutput files in: {OUTPUT_DIR}")
    print("  - object1_control.stl")
    print("  - object2_channels.stl")
    print("  - object3_bifurcate_512.stl")
    print("  - object4_turn_bifurcate_merge.stl")
    print("  - object5_cco_nlp_organic.stl")


if __name__ == "__main__":
    main()
