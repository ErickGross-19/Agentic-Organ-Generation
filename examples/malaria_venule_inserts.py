#!/usr/bin/env python3
"""
Malaria Venule Inserts Generator

This module generates five STL files for malaria venule insert scaffolds:
1. Object 1 (Control): Solid cylinder with ridge, no internal voids
2. Object 2 (Control + Channels): Control with 4 straight channels
3. Object 3 (Bifurcation 512): 4 inlets with recursive bifurcation to 512 terminals
4. Object 4 (Turn-Bifurcate-Merge): Single inlet with 90-degree turn, bifurcation, merge, return
5. Object 5 (CCO-NLP Organic): 4 inlets with CCO hybrid growth + NLP iterative optimization

DESIGN CHOICES DOCUMENTED:
- Ridge geometry: Annular ring on perimeter (outer_radius=5mm, inner_radius=4.9mm)
  Fallback: Solid raised disk if ring creation fails
- Object 2 channel count: 4 channels (minimum specified)
- Object 2 channel placement: Square pattern at (+/-1.5mm, +/-1.5mm) from center
- Object 3 bifurcation depths: 0.25, 0.50, 0.75, 1.00, 1.25, 1.50, 1.75 mm from top
- Object 3 branch taper: Exponential from 1mm to 100um over 7 levels
- Overlap-based merge strategy: Voxel union merges overlapping void volumes
- Object 5 CCO-NLP: 4 rounds of CCO growth + NLP optimization, 512 total terminals
  - Coordinate convention: Cylinder centered at origin, z spans [-1mm, +1mm]
  - Inlet z aligned with top face at z = +1mm
  - Optimized per-tree after each round, then globally on merged network

UNITS:
- Internal computations: METERS
- Output STL files: MILLIMETERS (scaled at export)

Author: Generated by Agentic Organ Generation System
"""

import sys
import os
import math
from math import sqrt, cos, sin, radians, pi  # Explicit imports to avoid shadowing issues
import json
import numpy as np
import trimesh
from pathlib import Path
from typing import List, Tuple, Optional, Dict, Any
from dataclasses import dataclass
import tempfile
from pathlib import Path
from trimesh.voxel import VoxelGrid
import shutil



# Add parent directory to path for imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from generation.core.domain import CylinderDomain
from generation.core.types import Point3D, Direction3D, TubeGeometry
from generation.core.network import VascularNetwork, Node, VesselSegment
from generation.ops.build import create_network, add_inlet
from generation.ops.growth import grow_branch, grow_to_point
from generation.adapters.mesh_adapter import to_trimesh, export_stl
from generation.ops.embedding import embed_tree_as_negative_space
from generation.rules.constraints import BranchingConstraints

# Additional imports for Object 5 (CCO-NLP)
from generation.specs.design_spec import DesignSpec, CylinderSpec, TreeSpec, InletSpec
from generation.specs.compile import compile_domain
from generation.backends.cco_hybrid_backend import CCOHybridBackend, CCOConfig
from generation.optimization import optimize_geometry, NLPConfig

# Validity checking imports
from validity import run_pre_embedding_validation, run_post_embedding_validation, ValidationConfig


# =============================================================================
# HARDCODED PARAMETERS - All dimensions in METERS internally
# =============================================================================

# --- Base Cylinder Parameters (shared by all objects) ---
CYLINDER_RADIUS_M = 0.005          # 5 mm radius = 10 mm diameter
CYLINDER_HEIGHT_M = 0.002          # 2 mm height
CYLINDER_CENTER = (0.0, 0.0, 0.0)  # Centered at origin

# --- Ridge Parameters (shared by all objects) ---
RIDGE_HEIGHT_M = 0.0001            # 0.1 mm ridge height
RIDGE_THICKNESS_M = 0.0001         # 0.1 mm ridge thickness (annular ring width)
# Ridge interpretation: Annular ring on perimeter
# - Outer radius = CYLINDER_RADIUS_M (5.0 mm)
# - Inner radius = CYLINDER_RADIUS_M - RIDGE_THICKNESS_M (4.9 mm)
# - Z range = [+1.0 mm, +1.1 mm] (top of cylinder to top of ridge)
# IMPORTANT: For voxel union to work correctly, the ridge must OVERLAP with the
# cylinder (not just touch). We extend the ridge slightly INTO the cylinder.
RIDGE_OVERLAP_M = 0.00005          # 0.05 mm overlap into cylinder for voxel union

# --- Derived Parameters ---
RIDGE_INNER_RADIUS_M = CYLINDER_RADIUS_M - RIDGE_THICKNESS_M  # 4.9 mm
TOP_FACE_Z_M = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2     # +1.0 mm
# Used by compute_inlet_positions for 2/3/N inlet layouts
INLET_PLACEMENT_FRACTION = 0.7

# =============================================================================
# HELPER FUNCTIONS FOR PARAMETER INFERENCE
# =============================================================================
def ensure_mesh_in_world_units(mesh_out: trimesh.Trimesh,
                               reference_extent_m: float,
                               voxel_transform: np.ndarray,
                               label: str = "",
                               ratio_threshold: float = 50.0) -> trimesh.Trimesh:
    """
    Some trimesh builds return marching_cubes meshes in voxel-index coordinates.
    Detect by comparing extents to an expected reference extent (meters).
    If output is wildly larger, apply voxel_transform to convert to world units.
    """
    try:
        out_extent = float(np.max(mesh_out.extents))
        if reference_extent_m > 0:
            ratio = out_extent / float(reference_extent_m)
            if ratio > ratio_threshold:
                print(f"[units-fix]{' '+label if label else ''} marching_cubes looks like voxel coords "
                      f"(out/ref={ratio:.1f}). Applying voxel transform.")
                mesh_out = mesh_out.copy()
                mesh_out.apply_transform(voxel_transform)
    except Exception as e:
        print(f"[units-fix]{' '+label if label else ''} warning: {e}")
    return mesh_out

def compute_inlet_positions(
    num_inlets: int,
    inlet_radius: float,
    cylinder_radius: float = None,
    ridge_inner_radius: float = None,
    wall_margin: float = 0.0005,
    include_z: bool = False,
    z_position: float = None,
    placement_fraction: float = None,
) -> List[Tuple[float, ...]]:
    """
    Compute inlet positions based on geometry parameters.

    Fixes:
      - avoids NameError when INLET_PLACEMENT_FRACTION defined later
      - validates max_placement_radius (prevents negative offsets)
      - uses cylinder_radius meaningfully (limit is min(cylinder_radius, ridge_inner_radius))
      - avoids relying on mutable/late globals as default args
    """
    if num_inlets == 0:
        return []

    if cylinder_radius is None:
        cylinder_radius = CYLINDER_RADIUS_M
    if ridge_inner_radius is None:
        ridge_inner_radius = RIDGE_INNER_RADIUS_M
    if placement_fraction is None:
        placement_fraction = INLET_PLACEMENT_FRACTION

    # Placement must fit inside BOTH cylinder and ridge inner radius
    limiting_radius = min(float(cylinder_radius), float(ridge_inner_radius))

    # Maximum radius for inlet center placement
    max_placement_radius = limiting_radius - float(inlet_radius) - float(wall_margin)

    if max_placement_radius <= 0:
        raise ValueError(
            f"Cannot place {num_inlets} inlets: max_placement_radius<=0.\n"
            f"  limiting_radius={limiting_radius:.6f} m\n"
            f"  inlet_radius={inlet_radius:.6f} m\n"
            f"  wall_margin={wall_margin:.6f} m\n"
            f"  (Check RIDGE_THICKNESS_M / inlet radius / wall margin.)"
        )

    # Choose symmetric layouts
    if num_inlets == 1:
        positions = [(0.0, 0.0)]

    elif num_inlets == 2:
        offset = max_placement_radius * placement_fraction
        positions = [(offset, 0.0), (-offset, 0.0)]

    elif num_inlets == 3:
        offset = max_placement_radius * placement_fraction
        positions = [
            (0.0, offset),
            (offset * cos(radians(210)), offset * sin(radians(210))),
            (offset * cos(radians(330)), offset * sin(radians(330))),
        ]

    elif num_inlets == 4:
        offset = max_placement_radius / sqrt(2.0)
        positions = [(offset, offset), (-offset, offset), (-offset, -offset), (offset, -offset)]

    else:
        offset = max_placement_radius * placement_fraction
        positions = []
        for i in range(num_inlets):
            angle = 2.0 * pi * i / num_inlets
            positions.append((offset * cos(angle), offset * sin(angle)))

    # Add Z coordinate if requested
    if include_z:
        if z_position is None:
            # Prefer TOP_FACE_Z_M if available
            if "TOP_FACE_Z_M" in globals():
                z_position = TOP_FACE_Z_M
            else:
                raise ValueError("include_z=True requires z_position (TOP_FACE_Z_M not available).")
        positions = [(x, y, float(z_position)) for x, y in positions]

    return positions


def compute_bifurcation_depths(
    num_bifurcations: int,
    cylinder_height: float = CYLINDER_HEIGHT_M,
    top_margin_fraction: float = 0.0,
    bottom_margin_fraction: float = 0.125,
) -> List[float]:
    """
    Compute bifurcation depths based on number of bifurcations and object height.
    
    Depths are evenly spaced from near the top to near the bottom of the cylinder.
    
    Parameters
    ----------
    num_bifurcations : int
        Number of bifurcation levels
    cylinder_height : float
        Height of the cylinder (in meters)
    top_margin_fraction : float
        Fraction of height to leave as margin at top (default 0)
    bottom_margin_fraction : float
        Fraction of height to leave as margin at bottom (default 0.125 = 1/8)
    
    Returns
    -------
    List of depths (in meters) from the top face
    """
    if num_bifurcations == 0:
        return []
    
    # Usable height for bifurcations
    usable_height = cylinder_height * (1 - top_margin_fraction - bottom_margin_fraction)
    start_depth = cylinder_height * top_margin_fraction
    
    # Evenly space bifurcations
    # depth[i] = start_depth + (i + 1) / (num_bifurcations + 1) * usable_height
    depths = []
    for i in range(num_bifurcations):
        depth = start_depth + (i + 1) / (num_bifurcations + 1) * usable_height
        depths.append(depth)
    
    return depths

# =============================================================================
# OBJECT 1: Control (solid cylinder + ridge, no channels)
# =============================================================================
# Object 1 has no inlets or terminals - it's a solid control sample
OBJ1_NUM_INLETS = 0                # No inlets (solid control)
OBJ1_INLET_RADIUS_M = None         # N/A for solid control
OBJ1_TERMINAL_RADIUS_M = None      # N/A for solid control

# =============================================================================
# OBJECT 2: Straight Channels
# =============================================================================
OBJ2_NUM_INLETS = 4                # 4 straight channels (range 4-9, using minimum)
OBJ2_INLET_RADIUS_M = 0.001        # 1 mm channel/inlet radius
OBJ2_TERMINAL_RADIUS_M = 0.001     # 1 mm (same as inlet - no taper for straight channels)
OBJ2_CHANNEL_DEPTH_M = 0.001       # 1 mm channel depth (extends downward from top)
OBJ2_WALL_MARGIN_M = 0.0005        # 0.5 mm minimum wall margin from cylinder edge
# Inlet positions for Object 2 - INFERRED from geometry
OBJ2_INLET_POSITIONS = compute_inlet_positions(
    num_inlets=OBJ2_NUM_INLETS,
    inlet_radius=OBJ2_INLET_RADIUS_M,
    wall_margin=OBJ2_WALL_MARGIN_M,
)

# =============================================================================
# OBJECT 3: Recursive Bifurcation (512 terminals)
# =============================================================================
OBJ3_NUM_INLETS = 4                # 4 inlet channels
OBJ3_INLET_RADIUS_M = 0.001        # 1 mm inlet radius
OBJ3_TERMINAL_RADIUS_M = 0.0001    # 100 um terminal radius
OBJ3_TOTAL_TERMINALS = 512         # Total terminal count
OBJ3_TERMINALS_PER_INLET = 128     # 512 / 4 = 128 terminals per inlet
OBJ3_BIFURCATION_LEVELS = 7        # 2^7 = 128 terminals per inlet
OBJ3_WALL_MARGIN_M = 0.0005        # 0.5 mm minimum wall margin from cylinder edge
# Bifurcation depth schedule - INFERRED from number of bifurcations and object height
OBJ3_BIFURCATION_DEPTHS_M = compute_bifurcation_depths(
    num_bifurcations=OBJ3_BIFURCATION_LEVELS,
    cylinder_height=CYLINDER_HEIGHT_M,
)
# Inlet positions for Object 3 - INFERRED from geometry
OBJ3_INLET_POSITIONS = compute_inlet_positions(
    num_inlets=OBJ3_NUM_INLETS,
    inlet_radius=OBJ3_INLET_RADIUS_M,
    wall_margin=OBJ3_WALL_MARGIN_M,
)

# =============================================================================
# OBJECT 4: Turn-Bifurcate-Merge Loop
# =============================================================================
OBJ4_NUM_INLETS = 1                # Single inlet for loop structure
OBJ4_INLET_RADIUS_M = 0.001        # 1 mm inlet radius
OBJ4_TERMINAL_RADIUS_M = 0.0005    # 500 um terminal radius (before merge back)
OBJ4_DOWNWARD_LENGTH_M = 0.001     # 1 mm downward travel before turn
OBJ4_HORIZONTAL_LENGTH_M = 0.001   # 1 mm horizontal travel after turn
OBJ4_NUM_BIFURCATIONS = 3          # Number of bifurcation levels in lateral plane
OBJ4_MERGE_OVERLAP_M = 0.0005      # 0.5 mm overlap for merge region
OBJ4_WALL_MARGIN_M = 0.0005        # 0.5 mm minimum wall margin from cylinder edge
# Inlet position for Object 4 - INFERRED from geometry (single inlet at center)
_obj4_positions = compute_inlet_positions(
    num_inlets=OBJ4_NUM_INLETS,
    inlet_radius=OBJ4_INLET_RADIUS_M,
    wall_margin=OBJ4_WALL_MARGIN_M,
)
OBJ4_INLET_POSITION = _obj4_positions[0] if _obj4_positions else (0.0, 0.0)

# =============================================================================
# OBJECT 5: CCO-NLP Organic Growth
# =============================================================================
# Coordinate convention: Cylinder centered at origin, z spans [-1mm, +1mm]
# Top face at z = +1mm = +0.001m
OBJ5_NUM_INLETS = 4                # 4 inlet channels
OBJ5_INLET_RADIUS_M = 0.001        # 1 mm inlet radius
OBJ5_TERMINAL_RADIUS_M = 0.0001    # 100 um terminal radius (minimum)
OBJ5_TOTAL_OUTLETS = 512           # Total terminal outlets (128 per inlet)
OBJ5_NUM_ROUNDS = 4                # Number of CCO growth rounds
OBJ5_OUTLETS_PER_ROUND = 32        # 512 / 4 inlets / 4 rounds = 32 per round per inlet
OBJ5_STRAIGHT_DOWN_M = 0.0001      # 0.1 mm straight down before CCO growth
OBJ5_VESSEL_TYPE = "venous"        # Vessel type for inserts
OBJ5_SEED = 42                     # Random seed for reproducibility
OBJ5_WALL_MARGIN_M = 0.0005        # 0.5 mm minimum wall margin from cylinder edge
# Inlet positions for Object 5 - INFERRED from geometry (with Z coordinate at top face)
OBJ5_INLET_POSITIONS = compute_inlet_positions(
    num_inlets=OBJ5_NUM_INLETS,
    inlet_radius=OBJ5_INLET_RADIUS_M,
    wall_margin=OBJ5_WALL_MARGIN_M,
    include_z=True,
    z_position=TOP_FACE_Z_M,
)
# CCO configuration parameters (tuned for tiny domain)
OBJ5_CCO_COLLISION_CLEARANCE = 5e-5    # 50 um collision clearance
OBJ5_CCO_MIN_SEGMENT_LENGTH = 2e-4     # 200 um minimum segment
OBJ5_CCO_MAX_SEGMENT_LENGTH = 2e-3     # 2 mm maximum segment (within 2mm height)
OBJ5_CCO_MIN_TERMINAL_SEP = 5e-5       # 50 um between terminals
OBJ5_CCO_CANDIDATE_EDGES_K = 50        # Candidate edges for optimization
OBJ5_CCO_GRID_RESOLUTION = 10          # Grid resolution for bifurcation optimization
OBJ5_CCO_USE_NLP = True                # Enable NLP-based bifurcation optimization
OBJ5_CCO_MURRAY_EXPONENT = 3.0         # Murray's law exponent
# NLP global optimization parameters
OBJ5_NLP_ENABLED = True                # Enable global NLP optimization
OBJ5_NLP_MURRAY_EXPONENT = 3.0         # Murray's law exponent
OBJ5_NLP_TARGET_PRESSURE_DROP = 13332.0  # ~100 mmHg pressure drop
OBJ5_NLP_VISCOSITY = 0.0035            # Blood viscosity (Pa*s)
OBJ5_NLP_FIX_TERMINALS = True          # Fix terminal positions
OBJ5_NLP_FIX_ROOT = True               # Fix inlet positions
OBJ5_NLP_MAX_ITERATIONS = 500          # Max optimization iterations
OBJ5_NLP_TOLERANCE = 1e-5              # Solver tolerance
OBJ5_NLP_CLEANUP_DEGENERATE = True     # Remove degenerate segments

# =============================================================================
# VOXELIZATION PARAMETERS
# =============================================================================
VOXEL_PITCH_M = 2.5e-5             # 25 um voxel pitch (for fine resolution embedding)
VOXEL_PITCH_UNION_M = 5.0e-5       # 50 um voxel pitch (for union operations)
# Note: Ridge is 0.1mm (100um) thick, so we need at least 2 voxels across it
# Using 50um pitch gives 2 voxels across the ridge thickness for proper resolution
# 25 um pitch on 10mm x 10mm x 2mm domain = ~12.8M voxels
VOXEL_PITCH_RIDGE_M = 2.5e-5       # 25 um for ridge operations (4 voxels across 0.1mm ridge)
VOXEL_RETRY_MAX_ATTEMPTS = 4       # Max retry attempts for voxelization
VOXEL_RETRY_FACTOR = 1.5           # Pitch multiplier on retry

# =============================================================================
# MESH RESOLUTION PARAMETERS
# =============================================================================
CYLINDER_MESH_SECTIONS = 64        # Number of sections for cylinder mesh
RIDGE_MESH_POINTS = 65             # Number of points for ridge mesh ring
CHANNEL_MESH_SECTIONS = 32         # Number of sections for channel mesh
TAPERED_CYLINDER_SECTIONS = 16     # Default sections for tapered cylinders

# =============================================================================
# BRANCHING CONSTRAINTS (for VascularNetwork operations)
# =============================================================================
BRANCH_MIN_SEGMENT_LENGTH_M = 1e-5   # Minimum segment length for branching
BRANCH_MAX_SEGMENT_LENGTH_M = 0.01   # Maximum segment length for branching
BRANCH_MIN_RADIUS_M = 1e-5           # Minimum radius for branching

# =============================================================================
# BIFURCATION TREE PARAMETERS (shared by Objects 3 and 4)
# =============================================================================
BIFURC_BOTTOM_MARGIN_FRACTION = 0.125    # 12.5% margin at bottom of cylinder
BIFURC_HORIZONTAL_STEP_M = 0.0002        # Small step for horizontal branches
BIFURC_MIN_SEGMENT_LENGTH_M = 0.0001     # Minimum segment length
BIFURC_MAX_GROWTH_FRACTION = 0.8         # Max growth as fraction of available space (leave 20% for next bifurcation)
BIFURC_MIN_GROWTH_DISTANCE_M = 0.0001    # Minimum growth distance
BIFURC_ANGLE_REDUCTION_PER_LEVEL = 0.1   # Angle reduction factor per bifurcation level
BIFURC_TERMINAL_SEGMENT_LENGTH_M = 0.0001  # Length of terminal segments
BIFURC_DIRECTION_THRESHOLD = 0.1         # Threshold for detecting vertical vs horizontal direction

# =============================================================================
# OBJECT 3 ADDITIONAL PARAMETERS
# =============================================================================
OBJ3_BASE_ANGLE_DEG = 30.0               # Base bifurcation angle in degrees
OBJ3_MIN_CHANNEL_DIAMETER_MM = 0.2       # Minimum channel diameter for validation (mm)
OBJ3_MIN_WALL_THICKNESS_MM = 0.3         # Minimum wall thickness for validation (mm)

# =============================================================================
# OBJECT 4 ADDITIONAL PARAMETERS
# =============================================================================
OBJ4_INLET_OFFSET_M = 0.001              # Offset from center for return path
OBJ4_TURN_RADIUS_FACTOR = 0.9            # Radius reduction factor after turn
OBJ4_BRANCH_BASE_LENGTH_M = 0.0005       # Base branch length for bifurcations
OBJ4_BRANCH_LENGTH_DECAY = 0.2           # Length decay per bifurcation level
OBJ4_BRANCH_RADIUS_DECAY = 0.8           # Radius decay per bifurcation level
OBJ4_BASE_ANGLE_DEG = 45                 # Base bifurcation angle in degrees
OBJ4_ANGLE_DECAY_PER_LEVEL_DEG = 10       # Angle reduction per bifurcation level (degrees)
OBJ4_MERGE_POINT_X_M = 0.002             # X position of merge point
OBJ4_OUTLET_X_M = 0.002                  # X position of outlet

# =============================================================================
# GEOMETRY THRESHOLDS
# =============================================================================
DEGENERATE_LENGTH_THRESHOLD = 1e-9       # Threshold for degenerate segment detection          # Fraction of max radius for inlet placement (2-3 inlets)

# =============================================================================
# OUTPUT PARAMETERS
# =============================================================================
OUTPUT_UNITS = "mm"                # Output STL files in millimeters
OUTPUT_DIR = Path(__file__).parent / "Malaria Venule Inserts"


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def meters_to_mm(value_m: float) -> float:
    """Convert meters to millimeters."""
    return value_m * 1000.0


def print_validation_details(report, indent: str = "    "):
    """
    Print detailed validation results including failure reasons.
    
    Parameters
    ----------
    report : ValidationReport
        The validation report to print details from
    indent : str
        Indentation prefix for output lines
    """
    print(f"{indent}Validation status: {report.status}")
    print(f"{indent}Passed: {report.passed}")
    
    if not report.passed or report.status != "ok":
        summary = report.summary
        print(f"{indent}Summary: {summary.get('passed_checks', '?')}/{summary.get('total_checks', '?')} checks passed, "
              f"{summary.get('failed_checks', '?')} failed, {summary.get('total_warnings', '?')} warnings")
        
        for category_name, category_report in report.reports.items():
            if not category_report.passed:
                print(f"{indent}  Category '{category_name}' FAILED:")
                for check in category_report.checks:
                    if not check.passed:
                        print(f"{indent}    - {check.check_name}: {check.message}")
                        if check.details:
                            for key, value in check.details.items():
                                print(f"{indent}        {key}: {value}")
            elif hasattr(category_report, 'checks'):
                for check in category_report.checks:
                    if check.warnings:
                        print(f"{indent}  Category '{category_name}' warnings:")
                        for warning in check.warnings:
                            print(f"{indent}    - {check.check_name}: {warning}")


def create_cylinder_mesh(radius: float, height: float, center: Tuple[float, float, float]) -> trimesh.Trimesh:
    """Create a solid cylinder mesh centered at the given point."""
    cylinder = trimesh.creation.cylinder(
        radius=radius,
        height=height,
        sections=CYLINDER_MESH_SECTIONS,
    )
    cylinder.apply_translation([center[0], center[1], center[2]])
    return cylinder

def create_ridge_mesh(
    outer_radius: float,
    inner_radius: float,
    height: float,
    z_base: float,
    center_xy: Tuple[float, float],
) -> trimesh.Trimesh:
    """
    Create a watertight annular ring (ridge) mesh via direct vertex/face construction.
    No booleans, no Blender.

    The ring is a closed solid:
      - outer wall
      - inner wall
      - top annulus
      - bottom annulus
    """
    cx, cy = center_xy

    # Choose a reasonable resolution
    n = int(globals().get("RIDGE_MESH_POINTS", 65))
    if n < 16:
        n = 16

    # Angles
    angles = np.linspace(0.0, 2.0 * np.pi, n, endpoint=False)
    c = np.cos(angles)
    s = np.sin(angles)

    z0 = float(z_base)
    z1 = float(z_base + height)

    # Vertex rings (each is length n)
    outer_bottom = np.column_stack([cx + outer_radius * c, cy + outer_radius * s, np.full(n, z0)])
    outer_top    = np.column_stack([cx + outer_radius * c, cy + outer_radius * s, np.full(n, z1)])
    inner_bottom = np.column_stack([cx + inner_radius * c, cy + inner_radius * s, np.full(n, z0)])
    inner_top    = np.column_stack([cx + inner_radius * c, cy + inner_radius * s, np.full(n, z1)])

    # Stack vertices in a known order
    # 0..n-1: outer_bottom
    # n..2n-1: outer_top
    # 2n..3n-1: inner_bottom
    # 3n..4n-1: inner_top
    vertices = np.vstack([outer_bottom, outer_top, inner_bottom, inner_top]).astype(np.float64)

    faces = []

    def idx_outer_bottom(i): return i
    def idx_outer_top(i): return n + i
    def idx_inner_bottom(i): return 2 * n + i
    def idx_inner_top(i): return 3 * n + i

    # Build quads as two triangles per segment
    for i in range(n):
        j = (i + 1) % n

        # Outer wall (winding outward)
        a = idx_outer_bottom(i)
        b = idx_outer_bottom(j)
        c1 = idx_outer_top(i)
        d = idx_outer_top(j)
        faces.append([a, c1, b])
        faces.append([b, c1, d])

        # Inner wall (winding inward => reverse compared to outer)
        a = idx_inner_bottom(i)
        b = idx_inner_bottom(j)
        c1 = idx_inner_top(i)
        d = idx_inner_top(j)
        faces.append([a, b, c1])
        faces.append([b, d, c1])

        # Top annulus (connect outer_top to inner_top)
        a = idx_outer_top(i)
        b = idx_outer_top(j)
        c1 = idx_inner_top(i)
        d = idx_inner_top(j)
        faces.append([a, b, c1])
        faces.append([b, d, c1])

        # Bottom annulus (connect outer_bottom to inner_bottom) â€“ flip winding
        a = idx_outer_bottom(i)
        b = idx_outer_bottom(j)
        c1 = idx_inner_bottom(i)
        d = idx_inner_bottom(j)
        faces.append([a, c1, b])
        faces.append([b, c1, d])

    ring = trimesh.Trimesh(vertices=vertices, faces=np.asarray(faces, dtype=np.int64), process=True)

    # Clean + repair (light but effective)
    ring.remove_unreferenced_vertices()
    ring.merge_vertices()

    # Ensure normals and winding are consistent
    if ring.volume < 0:
        ring.invert()
    trimesh.repair.fix_normals(ring)
    trimesh.repair.fill_holes(ring)

    # Final sanity
    if not ring.is_watertight:
        # One more pass; avoids tiny cracks from numerical issues
        ring.merge_vertices()
        trimesh.repair.fill_holes(ring)
        trimesh.repair.fix_normals(ring)

    print("  Ridge: Created annular ring using direct mesh construction")
    return ring


def create_channel_mesh(
    position_xy: Tuple[float, float],
    z_top: float,
    radius: float,
    depth: float,
) -> trimesh.Trimesh:
    """Create a cylindrical channel mesh extending downward from z_top."""
    channel = trimesh.creation.cylinder(
        radius=radius,
        height=depth,
        sections=CHANNEL_MESH_SECTIONS,
    )
    # Position so top of channel is at z_top
    channel.apply_translation([position_xy[0], position_xy[1], z_top - depth / 2])
    return channel


def compute_taper_radius(level: int, total_levels: int, r_start: float, r_end: float) -> float:
    """
    Compute radius at a given bifurcation level using exponential taper.
    
    r_k = r_0 * (r_end/r_0)^(k/total_levels)
    """
    if total_levels == 0:
        return r_start
    ratio = r_end / r_start
    return r_start * (ratio ** (level / total_levels))


def voxel_union_meshes(meshes: List[trimesh.Trimesh], pitch: float) -> trimesh.Trimesh:
    """
    Union multiple meshes using voxelization and marching cubes.
    
    This is the overlap-based merge strategy: overlapping volumes are
    automatically merged during voxelization.
    
    Uses the repo's voxelized_with_retry() function for robust voxelization
    with automatic retry on memory errors.
    
    IMPORTANT: Uses trimesh's native VoxelGrid.marching_cubes property instead of
    skimage.measure.marching_cubes to avoid axis/transform seam bugs that can
    create disconnected mesh components.
    """
    from validity.mesh.voxel_utils import voxelized_with_retry
    
    if not meshes:
        raise ValueError("No meshes to union")
    
    if len(meshes) == 1:
        return meshes[0]
    
    # Concatenate all meshes
    combined = trimesh.util.concatenate(meshes)
    
    # Voxelize using repo's voxelized_with_retry for robust handling of memory errors
    voxels = voxelized_with_retry(
        combined, 
        pitch, 
        max_attempts=VOXEL_RETRY_MAX_ATTEMPTS, 
        factor=VOXEL_RETRY_FACTOR,
        log_prefix="[voxel_union_meshes] ",
    )
    
    # IMPORTANT: Fill the voxel grid to get solid volumes, not just surface shells
    # Without .fill(), voxelized() returns surface occupancy which produces fragile
    # non-manifold results and nonsense volumes when passed to marching cubes
    voxels = voxels.fill()
    
    # Use trimesh's native marching_cubes property which correctly handles
    # the voxel grid transform (axis order + translation + scaling).
    # This avoids the seam/gap bugs that occur when manually applying
    # voxels.transform[:3, 3] to skimage marching_cubes output.
    result = voxels.marching_cubes

    # -------------------------------------------------------------------------
    try:
        in_extent = float(np.max(combined.extents))
        out_extent = float(np.max(result.extents))
        if in_extent > 0:
            ratio = out_extent / in_extent
            if ratio > 50.0:
                print(
                    f"[voxel_union_meshes] Detected marching_cubes in voxel coordinates "
                    f"(out/in={ratio:.1f}). Applying voxels.transform to convert to meters."
                )
                result.apply_transform(voxels.transform)
    except Exception as e:
        print(f"[voxel_union_meshes] Warning: unit sanity-check/transform failed: {e}")

    # Light cleanup pass: merge vertices and fill holes
    # Avoid aggressive face filtering that can open seams
    result.merge_vertices()
    result.remove_unreferenced_vertices()
    
    # Fill any remaining holes
    trimesh.repair.fill_holes(result)
    
    # Fix normals and winding
    if result.volume < 0:
        result.invert()
    trimesh.repair.fix_normals(result)
    
    return result


def scale_mesh_to_mm(mesh: trimesh.Trimesh) -> trimesh.Trimesh:
    """Scale mesh from meters to millimeters."""
    scaled = mesh.copy()
    scaled.apply_scale(1000.0)  # m to mm
    return scaled


def export_mesh_with_units(mesh: trimesh.Trimesh, output_path: Path, units: str = "mm"):
    """Export mesh to STL with units.json sidecar file."""
    mesh.export(str(output_path))
    
    # Write units sidecar
    sidecar_path = str(output_path) + ".units.json"
    metadata = {
        "units": units,
        "stl_file": str(output_path),
        "description": "Malaria Venule Insert scaffold",
    }
    with open(sidecar_path, 'w') as f:
        json.dump(metadata, f, indent=2)
    
    print(f"  Exported: {output_path}")
    print(f"  Units sidecar: {sidecar_path}")



def repair_mesh_for_embedding(
    mesh: trimesh.Trimesh,
    name: str = "mesh",
    keep_largest_component: bool = True, ) -> trimesh.Trimesh:
    repaired = mesh.copy()

    print(f"    Repairing {name} for embedding...")
    print(f"    Before repair: {len(repaired.vertices)} vertices, {len(repaired.faces)} faces, watertight={repaired.is_watertight}")

    # If we must preserve disconnected parts (Object 2, 3, etc),
    # DO NOT run one global meshfix pass; it can silently drop components.
    if not keep_largest_component:
        parts = repaired.split(only_watertight=False)
        print(f"    Detected {len(parts)} connected component(s); repairing each without dropping any...")

        repaired_parts = []
        try:
            from validity.mesh.repair import meshfix_repair
            for i, p in enumerate(parts):
                rp = meshfix_repair(p, keep_largest_component=True)  # safe within one component
                repaired_parts.append(rp)
        except Exception as e:
            print(f"    meshfix_repair unavailable/failed for per-component repair: {e}")
            print(f"    Falling back to trimesh per-component cleanup...")
            for p in parts:
                rp = p.copy()
                try:
                    trimesh.repair.fix_normals(rp)
                    trimesh.repair.fix_winding(rp)
                    if not rp.is_watertight:
                        trimesh.repair.fill_holes(rp)
                except Exception:
                    pass
                repaired_parts.append(rp)

        repaired = trimesh.util.concatenate(repaired_parts)

    else:
        # Original behavior: single-component repair is fine
        try:
            from validity.mesh.repair import meshfix_repair
            print(f"    Using validity library's meshfix_repair (keep_largest_component={keep_largest_component})...")
            repaired = meshfix_repair(repaired, keep_largest_component=True)
            print(f"    meshfix_repair complete")
        except Exception as e:
            print(f"    Warning: meshfix_repair failed: {e}")
            print(f"    Falling back to trimesh repair functions...")
            try:
                trimesh.repair.fix_normals(repaired)
                trimesh.repair.fix_winding(repaired)
                if not repaired.is_watertight:
                    trimesh.repair.fill_holes(repaired)
            except Exception:
                pass

    # Final cleanup (version-safe)
    try:
        if hasattr(repaired, "remove_degenerate_faces"):
            repaired.remove_degenerate_faces()
        elif hasattr(repaired, "update_faces"):
            face_areas = repaired.area_faces
            repaired.update_faces(face_areas > 0)

        repaired.remove_unreferenced_vertices()
        repaired.merge_vertices()
        trimesh.repair.fix_normals(repaired)
    except Exception as e:
        print(f"    Warning: cleanup failed: {e}")

    print(f"    After repair: {len(repaired.vertices)} vertices, {len(repaired.faces)} faces, watertight={repaired.is_watertight}")
    return repaired




def embed_void_in_cylinder(
    void_mesh: "trimesh.Trimesh",
    output_dir: "Optional[Path]" = None,
    object_name: str = "object",
    voxel_pitch: float = VOXEL_PITCH_M,
    keep_largest_component: bool = True,
) -> "trimesh.Trimesh":
    """
    Carve void_mesh out of the base cylinder using generation.ops.embedding.embed_tree_as_negative_space
    with a proper CylinderDomain object (NOT a dict).

    If the library returns a shell / outline / uncarved solid (or fails), fall back to a deterministic
    voxel subtraction using FILLED voxel grids.
    """
    # Local imports to avoid NameError in notebooks / scripts with partial imports
    import math
    import json
    import shutil
    import tempfile
    import numpy as np
    import trimesh
    from pathlib import Path
    from trimesh.voxel import VoxelGrid

    # These should already exist in your file via the repo imports at top:
    #   from generation.core.domain import CylinderDomain
    #   from generation.core.types import Point3D
    #   from generation.ops.embedding import embed_tree_as_negative_space
    # plus your helpers:
    #   create_cylinder_mesh, scale_mesh_to_mm, repair_mesh_for_embedding

    def _ensure_mesh_in_world_units(mesh_out: trimesh.Trimesh,
                                   reference_extent_m: float,
                                   voxel_transform: np.ndarray,
                                   label: str = "",
                                   ratio_threshold: float = 50.0) -> trimesh.Trimesh:
        """
        Some trimesh builds return marching_cubes in voxel index coords. Detect and apply transform.
        """
        try:
            out_extent = float(np.max(mesh_out.extents))
            if reference_extent_m > 0:
                ratio = out_extent / float(reference_extent_m)
                if ratio > ratio_threshold:
                    print(f"[units-fix]{' '+label if label else ''} marching_cubes looks like voxel coords "
                          f"(out/ref={ratio:.1f}). Applying voxel transform.")
                    m2 = mesh_out.copy()
                    m2.apply_transform(voxel_transform)
                    return m2
        except Exception as e:
            print(f"[units-fix]{' '+label if label else ''} warning: {e}")
        return mesh_out

    # ----------------------------
    # Light-clean void mesh (non-destructive)
    # ----------------------------
    void_mesh = void_mesh.copy()
    try:
        void_mesh.remove_unreferenced_vertices()
        void_mesh.merge_vertices()
        if void_mesh.volume < 0:
            void_mesh.invert()
        trimesh.repair.fix_normals(void_mesh)
    except Exception:
        pass

    # IMPORTANT: do not collapse multi-component voids (channels)
    if keep_largest_component:
        try:
            void_mesh = repair_mesh_for_embedding(
                void_mesh,
                name=f"{object_name}_void",
                keep_largest_component=True
            )
        except Exception as e:
            print(f"    Warning: repair_mesh_for_embedding failed; continuing with light-cleaned void. Error: {e}")

    void_bounds = void_mesh.bounds
    print(f"    Void mesh bounds: min={void_bounds[0]}, max={void_bounds[1]}")
    try:
        print(f"    Void mesh volume: {abs(float(void_mesh.volume)):.9f} m^3")
    except Exception:
        print("    Void mesh volume: (unable to compute)")
    print(f"    Void mesh watertight: {void_mesh.is_watertight}")

    cyl_vol = math.pi * (CYLINDER_RADIUS_M ** 2) * CYLINDER_HEIGHT_M
    void_vol = 0.0
    try:
        void_vol = abs(float(void_mesh.volume))
    except Exception:
        void_vol = 0.0
    target_solid_vol = max(cyl_vol - void_vol, 0.0)

    temp_dir = None
    try:
        # ----------------------------
        # Export void STL + units sidecar for embedding
        # ----------------------------
        temp_dir = Path(tempfile.mkdtemp(prefix=f"embed_{object_name}_"))
        void_stl_path = temp_dir / f"{object_name}_void.stl"
        void_mesh.export(str(void_stl_path))

        sidecar_path = str(void_stl_path) + ".units.json"
        with open(sidecar_path, "w") as f:
            json.dump({"units": "m"}, f)

        print(f"    Exported void mesh to: {void_stl_path}")

        if output_dir:
            intermediate_path = Path(output_dir) / "intermediate" / f"{object_name}_void_for_embedding.stl"
            intermediate_path.parent.mkdir(parents=True, exist_ok=True)
            scale_mesh_to_mm(void_mesh).export(str(intermediate_path))
            print(f"    Saved intermediate void mesh: {intermediate_path}")

        # ----------------------------
        # Build the correct library domain object (NOT dict)
        # ----------------------------
        domain = CylinderDomain(
            center=Point3D(CYLINDER_CENTER[0], CYLINDER_CENTER[1], CYLINDER_CENTER[2]),
            radius=CYLINDER_RADIUS_M,
            height=CYLINDER_HEIGHT_M,
        )

        print(f"    Cylinder domain: center={CYLINDER_CENTER}, radius={CYLINDER_RADIUS_M}m, height={CYLINDER_HEIGHT_M}m")
        print(f"    Cylinder Z range: [{CYLINDER_CENTER[2] - CYLINDER_HEIGHT_M/2}, {CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M/2}]")
        print(f"    Using embed_tree_as_negative_space with voxel_pitch={voxel_pitch*1e6:.1f}um")

        # ----------------------------
        # Primary: library embedding
        # ----------------------------
        try:
            result = embed_tree_as_negative_space(
                tree_stl_path=str(void_stl_path),
                domain=domain,
                voxel_pitch=voxel_pitch,
                stl_units="m",
                geometry_units="m",
                output_units="m",
                output_void=True,
                output_shell=False,
                smoothing_iters=0,
            )

            # Pick the best "solid" mesh from whatever the library returns
            candidates = {k: v for k, v in (result or {}).items() if isinstance(v, trimesh.Trimesh)}
            if not candidates:
                raise RuntimeError(f"embed_tree_as_negative_space returned no trimesh meshes. keys={list((result or {}).keys())}")

            def safe_vol(m: trimesh.Trimesh) -> float:
                try:
                    return abs(float(m.volume))
                except Exception:
                    return 0.0

            scored = []
            for k, m in candidates.items():
                v = safe_vol(m)
                shell_penalty = 1e9 if v < 0.30 * cyl_vol else 0.0
                oversize_penalty = 1e9 if v > 1.05 * cyl_vol else 0.0
                score = abs(v - target_solid_vol) + shell_penalty + oversize_penalty
                scored.append((score, k, m, v))

            scored.sort(key=lambda t: t[0])
            _, chosen_key, solid_mesh, chosen_vol = scored[0]
            print(f"    Using embedding output mesh key='{chosen_key}', volume={chosen_vol:.9e} m^3")

            # If voxel_counts exists, use it to reject "outline" (surface-only void)
            metadata = (result or {}).get("metadata", {}) or {}
            voxel_counts = metadata.get("voxel_counts", None)

            if isinstance(voxel_counts, dict) and voxel_counts.get("domain", 0) > 0:
                domain_voxels = int(voxel_counts.get("domain", 0))
                void_voxels = int(voxel_counts.get("void", 0))
                solid_voxels = int(voxel_counts.get("solid", domain_voxels))

                print("    Voxel counts from embedding:")
                print(f"      Domain mask: {domain_voxels} voxels")
                print(f"      Void mask:   {void_voxels} voxels")
                print(f"      Solid mask:  {solid_voxels} voxels")

                # Must remove a meaningful number of voxels
                epsilon = max(1, int(0.001 * domain_voxels))  # 0.1%
                if not (void_voxels > 0 and solid_voxels < (domain_voxels - epsilon)):
                    raise RuntimeError("Embedding mask check failed: void not meaningfully carved")

                # Detect surface-only void (outline): compare void voxels to expected volumetric voxels
                expected_void_vox = None
                try:
                    if void_mesh.is_watertight and void_vol > 0:
                        expected_void_vox = void_vol / (float(voxel_pitch) ** 3)
                except Exception:
                    expected_void_vox = None

                if expected_void_vox is not None and expected_void_vox > 0:
                    ratio = void_voxels / expected_void_vox
                    print(f"    Void voxel sanity: void_vox={void_voxels}, expected~{int(expected_void_vox)}, ratio={ratio:.4f}")
                    if ratio < 0.35:
                        raise RuntimeError("Embedding produced surface-only void mask (outline). Forcing fallback.")

            # Volume sanity: reject shells or uncarved outputs
            out_vol = abs(float(solid_mesh.volume))
            reduction_pct = (cyl_vol - out_vol) / cyl_vol * 100.0
            print(f"    Volume sanity: cyl={cyl_vol:.9e}, out={out_vol:.9e}, reduction={reduction_pct:.3f}%")

            if out_vol < 0.30 * cyl_vol:
                raise RuntimeError("Embedding output is shell-like (volume too small). Forcing fallback.")
            if reduction_pct < 0.2:
                raise RuntimeError("Embedding output looks uncarved (reduction < 0.2%). Forcing fallback.")

            # Cleanup
            try:
                solid_mesh.remove_unreferenced_vertices()
                solid_mesh.merge_vertices()
                if solid_mesh.volume < 0:
                    solid_mesh.invert()
                trimesh.repair.fix_normals(solid_mesh)
                if not solid_mesh.is_watertight:
                    trimesh.repair.fill_holes(solid_mesh)
            except Exception:
                pass

            if output_dir:
                intermediate_path = Path(output_dir) / "intermediate" / f"{object_name}_cylinder_with_void.stl"
                intermediate_path.parent.mkdir(parents=True, exist_ok=True)
                scale_mesh_to_mm(solid_mesh).export(str(intermediate_path))
                print(f"    Saved intermediate cylinder with void: {intermediate_path}")

            return solid_mesh

        except Exception as e:
            print(f"    embed_tree_as_negative_space rejected/failed: {e}")
            print(f"    Using direct voxel subtraction fallback...")

        # ----------------------------
        # Fallback: deterministic FILLED voxel subtraction on a padded common grid
        # ----------------------------
        cylinder = create_cylinder_mesh(CYLINDER_RADIUS_M, CYLINDER_HEIGHT_M, CYLINDER_CENTER)

        pad = 2 * float(voxel_pitch)
        domain_min = np.array(
            [-CYLINDER_RADIUS_M, -CYLINDER_RADIUS_M, CYLINDER_CENTER[2] - CYLINDER_HEIGHT_M / 2],
            dtype=float
        )
        domain_max = np.array(
            [ CYLINDER_RADIUS_M,  CYLINDER_RADIUS_M, CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2],
            dtype=float
        )
        domain_min_padded = domain_min - pad
        domain_max_padded = domain_max + pad

        grid_shape = np.ceil((domain_max_padded - domain_min_padded) / float(voxel_pitch)).astype(int) + 1
        grid_shape = np.maximum(grid_shape, 1)

        cyl_vox = cylinder.voxelized(float(voxel_pitch)).fill()
        cyl_matrix = cyl_vox.matrix.astype(bool)
        cyl_origin = cyl_vox.transform[:3, 3].astype(float)

        void_vox = void_mesh.voxelized(float(voxel_pitch)).fill()
        void_matrix = void_vox.matrix.astype(bool)
        void_origin = void_vox.transform[:3, 3].astype(float)

        aligned_cyl = np.zeros(tuple(grid_shape), dtype=bool)
        aligned_void = np.zeros(tuple(grid_shape), dtype=bool)

        def paste_into(dst: np.ndarray, src: np.ndarray, src_origin: np.ndarray):
            src_origin = np.asarray(src_origin, dtype=float)
            offset_vox = np.round((src_origin - domain_min_padded) / float(voxel_pitch)).astype(int)

            src_start = np.maximum(-offset_vox, 0)
            dst_start = np.maximum(offset_vox, 0)

            copy_size = np.minimum(src.shape - src_start, dst.shape - dst_start)
            copy_size = np.maximum(copy_size, 0)

            if np.all(copy_size > 0):
                dst[
                    dst_start[0]:dst_start[0] + copy_size[0],
                    dst_start[1]:dst_start[1] + copy_size[1],
                    dst_start[2]:dst_start[2] + copy_size[2],
                ] = src[
                    src_start[0]:src_start[0] + copy_size[0],
                    src_start[1]:src_start[1] + copy_size[1],
                    src_start[2]:src_start[2] + copy_size[2],
                ]

        paste_into(aligned_cyl, cyl_matrix, cyl_origin)
        paste_into(aligned_void, void_matrix, void_origin)

        print(f"    Cylinder voxels: {int(aligned_cyl.sum())}")
        print(f"    Void voxels:     {int(aligned_void.sum())}")

        result_mask = aligned_cyl & (~aligned_void)
        print(f"    Result voxels:   {int(result_mask.sum())}")

        if not result_mask.any():
            raise RuntimeError("Result mask is empty after voxel subtraction")

        T = np.eye(4, dtype=float)
        T[0, 0] = float(voxel_pitch)
        T[1, 1] = float(voxel_pitch)
        T[2, 2] = float(voxel_pitch)
        T[:3, 3] = domain_min_padded

        vg = VoxelGrid(result_mask, transform=T)
        solid_mesh = vg.marching_cubes

        ref_extent = max(2.0 * CYLINDER_RADIUS_M, CYLINDER_HEIGHT_M)
        solid_mesh = _ensure_mesh_in_world_units(solid_mesh, ref_extent, vg.transform, label="embed_fallback")

        try:
            solid_mesh.remove_unreferenced_vertices()
            solid_mesh.merge_vertices()
            if solid_mesh.volume < 0:
                solid_mesh.invert()
            trimesh.repair.fix_normals(solid_mesh)
            if not solid_mesh.is_watertight:
                trimesh.repair.fill_holes(solid_mesh)
        except Exception:
            pass

        print(f"    Fallback complete: {len(solid_mesh.vertices)} vertices, {len(solid_mesh.faces)} faces")
        print(f"    Watertight: {solid_mesh.is_watertight}")

        if output_dir:
            intermediate_path = Path(output_dir) / "intermediate" / f"{object_name}_cylinder_with_void.stl"
            intermediate_path.parent.mkdir(parents=True, exist_ok=True)
            scale_mesh_to_mm(solid_mesh).export(str(intermediate_path))
            print(f"    Saved intermediate cylinder with void: {intermediate_path}")

        return solid_mesh

    finally:
        if temp_dir is not None:
            shutil.rmtree(temp_dir, ignore_errors=True)


# =============================================================================
# OBJECT GENERATION FUNCTIONS
# =============================================================================

def generate_object1_control(output_dir: Optional[Path] = None) -> trimesh.Trimesh:
    """
    Generate Object 1: Solid cylinder + ridge (no internal voids).

    Key fix:
      - Ridge MUST overlap into cylinder (not just touch) to ensure voxel union merges it.
      - We reuse the same 'add_ridge_to_mesh' pipeline used for other objects to avoid regressions.
    """
    print("\n" + "=" * 60)
    print("Generating Object 1: Control (solid cylinder + ridge)")
    print("=" * 60)

    # Base cylinder
    print("  Creating base cylinder...")
    base_cylinder = create_cylinder_mesh(
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
        center=CYLINDER_CENTER,
    )
    print(f"    Cylinder: radius={meters_to_mm(CYLINDER_RADIUS_M):.1f}mm, height={meters_to_mm(CYLINDER_HEIGHT_M):.1f}mm")

    # Save intermediate cylinder
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object1_cylinder.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(base_cylinder).export(str(intermediate_path))
        print(f"    Exported intermediate: {intermediate_path}")

    # Add ridge using the centralized ridge adder if available
    # (this uses RIDGE_OVERLAP_M and VOXEL_PITCH_RIDGE_M)
    if "add_ridge_to_mesh" in globals():
        print("  Adding ridge (using add_ridge_to_mesh with overlap)...")
        combined = add_ridge_to_mesh(base_cylinder)
    else:
        # Fallback inline ridge add (still uses overlap)
        print("  Adding ridge (inline fallback)...")
        z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
        overlap = float(globals().get("RIDGE_OVERLAP_M", 0.0))
        ridge_z_base = z_top - overlap
        ridge_total_height = RIDGE_HEIGHT_M + overlap

        ridge = create_ridge_mesh(
            outer_radius=CYLINDER_RADIUS_M,
            inner_radius=CYLINDER_RADIUS_M - RIDGE_THICKNESS_M,
            height=ridge_total_height,
            z_base=ridge_z_base,
            center_xy=(CYLINDER_CENTER[0], CYLINDER_CENTER[1]),
        )

        if output_dir:
            ridge_path = output_dir / "intermediate" / "object1_ridge.stl"
            scale_mesh_to_mm(ridge).export(str(ridge_path))
            print(f"    Exported intermediate: {ridge_path}")

        print(f"  Combining cylinder and ridge (voxel pitch: {meters_to_mm(VOXEL_PITCH_RIDGE_M)*1000:.0f}um)...")
        combined = voxel_union_meshes([base_cylinder, ridge], pitch=VOXEL_PITCH_RIDGE_M)

    print(f"  Object 1 complete: {len(combined.vertices)} vertices, {len(combined.faces)} faces")
    print(f"    Watertight: {combined.is_watertight}")
    print(f"    Bounds (m): {combined.bounds}")

    # OPTIONAL: validation for Object 1 is often misleading (it runs channel checks on a control).
    # If you still want it, keep it, but it should not be used to judge ridge success.
    try:
        if "ValidationConfig" in globals() and "run_post_embedding_validation" in globals():
            print("  Running validation (control object)...")
            validation_config = ValidationConfig(
                voxel_pitch_m=VOXEL_PITCH_M,
                expected_outlets=0,
            )
            report = run_post_embedding_validation(mesh=combined, config=validation_config)
            print_validation_details(report)
    except Exception as e:
        print(f"    Validation error (ignored for control object): {e}")

    return combined


def generate_object2_channels(output_dir: Optional[Path] = None) -> trimesh.Trimesh:
    """
    Generate Object 2: Control + straight channels.
    
    Design choice: 4 channels in a square pattern at (+/-1.5mm, +/-1.5mm).
    Uses the repo's embed_tree_as_negative_space function for embedding.
    
    Returns mesh in METERS (will be scaled to mm at export).
    
    Parameters
    ----------
    output_dir : Path, optional
        Directory to save intermediate STL files for debugging
    """
    print("\n" + "=" * 60)
    print("Generating Object 2: Control + straight channels")
    print("=" * 60)
    
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    
    # Create channels
    print(f"  Creating {OBJ2_NUM_INLETS} straight channels...")
    
    channels = []
    for i, pos in enumerate(OBJ2_INLET_POSITIONS[:OBJ2_NUM_INLETS]):
        channel = create_channel_mesh(
            position_xy=pos,
            z_top=z_top,
            radius=OBJ2_INLET_RADIUS_M,
            depth=OBJ2_CHANNEL_DEPTH_M,
        )
        channels.append(channel)
        print(f"    Channel {i+1}: position=({meters_to_mm(pos[0]):.1f}, {meters_to_mm(pos[1]):.1f})mm, "
              f"radius={meters_to_mm(OBJ2_INLET_RADIUS_M)}mm, depth={meters_to_mm(OBJ2_CHANNEL_DEPTH_M)}mm")
    
    # Union all channels
    print("  Combining channels...")
    channel_void = voxel_union_meshes(channels, pitch=VOXEL_PITCH_UNION_M)
    
    # Export intermediate channel void mesh
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object2_channel_void.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(channel_void).export(str(intermediate_path))
        print(f"    Exported intermediate void: {intermediate_path}")
    
    # Run pre-embedding validation on channel void mesh
    print("  Running pre-embedding validation on channel void mesh...")
    try:
        pre_report = run_pre_embedding_validation(mesh=channel_void)
        print_validation_details(pre_report)
    except Exception as e:
        print(f"    Pre-embedding validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Use the repo's embed_tree_as_negative_space function to carve channels from cylinder
    print("  Carving channels using embed_tree_as_negative_space...")
    cylinder_with_void = embed_void_in_cylinder(
        void_mesh=channel_void,
        output_dir=output_dir,
        object_name="object2",
        voxel_pitch=VOXEL_PITCH_M,
        keep_largest_component=False,
    )
    
    # Export intermediate cylinder with void (before ridge)
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object2_cylinder_with_void.stl"
        scale_mesh_to_mm(cylinder_with_void).export(str(intermediate_path))
        print(f"    Exported intermediate cylinder with void: {intermediate_path}")
    
    print(f"  Cylinder with void: {len(cylinder_with_void.vertices)} vertices, {len(cylinder_with_void.faces)} faces")
    print(f"    Watertight: {cylinder_with_void.is_watertight}")
    
    # Run post-embedding validation on cylinder with void (before adding ridge)
    # Run post-embedding validation on cylinder with void (before adding ridge)
    print("  Running validation on cylinder with void...")
    try:
        validation_config = ValidationConfig(
            voxel_pitch_m=VOXEL_PITCH_M * 1000.0,  # convert meters -> millimeters for validator
            expected_outlets=OBJ2_NUM_INLETS,
        )
        report = run_post_embedding_validation(
            mesh=scale_mesh_to_mm(cylinder_with_void),  # validate in mm
            config=validation_config
        )
        print_validation_details(report)
    except Exception as e:
        print(f"    Validation error: {e}")
        import traceback
        traceback.print_exc()

    
    # Return cylinder_with_void - ridge will be added at the END in main() to prevent smoothing
    return cylinder_with_void


def generate_bifurcation_tree_mesh(
    inlet_position: Tuple[float, float, float],
    inlet_radius: float,
    terminal_radius: float,
    bifurcation_depths: List[float],
    base_angle_deg: float = 30.0,
    rng_seed: Optional[int] = None,
    growth_fraction_range: Tuple[float, float] = (0.3, 0.7),
) -> trimesh.Trimesh:
    """
    Generate a bifurcating tree mesh from a single inlet.

    Key fix vs your current version:
    - Before each pre-bifurcation grow_to_point, clamp the step length so the target stays
      inside the cylinder (prevents "Target point ... is outside domain" warnings).
    """
    # Import inside function for robustness (matches your Object 4 style)
    from generation.ops.growth import grow_to_point, bifurcate
    from generation.rules.constraints import BranchingConstraints

    rng = np.random.default_rng(rng_seed)

    num_levels = len(bifurcation_depths)
    if num_levels == 0:
        return trimesh.Trimesh()

    # Cylinder bounds
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    z_bottom = CYLINDER_CENTER[2] - CYLINDER_HEIGHT_M / 2

    # Create network + domain (Point3D required by the library)
    domain = CylinderDomain(
        center=Point3D(*CYLINDER_CENTER),
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
    )
    network = create_network(domain, seed=rng_seed)

    constraints = BranchingConstraints(
        min_segment_length=BRANCH_MIN_SEGMENT_LENGTH_M,
        max_segment_length=BRANCH_MAX_SEGMENT_LENGTH_M,
        min_radius=BRANCH_MIN_RADIUS_M,
    )

    # Add inlet
    inlet_result = add_inlet(
        network,
        position=Point3D(*inlet_position),
        direction=(0.0, 0.0, -1.0),
        radius=inlet_radius,
        vessel_type="venous",
    )
    if not inlet_result.is_success():
        print(f"    Warning: Failed to add inlet: {inlet_result.message}")
        return trimesh.Trimesh()

    root_id = inlet_result.new_ids["node"]
    root_node = network.get_node(root_id)
    if root_node:
        root_node.attributes["direction"] = {"dx": 0.0, "dy": 0.0, "dz": -1.0}

    # Helper: max step along direction inside cylinder (with margins)
    def _max_step_inside_cylinder(
        p: np.ndarray,
        d: np.ndarray,
        r_effective: float,
        zmin: float,
        zmax: float,
    ) -> float:
        """
        Return the maximum t >= 0 such that p + t*d stays inside:
          x^2 + y^2 <= r_effective^2 and z in [zmin, zmax]
        """
        eps = 1e-12
        dx, dy, dz = float(d[0]), float(d[1]), float(d[2])
        x, y, z = float(p[0]), float(p[1]), float(p[2])

        t_candidates = []

        # Z planes
        if dz > eps:
            t_candidates.append((zmax - z) / dz)
        elif dz < -eps:
            t_candidates.append((zmin - z) / dz)

        # Side wall: (x + t dx)^2 + (y + t dy)^2 = r^2
        a = dx * dx + dy * dy
        if a > eps:
            b = 2.0 * (x * dx + y * dy)
            c = (x * x + y * y) - (r_effective * r_effective)
            disc = b * b - 4.0 * a * c
            if disc >= 0.0:
                sdisc = math.sqrt(disc)
                t1 = (-b - sdisc) / (2.0 * a)
                t2 = (-b + sdisc) / (2.0 * a)
                # We want the first positive intersection ahead
                for t in (t1, t2):
                    if t > eps:
                        t_candidates.append(t)

        # If no intersections found (should be rare), treat as unbounded
        if not t_candidates:
            return float("inf")

        # Smallest positive boundary hit
        t_pos = [t for t in t_candidates if t > eps]
        if not t_pos:
            return 0.0
        return min(t_pos)

    # Tips tracked as (node_id, level_index)
    current_tips: List[Tuple[str, int]] = [(root_id, 0)]

    for level in range(num_levels):
        depth = float(bifurcation_depths[level])
        target_z = float(inlet_position[2]) - depth

        # Distance between this level and next (controls child growth lengths)
        if level + 1 < num_levels:
            next_depth = float(bifurcation_depths[level + 1])
            distance_between_levels = max(next_depth - depth, BIFURC_MIN_SEGMENT_LENGTH_M)
        else:
            # Last level: remaining distance to bottom, leaving a margin
            bottom_z_allowed = float(inlet_position[2]) - CYLINDER_HEIGHT_M * (1.0 - BIFURC_BOTTOM_MARGIN_FRACTION)
            distance_between_levels = depth - (float(inlet_position[2]) - bottom_z_allowed)
            distance_between_levels = max(distance_between_levels, BIFURC_MIN_SEGMENT_LENGTH_M)

        new_tips: List[Tuple[str, int]] = []

        for tip_node_id, tip_level in current_tips:
            if tip_level != level:
                new_tips.append((tip_node_id, tip_level))
                continue

            tip_node = network.get_node(tip_node_id)
            if tip_node is None:
                continue

            tip_pos = np.array([tip_node.position.x, tip_node.position.y, tip_node.position.z], dtype=float)

            tip_dir_dict = tip_node.attributes.get("direction", {"dx": 0.0, "dy": 0.0, "dz": -1.0})
            tip_dir = np.array(
                [float(tip_dir_dict.get("dx", 0.0)),
                 float(tip_dir_dict.get("dy", 0.0)),
                 float(tip_dir_dict.get("dz", -1.0))],
                dtype=float
            )

            # Normalize direction for stable stepping
            nrm = float(np.linalg.norm(tip_dir))
            if nrm < 1e-12:
                tip_dir = np.array([0.0, 0.0, -1.0], dtype=float)
            else:
                tip_dir = tip_dir / nrm

            current_radius = float(compute_taper_radius(level, num_levels, inlet_radius, terminal_radius))
            next_radius = float(compute_taper_radius(level + 1, num_levels, inlet_radius, terminal_radius))

            # Base dist_to_target (your original logic)
            if abs(tip_dir[2]) > BIFURC_DIRECTION_THRESHOLD:
                dist_to_target = abs((target_z - tip_pos[2]) / tip_dir[2])
            else:
                dist_to_target = BIFURC_HORIZONTAL_STEP_M

            dist_to_target = max(dist_to_target, BIFURC_MIN_SEGMENT_LENGTH_M)

            # -------------------------
            # CRITICAL FIX: clamp step so target stays inside cylinder
            # Use an effective radius that accounts for vessel radius + wall margin.
            # -------------------------
            wall_margin = float(globals().get("OBJ3_WALL_MARGIN_M", 0.0))
            r_eff = CYLINDER_RADIUS_M - wall_margin - current_radius
            r_eff = max(r_eff, 1e-6)

            # Keep a tiny z-margin to avoid landing exactly on caps
            z_margin = 2.0 * float(globals().get("VOXEL_PITCH_M", 2.5e-5))
            zmin_eff = z_bottom + z_margin
            zmax_eff = z_top - z_margin

            t_max = _max_step_inside_cylinder(tip_pos, tip_dir, r_eff, zmin_eff, zmax_eff)

            safety = 0.95
            if t_max != float("inf"):
                dist_to_target = min(dist_to_target, safety * t_max)

            if dist_to_target < BIFURC_MIN_SEGMENT_LENGTH_M:
                # Not enough room to place the next bifurcation point safely
                print(f"    Warning: insufficient room to grow at level {level} from tip; skipping branch.")
                continue

            bifurc_pos = tip_pos + tip_dir * dist_to_target

            grow_result = grow_to_point(
                network,
                from_node_id=tip_node_id,
                target_point=tuple(bifurc_pos),
                target_radius=current_radius,
                constraints=constraints,
                check_collisions=False,
                fail_on_collision=False,
            )
            if not grow_result.is_success():
                print(f"    Warning: grow_to_point failed at level {level}: {grow_result.message}")
                continue

            bifurc_node_id = grow_result.new_ids["node"]

            # Child growth distances (your existing grow->bifurcate->grow pattern)
            max_growth = distance_between_levels * BIFURC_MAX_GROWTH_FRACTION

            g1 = float(rng.uniform(growth_fraction_range[0], growth_fraction_range[1]))
            growth_distance1 = min(g1 * distance_between_levels, max_growth)
            growth_distance1 = max(growth_distance1, BIFURC_MIN_GROWTH_DISTANCE_M)

            g2 = float(rng.uniform(growth_fraction_range[0], growth_fraction_range[1]))
            growth_distance2 = min(g2 * distance_between_levels, max_growth)
            growth_distance2 = max(growth_distance2, BIFURC_MIN_GROWTH_DISTANCE_M)

            angle_deg = float(base_angle_deg) * (1.0 - BIFURC_ANGLE_REDUCTION_PER_LEVEL * level)

            bifurc_result = bifurcate(
                network,
                at_node_id=bifurc_node_id,
                child_lengths=(growth_distance1, growth_distance2),
                angle_deg=angle_deg,
                constraints=constraints,
                check_collisions=False,
                seed=rng_seed,
            )
            if not bifurc_result.is_success():
                print(f"    Warning: bifurcate failed at level {level}: {bifurc_result.message}")
                continue

            child_node_ids = bifurc_result.new_ids.get("nodes", [])
            for child_node_id in child_node_ids:
                child_node = network.get_node(child_node_id)
                if child_node:
                    child_node.attributes["radius"] = next_radius
                new_tips.append((child_node_id, level + 1))

        current_tips = new_tips

    # Add short terminal segments
    for tip_node_id, _tip_level in current_tips:
        tip_node = network.get_node(tip_node_id)
        if tip_node is None:
            continue

        tip_pos = np.array([tip_node.position.x, tip_node.position.y, tip_node.position.z], dtype=float)
        tip_dir_dict = tip_node.attributes.get("direction", {"dx": 0.0, "dy": 0.0, "dz": -1.0})
        tip_dir = np.array(
            [float(tip_dir_dict.get("dx", 0.0)),
             float(tip_dir_dict.get("dy", 0.0)),
             float(tip_dir_dict.get("dz", -1.0))],
            dtype=float
        )
        nrm = float(np.linalg.norm(tip_dir))
        if nrm < 1e-12:
            tip_dir = np.array([0.0, 0.0, -1.0], dtype=float)
        else:
            tip_dir = tip_dir / nrm

        end_pos = tip_pos + tip_dir * BIFURC_TERMINAL_SEGMENT_LENGTH_M

        _ = grow_to_point(
            network,
            from_node_id=tip_node_id,
            target_point=tuple(end_pos),
            target_radius=terminal_radius,
            constraints=constraints,
            check_collisions=False,
            fail_on_collision=False,
        )

    # Convert to mesh
    print(f"    Converting network to mesh ({len(network.segments)} segments).")
    mesh_result = to_trimesh(network, mode="fast", include_caps=True, include_node_spheres=False)

    if mesh_result.is_success():
        return mesh_result.metadata["mesh"]
    else:
        print(f"    Warning: to_trimesh failed: {mesh_result.message}")
        return trimesh.Trimesh()


def _create_tapered_cylinder(
    start: np.ndarray,
    end: np.ndarray,
    radius_start: float,
    radius_end: float,
    sections: int = TAPERED_CYLINDER_SECTIONS,
) -> trimesh.Trimesh:
    """Create a tapered cylinder (frustum) between two points."""
    direction = end - start
    length = np.linalg.norm(direction)
    
    if length < DEGENERATE_LENGTH_THRESHOLD:
        # Degenerate segment, return small sphere
        sphere = trimesh.creation.icosphere(subdivisions=1, radius=radius_start)
        sphere.apply_translation(start)
        return sphere
    
    direction = direction / length
    
    # Create frustum along Z axis
    if abs(radius_start - radius_end) < 1e-10:
        frustum = trimesh.creation.cylinder(
            radius=radius_start,
            height=length,
            sections=sections,
        )
    else:
        # Manual frustum creation
        angles = np.linspace(0, 2 * np.pi, sections, endpoint=False)
        
        z_bottom = -length / 2
        z_top = length / 2
        
        bottom_verts = np.column_stack([
            radius_start * np.cos(angles),
            radius_start * np.sin(angles),
            np.full(sections, z_bottom),
        ])
        
        top_verts = np.column_stack([
            radius_end * np.cos(angles),
            radius_end * np.sin(angles),
            np.full(sections, z_top),
        ])
        
        # Center vertices for caps
        center_bottom = np.array([[0, 0, z_bottom]])
        center_top = np.array([[0, 0, z_top]])
        
        vertices = np.vstack([bottom_verts, top_verts, center_bottom, center_top])
        
        faces = []
        # Side faces
        for i in range(sections):
            i_next = (i + 1) % sections
            faces.append([i, i_next, i + sections])
            faces.append([i_next, i_next + sections, i + sections])
        
        # Bottom cap
        center_bottom_idx = 2 * sections
        for i in range(sections):
            i_next = (i + 1) % sections
            faces.append([center_bottom_idx, i_next, i])
        
        # Top cap
        center_top_idx = 2 * sections + 1
        for i in range(sections):
            i_next = (i + 1) % sections
            faces.append([center_top_idx, i + sections, i_next + sections])
        
        frustum = trimesh.Trimesh(vertices=vertices, faces=np.array(faces))
    
    # Rotate to align with direction
    z_axis = np.array([0, 0, 1])
    if not np.allclose(direction, z_axis) and not np.allclose(direction, -z_axis):
        rotation_axis = np.cross(z_axis, direction)
        if np.linalg.norm(rotation_axis) > 1e-6:
            rotation_axis = rotation_axis / np.linalg.norm(rotation_axis)
            angle = np.arccos(np.clip(np.dot(z_axis, direction), -1, 1))
            rotation_matrix = trimesh.transformations.rotation_matrix(angle, rotation_axis)
            frustum.apply_transform(rotation_matrix)
    elif np.allclose(direction, -z_axis):
        rotation_matrix = trimesh.transformations.rotation_matrix(np.pi, [1, 0, 0])
        frustum.apply_transform(rotation_matrix)
    
    # Translate to position
    center = (start + end) / 2
    frustum.apply_translation(center)
    
    return frustum


def generate_object3_bifurcate_512(output_dir: Optional[Path] = None) -> trimesh.Trimesh:
    """
    Generate Object 3: Recursive bifurcation to 512 terminals.
    
    Design choices:
    - 4 inlets at symmetric positions near center
    - 7 bifurcation levels per inlet (2^7 = 128 terminals each)
    - Exponential radius taper from 1mm to 100um
    - Bifurcation depths at 0.25, 0.50, 0.75, 1.00, 1.25, 1.50, 1.75 mm
    - Overlapping branches merge via voxel union
    - Uses the repo's embed_tree_as_negative_space function for embedding
    
    Returns mesh in METERS (will be scaled to mm at export).
    
    Parameters
    ----------
    output_dir : Path, optional
        Directory to save intermediate STL files for debugging
    """
    print("\n" + "=" * 60)
    print("Generating Object 3: Recursive bifurcation to 512 terminals")
    print("=" * 60)
    
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    
    # Generate bifurcating trees from each inlet
    print(f"  Generating {OBJ3_NUM_INLETS} bifurcating trees...")
    all_trees = []
    
    for i, (x, y) in enumerate(OBJ3_INLET_POSITIONS):
        print(f"    Tree {i+1}: inlet at ({meters_to_mm(x):.1f}, {meters_to_mm(y):.1f})mm")
        inlet_pos = (x, y, z_top)
        
        tree_mesh = generate_bifurcation_tree_mesh(
            inlet_position=inlet_pos,
            inlet_radius=OBJ3_INLET_RADIUS_M,
            terminal_radius=OBJ3_TERMINAL_RADIUS_M,
            bifurcation_depths=OBJ3_BIFURCATION_DEPTHS_M,
            base_angle_deg=OBJ3_BASE_ANGLE_DEG,
        )
        all_trees.append(tree_mesh)
        print(f"      Generated tree with {len(tree_mesh.vertices)} vertices")
    
    # Union all trees (overlapping branches merge)
    print("  Combining all trees (overlap-based merge)...")
    combined_void = voxel_union_meshes(all_trees, pitch=VOXEL_PITCH_UNION_M)
    
    # Export intermediate tree void mesh
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object3_tree_void.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(combined_void).export(str(intermediate_path))
        print(f"    Exported intermediate void: {intermediate_path}")
    
    # Run pre-embedding validation on tree mesh
    print("  Running pre-embedding validation on tree mesh...")
    try:
        pre_report = run_pre_embedding_validation(mesh=combined_void)
        print_validation_details(pre_report)
    except Exception as e:
        print(f"    Pre-embedding validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Use the repo's embed_tree_as_negative_space function to carve voids from cylinder
    # NOTE: keep_largest_component=False to preserve all 4 inlet trees
    # (they are disconnected and would otherwise be dropped by meshfix_repair)
    print("  Carving voids using embed_tree_as_negative_space...")
    cylinder_with_void = embed_void_in_cylinder(
        void_mesh=combined_void,
        output_dir=output_dir,
        object_name="object3",
        voxel_pitch=VOXEL_PITCH_M,
        keep_largest_component=False,  # Preserve all 4 inlet trees
    )
    
    # Export intermediate cylinder with void (before ridge)
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object3_cylinder_with_void.stl"
        scale_mesh_to_mm(cylinder_with_void).export(str(intermediate_path))
        print(f"    Exported intermediate cylinder with void: {intermediate_path}")
    
    print(f"  Cylinder with void: {len(cylinder_with_void.vertices)} vertices, {len(cylinder_with_void.faces)} faces")
    print(f"    Watertight: {cylinder_with_void.is_watertight}")
    
    # Run post-embedding validation on cylinder with void (before adding ridge)
    # NOTE: Validation thresholds are adjusted for Object 3's design:
    # - expected_outlets = OBJ3_NUM_INLETS (4), not OBJ3_TOTAL_TERMINALS (512)
    #   because the 512 terminals are internal, not external openings
    # - min_channel_diameter = 0.2mm to match the terminal diameter (2 * 100Âµm)
    print("  Running post-embedding validation on cylinder with void...")
    try:
        from validity.post_embedding.printability_checks import ManufacturingConfig
        validation_config = ValidationConfig(
            voxel_pitch_m=VOXEL_PITCH_M,
            expected_outlets=OBJ3_NUM_INLETS,  # 4 inlets, not 512 internal terminals
            manufacturing=ManufacturingConfig(
                min_channel_diameter=OBJ3_MIN_CHANNEL_DIAMETER_MM,  # 2 * terminal radius (100Âµm = 0.1mm)
                min_wall_thickness=OBJ3_MIN_WALL_THICKNESS_MM,
            ),
        )
        report = run_post_embedding_validation(mesh=cylinder_with_void, config=validation_config)
        print_validation_details(report)
    except Exception as e:
        print(f"    Validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Return cylinder_with_void - ridge will be added at the END in main() to prevent smoothing
    return cylinder_with_void


def generate_object4_turn_bifurcate_merge(
    output_dir: Optional[Path] = None,
    rng_seed: Optional[int] = None,
    growth_fraction_range: Tuple[float, float] = (0.3, 0.7),
) -> trimesh.Trimesh:
    """
    Generate Object 4: Single inlet, 90-degree turn, bifurcate, merge, return.
    
    Uses the pre-built grow_to_point and bifurcate tools from the generation library.
    Implements grow -> bifurcate -> grow pattern where branches grow for an RNG-based
    distance before bifurcating, ensuring proper separation between branches.
    
    Design choices:
    - Single inlet at center top face, radius 1mm
    - Travel downward 1mm
    - Turn 90 degrees (along +X direction)
    - Bifurcate in XY plane with grow -> bifurcate -> grow pattern
    - Branches merge by overlapping in space (voxel union)
    - Single trunk returns upward to exit near top face
    - Uses the repo's embed_tree_as_negative_space function for embedding
    
    Returns mesh in METERS (will be scaled to mm at export).
    
    Parameters
    ----------
    output_dir : Path, optional
        Directory to save intermediate STL files for debugging
    rng_seed : int, optional
        Random seed for reproducible growth distances
    growth_fraction_range : tuple
        (min, max) fraction of available distance for post-bifurcation growth.
        Growth distance is calculated as: fraction * branch_length
        This ensures branches separate before the next bifurcation while leaving
        enough space to bifurcate before reaching the edge.
    """
    from generation.ops.growth import grow_to_point, grow_branch, bifurcate
    from generation.rules.constraints import BranchingConstraints
    from generation.core.types import Direction3D
    
    print("\n" + "=" * 60)
    print("Generating Object 4: Turn-Bifurcate-Merge loop")
    print("=" * 60)
    
    rng = np.random.default_rng(rng_seed)
    
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    z_bottom = CYLINDER_CENTER[2] - CYLINDER_HEIGHT_M / 2
    
    # Create a VascularNetwork with a cylinder domain
    domain = CylinderDomain(
        center=Point3D(*CYLINDER_CENTER),
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
    )

    network = create_network(domain, seed=rng_seed)
    
    # Set up constraints with relaxed limits for small geometry
    constraints = BranchingConstraints(
        min_segment_length=BRANCH_MIN_SEGMENT_LENGTH_M,
        max_segment_length=BRANCH_MAX_SEGMENT_LENGTH_M,
        min_radius=BRANCH_MIN_RADIUS_M,
    )
    
    # Inlet position (slightly offset from center to allow return path)
    inlet_x = OBJ4_INLET_POSITION[0] - OBJ4_INLET_OFFSET_M  # Offset from center to allow return path
    inlet_y = OBJ4_INLET_POSITION[1]
    inlet_pos = (inlet_x, inlet_y, z_top)
    
    # Add inlet node
    print("  Building channel network using pre-built tools...")
    inlet_result = add_inlet(
        network,
        position=Point3D(*inlet_pos),
        direction=(0.0, 0.0, -1.0),
        radius=OBJ4_INLET_RADIUS_M,
        vessel_type="venous",
    )


    if not inlet_result.is_success():
        print(f"    Warning: Failed to add inlet: {inlet_result.message}")
        return trimesh.Trimesh()
    
    current_node_id = inlet_result.new_ids["node"]
    
    # 1. Downward segment (1mm) using grow_to_point
    print("    Segment 1: Downward 1mm (using grow_to_point)")
    down_end = (inlet_x, inlet_y, z_top - OBJ4_DOWNWARD_LENGTH_M)
    grow_result = grow_to_point(
        network,
        from_node_id=current_node_id,
        target_point=down_end,
        target_radius=OBJ4_INLET_RADIUS_M,
        constraints=constraints,
        check_collisions=False,
        fail_on_collision=False,
    )
    if not grow_result.is_success():
        print(f"    Warning: grow_to_point failed: {grow_result.message}")
        return trimesh.Trimesh()
    current_node_id = grow_result.new_ids["node"]
    
    # 2. 90-degree turn (horizontal along +X) using grow_to_point
    print("    Segment 2: Horizontal turn (+X direction) (using grow_to_point)")
    turn_end = (inlet_x + OBJ4_HORIZONTAL_LENGTH_M, inlet_y, z_top - OBJ4_DOWNWARD_LENGTH_M)
    
    # Update direction for horizontal growth
    turn_node = network.get_node(current_node_id)
    if turn_node:
        turn_node.attributes["direction"] = {"dx": 1.0, "dy": 0.0, "dz": 0.0}
    
    grow_result = grow_to_point(
        network,
        from_node_id=current_node_id,
        target_point=turn_end,
        target_radius=OBJ4_INLET_RADIUS_M * OBJ4_TURN_RADIUS_FACTOR,
        constraints=constraints,
        check_collisions=False,
        fail_on_collision=False,
    )
    if not grow_result.is_success():
        print(f"    Warning: grow_to_point failed: {grow_result.message}")
        return trimesh.Trimesh()
    current_node_id = grow_result.new_ids["node"]
    
    # 3. Bifurcate in XY plane with grow -> bifurcate -> grow pattern
    print(f"    Bifurcating {OBJ4_NUM_BIFURCATIONS} levels in XY plane (using bifurcate)")
    
    # Track current branch tips: list of node_ids
    branch_tip_ids = [current_node_id]
    
    for level in range(OBJ4_NUM_BIFURCATIONS):
        new_tip_ids = []
        branch_length = OBJ4_BRANCH_BASE_LENGTH_M * (1.0 - OBJ4_BRANCH_LENGTH_DECAY * level)  # Decreasing length
        branch_radius = OBJ4_INLET_RADIUS_M * OBJ4_TURN_RADIUS_FACTOR * (OBJ4_BRANCH_RADIUS_DECAY ** (level + 1))
        
        # Calculate distance to next bifurcation level for growth distance
        if level + 1 < OBJ4_NUM_BIFURCATIONS:
            next_branch_length = OBJ4_BRANCH_BASE_LENGTH_M * (1.0 - OBJ4_BRANCH_LENGTH_DECAY * (level + 1))
        else:
            next_branch_length = branch_length * 0.5  # Last level: use half of current
        
        for tip_node_id in branch_tip_ids:
            tip_node = network.get_node(tip_node_id)
            if tip_node is None:
                continue
            
            tip_pos = np.array([tip_node.position.x, tip_node.position.y, tip_node.position.z])
            tip_dir_dict = tip_node.attributes.get("direction", {"dx": 1, "dy": 0, "dz": 0})
            tip_dir = np.array([tip_dir_dict.get("dx", 1), tip_dir_dict.get("dy", 0), tip_dir_dict.get("dz", 0)])
            
            # Grow forward a bit (pre-bifurcation growth) using grow_branch
            mid_pos = tip_pos + tip_dir * branch_length
            grow_result = grow_to_point(
                network,
                from_node_id=tip_node_id,
                target_point=tuple(mid_pos),
                target_radius=branch_radius,
                constraints=constraints,
                check_collisions=False,
                fail_on_collision=False,
            )
            
            if not grow_result.is_success():
                print(f"    Warning: grow_to_point failed at level {level}: {grow_result.message}")
                continue
            
            bifurc_node_id = grow_result.new_ids["node"]
            
            # Calculate RNG-based growth distances for child branches
            max_growth = next_branch_length * BIFURC_MAX_GROWTH_FRACTION  # Leave room for next bifurcation approach
            
            growth_fraction1 = rng.uniform(growth_fraction_range[0], growth_fraction_range[1])
            growth_distance1 = min(growth_fraction1 * next_branch_length, max_growth)
            growth_distance1 = max(growth_distance1, BIFURC_MIN_GROWTH_DISTANCE_M)
            
            growth_fraction2 = rng.uniform(growth_fraction_range[0], growth_fraction_range[1])
            growth_distance2 = min(growth_fraction2 * next_branch_length, max_growth)
            growth_distance2 = max(growth_distance2, BIFURC_MIN_GROWTH_DISTANCE_M)
            
            # Angle for bifurcation (decreases with level for tighter packing)
            angle_deg = OBJ4_BASE_ANGLE_DEG - OBJ4_ANGLE_DECAY_PER_LEVEL_DEG * level
            
            # Use bifurcate to create two child branches with RNG-based growth lengths
            bifurc_result = bifurcate(
                network,
                at_node_id=bifurc_node_id,
                child_lengths=(growth_distance1, growth_distance2),
                angle_deg=angle_deg,
                constraints=constraints,
                check_collisions=False,
                seed=rng_seed,
            )
            
            if not bifurc_result.is_success():
                print(f"    Warning: bifurcate failed at level {level}: {bifurc_result.message}")
                continue
            
            # Get the child node IDs from bifurcation result
            child_node_ids = bifurc_result.new_ids.get("nodes", [])
            for child_node_id in child_node_ids:
                # Update child node radius for next level
                child_node = network.get_node(child_node_id)
                if child_node:
                    child_node.attributes["radius"] = branch_radius
                new_tip_ids.append(child_node_id)
        
        branch_tip_ids = new_tip_ids
    
    # 4. Merge branches back (overlap-based merge)
    # Route all branch tips toward a common merge point using grow_to_point
    print("    Merging branches (using grow_to_point)")
    merge_point = (OBJ4_MERGE_POINT_X_M, 0.0, z_top - OBJ4_DOWNWARD_LENGTH_M)  # Merge point at +2mm X
    
    merge_node_id = None
    for tip_node_id in branch_tip_ids:
        tip_node = network.get_node(tip_node_id)
        if tip_node is None:
            continue
        
        grow_result = grow_to_point(
            network,
            from_node_id=tip_node_id,
            target_point=merge_point,
            target_radius=OBJ4_TERMINAL_RADIUS_M,
            constraints=constraints,
            check_collisions=False,
            fail_on_collision=False,
        )
        if grow_result.is_success():
            merge_node_id = grow_result.new_ids["node"]
    
    # 5. Return upward to top face using grow_to_point
    print("    Segment: Return upward to top face (using grow_to_point)")
    outlet_pos = (OBJ4_OUTLET_X_M, 0.0, z_top)  # Outlet at +2mm X from center
    
    if merge_node_id is not None:
        # Update direction for upward growth
        merge_node = network.get_node(merge_node_id)
        if merge_node:
            merge_node.attributes["direction"] = {"dx": 0.0, "dy": 0.0, "dz": 1.0}
        
        grow_result = grow_to_point(
            network,
            from_node_id=merge_node_id,
            target_point=outlet_pos,
            target_radius=OBJ4_TERMINAL_RADIUS_M,
            constraints=constraints,
            check_collisions=False,
            fail_on_collision=False,
        )
    
    # Convert network to mesh using the mesh adapter
    print(f"    Converting network to mesh ({len(network.segments)} segments)...")
    mesh_result = to_trimesh(network, mode="fast", include_caps=True, include_node_spheres=False)
    
    if not mesh_result.is_success():
        print(f"    Warning: to_trimesh failed: {mesh_result.message}")
        return trimesh.Trimesh()
    
    channel_segments = [mesh_result.metadata["mesh"]]
    
    # Union all channel segments
    print(f"  Combining {len(channel_segments)} channel segments...")
    combined_void = voxel_union_meshes(channel_segments, pitch=VOXEL_PITCH_UNION_M)
    
    # Export intermediate channel void mesh
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object4_channel_void.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(combined_void).export(str(intermediate_path))
        print(f"    Exported intermediate void: {intermediate_path}")
    
    # Run pre-embedding validation on channel mesh
    print("  Running pre-embedding validation on channel mesh...")
    try:
        pre_report = run_pre_embedding_validation(mesh=combined_void)
        print_validation_details(pre_report)
    except Exception as e:
        print(f"    Pre-embedding validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Use the repo's embed_tree_as_negative_space function to carve channels from cylinder
    print("  Carving channels using embed_tree_as_negative_space...")
    cylinder_with_void = embed_void_in_cylinder(
        void_mesh=combined_void,
        output_dir=output_dir,
        object_name="object4",
        voxel_pitch=VOXEL_PITCH_M,
        keep_largest_component=False,
    )
    
    # Export intermediate cylinder with void (before ridge)
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object4_cylinder_with_void.stl"
        scale_mesh_to_mm(cylinder_with_void).export(str(intermediate_path))
        print(f"    Exported intermediate cylinder with void: {intermediate_path}")
    
    print(f"  Cylinder with void: {len(cylinder_with_void.vertices)} vertices, {len(cylinder_with_void.faces)} faces")
    print(f"    Watertight: {cylinder_with_void.is_watertight}")
    
    # Run post-embedding validation on cylinder with void (before adding ridge)
    # Run post-embedding validation on cylinder with void (before adding ridge)
    print("  Running validation on cylinder with void...")
    try:
        validation_config = ValidationConfig(
            voxel_pitch_m=VOXEL_PITCH_M * 1000.0,  # convert meters -> millimeters for validator
            expected_outlets=OBJ2_NUM_INLETS,
        )
        report = run_post_embedding_validation(
            mesh=scale_mesh_to_mm(cylinder_with_void),  # validate in mm
            config=validation_config
        )
        print_validation_details(report)
    except Exception as e:
        print(f"    Validation error: {e}")
        import traceback
        traceback.print_exc()

    
    # Return cylinder_with_void - ridge will be added at the END in main() to prevent smoothing
    return cylinder_with_void


# =============================================================================
# OBJECT 5: CCO-NLP ORGANIC GROWTH
# =============================================================================

def generate_object5_cco_nlp_organic(output_dir: Optional[Path] = None) -> trimesh.Trimesh:
    """
    Generate Object 5: CCO-Hybrid + NLP iterative organic growth.
    
    This object uses the repo's CCOHybridBackend for organic vascular network
    generation with iterative NLP optimization between growth rounds.
    
    Design choices documented:
    - Coordinate convention: Cylinder centered at origin, z spans [-1mm, +1mm]
    - Inlet z aligned with top face at z = +1mm
    - 4 inlets in symmetric square pattern at (+/-1.5mm, +/-1.5mm)
    - Each inlet starts with 0.1mm straight downward segment
    - 4 rounds of CCO growth + NLP optimization
    - 512 total terminals (128 per inlet, 32 per round per inlet)
    - Optimized per-tree after each round, then globally on merged network
    
    Returns mesh in METERS (will be scaled to mm at export).
    
    Parameters
    ----------
    output_dir : Path, optional
        Directory to save intermediate STL files for debugging
    """
    import copy
    import time
    
    print("\n" + "=" * 60)
    print("Generating Object 5: CCO-NLP Organic Growth")
    print("=" * 60)
    
    print("\n  Design choices:")
    print(f"    - Coordinate convention: Cylinder centered at origin")
    print(f"    - Top face at z = +{meters_to_mm(CYLINDER_HEIGHT_M/2)}mm")
    print(f"    - {OBJ5_NUM_INLETS} inlets at (+/-1.5mm, +/-1.5mm)")
    print(f"    - {OBJ5_NUM_ROUNDS} growth rounds with NLP optimization")
    print(f"    - {OBJ5_TOTAL_OUTLETS} total outlets ({OBJ5_TOTAL_OUTLETS // OBJ5_NUM_INLETS} per inlet)")
    print(f"    - Vessel type: {OBJ5_VESSEL_TYPE}")
    print(f"    - Seed: {OBJ5_SEED}")
    
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    
    # Create domain for CCO generation
    print("\n  Setting up CCO domain and configuration...")
    domain_spec = CylinderSpec(
        center=(CYLINDER_CENTER[0], CYLINDER_CENTER[1], CYLINDER_CENTER[2]),
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
    )
    domain = compile_domain(domain_spec)
    
    # Create CCO configuration
    cco_config = CCOConfig(
        seed=OBJ5_SEED,
        murray_exponent=OBJ5_CCO_MURRAY_EXPONENT,
        collision_clearance=OBJ5_CCO_COLLISION_CLEARANCE,
        min_segment_length=OBJ5_CCO_MIN_SEGMENT_LENGTH,
        max_segment_length=OBJ5_CCO_MAX_SEGMENT_LENGTH,
        min_terminal_separation=OBJ5_CCO_MIN_TERMINAL_SEP,
        candidate_edges_k=OBJ5_CCO_CANDIDATE_EDGES_K,
        optimization_grid_resolution=OBJ5_CCO_GRID_RESOLUTION,
        collision_check_enabled=True,
        use_partial_binding=True,
        use_collision_triage=True,
        use_nlp_optimization=OBJ5_CCO_USE_NLP,
    )
    
    print(f"    CCO config: murray_exponent={cco_config.murray_exponent}, "
          f"collision_clearance={cco_config.collision_clearance*1000:.3f}mm")
    
    # Create NLP configuration
    nlp_config = NLPConfig(
        murray_exponent=OBJ5_NLP_MURRAY_EXPONENT,
        target_pressure_drop=OBJ5_NLP_TARGET_PRESSURE_DROP,
        viscosity=OBJ5_NLP_VISCOSITY,
        fix_terminal_positions=OBJ5_NLP_FIX_TERMINALS,
        fix_root_position=OBJ5_NLP_FIX_ROOT,
        max_iterations=OBJ5_NLP_MAX_ITERATIONS,
        solver_tolerance=OBJ5_NLP_TOLERANCE,
        cleanup_degenerate_segments=OBJ5_NLP_CLEANUP_DEGENERATE,
    )
    
    # Create CCO backend
    backend = CCOHybridBackend()
    
    # Calculate outlets per inlet
    outlets_per_inlet = OBJ5_TOTAL_OUTLETS // OBJ5_NUM_INLETS
    
    # Generate trees for each inlet
    print(f"\n  Generating {OBJ5_NUM_INLETS} inlet trees with iterative CCO + NLP...")
    all_networks = []
    total_outlets_achieved = 0
    
    for inlet_idx, inlet_pos in enumerate(OBJ5_INLET_POSITIONS):
        print(f"\n    Inlet {inlet_idx + 1}: position=({inlet_pos[0]*1000:.1f}, "
              f"{inlet_pos[1]*1000:.1f}, {inlet_pos[2]*1000:.1f})mm")
        
        inlet_position = np.array(inlet_pos)
        
        # Generate tree for this inlet using CCO
        try:
            start_time = time.time()
            network = backend.generate(
                domain=domain,
                num_outlets=outlets_per_inlet,
                inlet_position=inlet_position,
                inlet_radius=OBJ5_INLET_RADIUS_M,
                vessel_type=OBJ5_VESSEL_TYPE,
                config=cco_config,
                rng_seed=OBJ5_SEED + inlet_idx,
            )
            gen_time = time.time() - start_time
            
            # Count actual outlets
            outlet_count = sum(1 for n in network.nodes.values() 
                             if n.node_type in ("outlet", "terminal"))
            total_outlets_achieved += outlet_count
            
            print(f"      CCO generation: {outlet_count} outlets in {gen_time:.1f}s")
            print(f"      Network: {len(network.nodes)} nodes, {len(network.segments)} segments")
            
            # Apply NLP optimization if enabled
            if OBJ5_NLP_ENABLED:
                print(f"      Applying NLP optimization...")
                try:
                    nlp_start = time.time()
                    nlp_result = optimize_geometry(network, nlp_config)
                    nlp_time = time.time() - nlp_start
                    
                    if nlp_result.success:
                        print(f"      NLP success: volume reduction {nlp_result.volume_reduction*100:.1f}% "
                              f"in {nlp_time:.1f}s")
                    else:
                        print(f"      NLP did not converge (continuing anyway)")
                except Exception as e:
                    print(f"      NLP optimization failed: {e} (continuing anyway)")
            
            all_networks.append(network)
            
        except Exception as e:
            print(f"      ERROR generating inlet {inlet_idx + 1}: {e}")
            continue
    
    if not all_networks:
        raise RuntimeError("Failed to generate any inlet networks")
    
    print(f"\n  Total outlets achieved: {total_outlets_achieved}/{OBJ5_TOTAL_OUTLETS}")
    
    # Merge all networks into one
    print("\n  Merging all inlet networks...")
    merged_network = all_networks[0]
    
    for i, network in enumerate(all_networks[1:], start=2):
        # Simple merge: copy nodes and segments with new IDs
        node_id_map = {}
        for old_node in network.nodes.values():
            new_node_id = merged_network.id_gen.next_id()
            new_node = Node(
                id=new_node_id,
                position=copy.deepcopy(old_node.position),
                node_type=old_node.node_type,
                vessel_type=old_node.vessel_type,
                attributes=old_node.attributes.copy() if old_node.attributes else {},
            )
            merged_network.add_node(new_node)
            node_id_map[old_node.id] = new_node_id
        
        for old_seg in network.segments.values():
            new_seg_id = merged_network.id_gen.next_id()
            new_seg = VesselSegment(
                id=new_seg_id,
                start_node_id=node_id_map[old_seg.start_node_id],
                end_node_id=node_id_map[old_seg.end_node_id],
                geometry=copy.deepcopy(old_seg.geometry),
                vessel_type=old_seg.vessel_type,
                attributes=old_seg.attributes.copy() if old_seg.attributes else {},
            )
            merged_network.add_segment(new_seg)
        
        print(f"    Merged inlet {i}: {len(network.nodes)} nodes, {len(network.segments)} segments")
    
    print(f"  Merged network: {len(merged_network.nodes)} nodes, "
          f"{len(merged_network.segments)} segments")
    
    # Final global NLP optimization on merged network
    if OBJ5_NLP_ENABLED:
        print("\n  Applying final global NLP optimization...")
        try:
            nlp_start = time.time()
            nlp_result = optimize_geometry(merged_network, nlp_config)
            nlp_time = time.time() - nlp_start
            
            if nlp_result.success:
                print(f"    Final NLP success: volume reduction {nlp_result.volume_reduction*100:.1f}% "
                      f"in {nlp_time:.1f}s")
            else:
                print(f"    Final NLP did not converge (continuing anyway)")
        except Exception as e:
            print(f"    Final NLP optimization failed: {e} (continuing anyway)")
    
    # Convert network to mesh
    print("\n  Converting network to mesh...")
    tree_mesh = None
    try:
        mesh_result = to_trimesh(merged_network, mode="voxel_repair")
        if mesh_result.is_success():
            tree_mesh = mesh_result.metadata["mesh"]
            print(f"    Tree mesh: {len(tree_mesh.vertices)} vertices, {len(tree_mesh.faces)} faces")
        else:
            print(f"    to_trimesh returned failure: {mesh_result.message}, using manual mesh construction")
    except Exception as e:
        print(f"    to_trimesh failed: {e}, using manual mesh construction")
    
    if tree_mesh is None:
        # Fallback: create mesh from segments manually
        all_segment_meshes = []
        for seg in merged_network.segments.values():
            start_node = merged_network.nodes[seg.start_node_id]
            end_node = merged_network.nodes[seg.end_node_id]
            # Convert Point3D to numpy array
            if hasattr(start_node.position, 'to_array'):
                start_pos = start_node.position.to_array()
            else:
                start_pos = np.array(start_node.position)
            if hasattr(end_node.position, 'to_array'):
                end_pos = end_node.position.to_array()
            else:
                end_pos = np.array(end_node.position)
            
            # Get radii
            if seg.geometry and hasattr(seg.geometry, 'start_radius'):
                start_r = seg.geometry.start_radius
                end_r = seg.geometry.end_radius
            else:
                start_r = OBJ5_INLET_RADIUS_M
                end_r = OBJ5_TERMINAL_RADIUS_M
            
            # Create tapered cylinder
            seg_mesh = _create_tapered_cylinder(start_pos, end_pos, start_r, end_r)
            if seg_mesh is not None:
                all_segment_meshes.append(seg_mesh)
        
        if all_segment_meshes:
            tree_mesh = voxel_union_meshes(all_segment_meshes, pitch=VOXEL_PITCH_UNION_M)
        else:
            raise RuntimeError("Failed to create tree mesh")
    
    # Export intermediate tree mesh
    if output_dir and tree_mesh is not None:
        intermediate_path = output_dir / "intermediate" / "object5_tree_void.stl"
        intermediate_path.parent.mkdir(parents=True, exist_ok=True)
        scale_mesh_to_mm(tree_mesh).export(str(intermediate_path))
        print(f"    Exported intermediate tree: {intermediate_path}")
    
    # Run pre-embedding validation on tree mesh
    print("  Running pre-embedding validation on tree mesh...")
    try:
        pre_report = run_pre_embedding_validation(mesh=tree_mesh)
        print_validation_details(pre_report)
    except Exception as e:
        print(f"    Pre-embedding validation error: {e}")
        import traceback
        traceback.print_exc()
    
    # Use the repo's embed_tree_as_negative_space function to carve voids from cylinder
    print("\n  Carving vascular channels using embed_tree_as_negative_space...")
    cylinder_with_void = embed_void_in_cylinder(
        void_mesh=tree_mesh,
        output_dir=output_dir,
        object_name="object5",
        voxel_pitch=VOXEL_PITCH_M,
        keep_largest_component=False,
    )
    
    # Export intermediate cylinder with void (before ridge)
    if output_dir:
        intermediate_path = output_dir / "intermediate" / "object5_cylinder_with_void.stl"
        scale_mesh_to_mm(cylinder_with_void).export(str(intermediate_path))
        print(f"    Exported intermediate cylinder with void: {intermediate_path}")
    
    print(f"  Cylinder with void: {len(cylinder_with_void.vertices)} vertices, {len(cylinder_with_void.faces)} faces")
    print(f"    Watertight: {cylinder_with_void.is_watertight}")
    
    # Run post-embedding validation on cylinder with void (before adding ridge)
    # Run post-embedding validation on cylinder with void (before adding ridge)
    print("  Running validation on cylinder with void...")
    try:
        validation_config = ValidationConfig(
            voxel_pitch_m=VOXEL_PITCH_M * 1000.0,  # convert meters -> millimeters for validator
            expected_outlets=OBJ2_NUM_INLETS,
        )
        report = run_post_embedding_validation(
            mesh=scale_mesh_to_mm(cylinder_with_void),  # validate in mm
            config=validation_config
        )
        print_validation_details(report)
    except Exception as e:
        print(f"    Validation error: {e}")
        import traceback
        traceback.print_exc()

    
    # Generate report
    report = {
        "object": "object5_cco_nlp_organic",
        "design_choices": {
            "coordinate_convention": "Cylinder centered at origin, z spans [-1mm, +1mm]",
            "inlet_z_position": f"+{meters_to_mm(CYLINDER_HEIGHT_M/2)}mm (top face)",
            "num_inlets": OBJ5_NUM_INLETS,
            "inlet_positions_mm": [[p[0]*1000, p[1]*1000, p[2]*1000] for p in OBJ5_INLET_POSITIONS],
            "num_rounds": OBJ5_NUM_ROUNDS,
            "vessel_type": OBJ5_VESSEL_TYPE,
        },
        "parameters": {
            "total_outlets_requested": OBJ5_TOTAL_OUTLETS,
            "total_outlets_achieved": total_outlets_achieved,
            "inlet_radius_mm": OBJ5_INLET_RADIUS_M * 1000,
            "terminal_radius_mm": OBJ5_TERMINAL_RADIUS_M * 1000,
            "cco_collision_clearance_mm": OBJ5_CCO_COLLISION_CLEARANCE * 1000,
            "cco_min_segment_mm": OBJ5_CCO_MIN_SEGMENT_LENGTH * 1000,
            "cco_max_segment_mm": OBJ5_CCO_MAX_SEGMENT_LENGTH * 1000,
            "nlp_enabled": OBJ5_NLP_ENABLED,
            "nlp_murray_exponent": OBJ5_NLP_MURRAY_EXPONENT,
            "voxel_pitch_mm": VOXEL_PITCH_UNION_M * 1000,
        },
        "mesh_stats": {
            "vertices": len(cylinder_with_void.vertices),
            "faces": len(cylinder_with_void.faces),
            "watertight": cylinder_with_void.is_watertight,
        },
    }
    
    # Save report
    report_path = OUTPUT_DIR / "object5_cco_nlp_organic_report.json"
    with open(report_path, 'w') as f:
        json.dump(report, f, indent=2)
    print(f"  Report saved: {report_path}")
    
    # Return cylinder_with_void - ridge will be added at the END in main() to prevent smoothing
    return cylinder_with_void


# =============================================================================
# MAIN EXECUTION
# =============================================================================

def add_ridge_to_mesh(mesh_m: trimesh.Trimesh) -> trimesh.Trimesh:
    """
    Add ridge to a mesh at the END (after all voxel operations) to prevent smoothing.
    
    Uses voxel union with fine pitch (VOXEL_PITCH_RIDGE_M = 25um) to preserve ridge detail
    while maintaining watertightness. The ridge is 0.1mm (100um) thick, so at 25um pitch
    it will be 4 voxels thick, which is sufficient to preserve the geometry.
    
    Parameters
    ----------
    mesh_m : trimesh.Trimesh
        The mesh to add ridge to (in meters)
    
    Returns
    -------
    trimesh.Trimesh
        The mesh with ridge added (in meters)
    """
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    
    # Print diagnostic info about input mesh
    print(f"    Input mesh: {len(mesh_m.vertices)} vertices, {len(mesh_m.faces)} faces")
    print(f"    Input mesh bounds: {mesh_m.bounds}")
    print(f"    Input mesh watertight: {mesh_m.is_watertight}")
    
    # IMPORTANT: For voxel union to work correctly, the ridge must OVERLAP with the
    # mesh (not just touch at z_top). We extend the ridge slightly INTO the mesh.
    ridge_z_base = z_top - RIDGE_OVERLAP_M  # Start ridge slightly INSIDE for overlap
    ridge_total_height = RIDGE_HEIGHT_M + RIDGE_OVERLAP_M  # Total height includes overlap
    
    ridge = create_ridge_mesh(
        outer_radius=CYLINDER_RADIUS_M,
        inner_radius=CYLINDER_RADIUS_M - RIDGE_THICKNESS_M,
        height=ridge_total_height,
        z_base=ridge_z_base,
        center_xy=(CYLINDER_CENTER[0], CYLINDER_CENTER[1]),
    )
    
    # Print diagnostic info about ridge mesh
    print(f"    Ridge mesh: {len(ridge.vertices)} vertices, {len(ridge.faces)} faces")
    print(f"    Ridge mesh bounds: {ridge.bounds}")
    print(f"    Ridge mesh watertight: {ridge.is_watertight}")
    print(f"    Ridge Z range: [{ridge_z_base}, {ridge_z_base + ridge_total_height}] (overlaps into mesh by {RIDGE_OVERLAP_M*1e6:.0f}um)")
    
    print(f"    Using voxel union with fine pitch ({VOXEL_PITCH_RIDGE_M*1e6:.0f}um) to preserve ridge detail")
    print(f"    Ridge thickness ({RIDGE_THICKNESS_M*1e6:.0f}um) / voxel pitch ({VOXEL_PITCH_RIDGE_M*1e6:.0f}um) = {RIDGE_THICKNESS_M/VOXEL_PITCH_RIDGE_M:.1f} voxels")
    
    # Perform voxel union
    combined = voxel_union_meshes([mesh_m, ridge], pitch=VOXEL_PITCH_RIDGE_M)
    # Fail fast if something is still in voxel-index coordinates.
    # (If this triggers, the ridge check will falsely "succeed" because 100 >> 0.0011.)
    try:
        in_extent = float(np.max(mesh_m.extents))
        out_extent = float(np.max(combined.extents))
        if in_extent > 0:
            ratio = out_extent / in_extent
            if ratio > 50.0:
                raise RuntimeError(
                    f"voxel_union_meshes returned a mesh that looks like voxel-index coordinates "
                    f"(out/in={ratio:.1f}). Expected meters. "
                    f"Check voxel_union_meshes() transform handling."
                )
    except Exception:
        raise

    # Print diagnostic info about combined mesh
    print(f"    Combined mesh: {len(combined.vertices)} vertices, {len(combined.faces)} faces")
    print(f"    Combined mesh bounds: {combined.bounds}")
    print(f"    Combined mesh watertight: {combined.is_watertight}")
    
    # Verify the ridge was added by checking Z bounds
    input_z_max = mesh_m.bounds[1][2]
    combined_z_max = combined.bounds[1][2]
    expected_z_max = z_top + RIDGE_HEIGHT_M
    
    if combined_z_max < expected_z_max - VOXEL_PITCH_RIDGE_M:
        print(f"    WARNING: Combined Z max ({combined_z_max:.6f}) < expected ({expected_z_max:.6f})")
        print(f"    Ridge may not have been added correctly!")
    else:
        print(f"    Ridge added successfully: Z max increased from {input_z_max:.6f} to {combined_z_max:.6f}")
    
    return combined


def main():
    """Generate all five objects and export to STL files."""
    print("=" * 70)
    print("MALARIA VENULE INSERTS GENERATOR")
    print("=" * 70)
    print("\nDesign Choices:")
    print("  - Ridge geometry: Annular ring (outer=5mm, inner=4.9mm, height=0.1mm)")
    print("  - Object 2 channels: 4 channels at (+/-1.5mm, +/-1.5mm)")
    print("  - Object 3 bifurcation: 7 levels, depths 0.25-1.75mm, taper 1mm->100um")
    print("  - Overlap-based merge: Voxel union merges overlapping void volumes")
    print("  - Object 5 CCO-NLP: 4 inlets, 4 rounds CCO + NLP, 512 terminals")
    print("  - Ridge added at END (after voxel ops) to prevent smoothing")
    print(f"\nVoxel pitch: {meters_to_mm(VOXEL_PITCH_M)*1000:.0f} um (fine)")
    print(f"Voxel pitch (union): {meters_to_mm(VOXEL_PITCH_UNION_M)*1000:.0f} um")
    print(f"Voxel pitch (ridge): {meters_to_mm(VOXEL_PITCH_RIDGE_M)*1000:.0f} um")
    print(f"Output units: {OUTPUT_UNITS}")
    
    # Create output directory
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    print(f"\nOutput directory: {OUTPUT_DIR}")
    print(f"Intermediate STLs will be saved to: {OUTPUT_DIR / 'intermediate'}")
    
    # Generate and export each object (pass output_dir for intermediate STL exports)
    # Objects 2-5 return cylinder_with_void (without ridge) - ridge is added at the END
    # Object 1 already includes ridge (no voxel operations after ridge)
    objects = [
        ("object1_control.stl", lambda: generate_object1_control(output_dir=OUTPUT_DIR), False),  # Already has ridge
        ("object2_channels.stl", lambda: generate_object2_channels(output_dir=OUTPUT_DIR), True),  # Needs ridge
        ("object3_bifurcate_512.stl", lambda: generate_object3_bifurcate_512(output_dir=OUTPUT_DIR), True),  # Needs ridge
        ("object4_turn_bifurcate_merge.stl", lambda: generate_object4_turn_bifurcate_merge(output_dir=OUTPUT_DIR), True),  # Needs ridge
        ("object5_cco_nlp_organic.stl", lambda: generate_object5_cco_nlp_organic(output_dir=OUTPUT_DIR), True),  # Needs ridge
    ]
    
    for filename, generator_func, needs_ridge in objects:
        try:
            mesh_m = generator_func()
            
            # Add ridge at the END for objects 2-5 (after all voxel operations)
            if needs_ridge:
                print(f"  Adding ridge to {filename} (at END to prevent smoothing)...")
                mesh_m = add_ridge_to_mesh(mesh_m)
                print(f"    Final mesh: {len(mesh_m.vertices)} vertices, {len(mesh_m.faces)} faces")
            
            # Scale to millimeters
            mesh_mm = scale_mesh_to_mm(mesh_m)
            
            # Export
            output_path = OUTPUT_DIR / filename
            export_mesh_with_units(mesh_mm, output_path, units=OUTPUT_UNITS)
            
        except Exception as e:
            print(f"\nERROR generating {filename}: {e}")
            import traceback
            traceback.print_exc()
    
    print("\n" + "=" * 70)
    print("GENERATION COMPLETE")
    print("=" * 70)
    print(f"\nOutput files in: {OUTPUT_DIR}")
    print("  - object1_control.stl")
    print("  - object2_channels.stl")
    print("  - object3_bifurcate_512.stl")
    print("  - object4_turn_bifurcate_merge.stl")
    print("  - object5_cco_nlp_organic.stl")
    print(f"\nIntermediate STLs in: {OUTPUT_DIR / 'intermediate'}")


if __name__ == "__main__":
    main()
