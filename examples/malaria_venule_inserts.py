#!/usr/bin/env python3
"""
Malaria Venule Inserts Generator

This module generates four STL files for malaria venule insert scaffolds:
1. Object 1 (Control): Solid cylinder with ridge, no internal voids
2. Object 2 (Control + Channels): Control with 4 straight channels
3. Object 3 (Bifurcation 512): 4 inlets with recursive bifurcation to 512 terminals
4. Object 4 (Turn-Bifurcate-Merge): Single inlet with 90-degree turn, bifurcation, merge, return

DESIGN CHOICES DOCUMENTED:
- Ridge geometry: Annular ring on perimeter (outer_radius=5mm, inner_radius=4.9mm)
  Fallback: Solid raised disk if ring creation fails
- Object 2 channel count: 4 channels (minimum specified)
- Object 2 channel placement: Square pattern at (+/-1.5mm, +/-1.5mm) from center
- Object 3 bifurcation depths: 0.25, 0.50, 0.75, 1.00, 1.25, 1.50, 1.75 mm from top
- Object 3 branch taper: Exponential from 1mm to 100um over 7 levels
- Overlap-based merge strategy: Voxel union merges overlapping void volumes

UNITS:
- Internal computations: METERS
- Output STL files: MILLIMETERS (scaled at export)

Author: Generated by Agentic Organ Generation System
"""

import sys
import os
import math
import json
import numpy as np
import trimesh
from pathlib import Path
from typing import List, Tuple, Optional, Dict, Any
from dataclasses import dataclass

# Add parent directory to path for imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from generation.core.domain import CylinderDomain
from generation.core.types import Point3D, Direction3D, TubeGeometry
from generation.core.network import VascularNetwork, Node, VesselSegment
from generation.ops.build import create_network, add_inlet
from generation.ops.growth import grow_branch, grow_to_point
from generation.adapters.mesh_adapter import to_trimesh, export_stl
from generation.ops.embedding import embed_tree_as_negative_space
from generation.rules.constraints import BranchingConstraints


# =============================================================================
# HARDCODED PARAMETERS - All dimensions in METERS internally
# =============================================================================

# --- Base Cylinder Parameters ---
CYLINDER_RADIUS_M = 0.005          # 5 mm radius = 10 mm diameter
CYLINDER_HEIGHT_M = 0.002          # 2 mm height
CYLINDER_CENTER = (0.0, 0.0, 0.0)  # Centered at origin

# --- Ridge Parameters ---
RIDGE_HEIGHT_M = 0.0001            # 0.1 mm ridge height
RIDGE_THICKNESS_M = 0.0001         # 0.1 mm ridge thickness (annular ring width)
# Ridge interpretation: Annular ring on perimeter
# - Outer radius = CYLINDER_RADIUS_M (5.0 mm)
# - Inner radius = CYLINDER_RADIUS_M - RIDGE_THICKNESS_M (4.9 mm)
# - Z range = [+1.0 mm, +1.1 mm] (top of cylinder to top of ridge)

# --- Channel Parameters (Object 2) ---
CHANNEL_RADIUS_M = 0.001           # 1 mm channel radius
CHANNEL_DEPTH_M = 0.001            # 1 mm channel depth (extends downward from top)
NUM_CHANNELS = 4                   # Number of straight channels (4-9 range, using minimum)
CHANNEL_OFFSET_M = 0.0015          # 1.5 mm offset from center for channel placement
WALL_MARGIN_M = 0.0005             # 0.5 mm minimum wall margin from cylinder edge

# --- Bifurcation Parameters (Object 3) ---
NUM_INLETS_OBJ3 = 4                # 4 inlet channels
INLET_RADIUS_M = 0.001             # 1 mm inlet radius
TERMINAL_RADIUS_M = 0.0001         # 100 um terminal radius
TOTAL_TERMINALS = 512              # Total terminal count
TERMINALS_PER_INLET = 128          # 512 / 4 = 128 terminals per inlet
BIFURCATION_LEVELS = 7             # 2^7 = 128 terminals per inlet
# Bifurcation depth schedule (mm from top face, converted to meters)
BIFURCATION_DEPTHS_M = [
    0.00025,  # 0.25 mm
    0.00050,  # 0.50 mm
    0.00075,  # 0.75 mm
    0.00100,  # 1.00 mm
    0.00125,  # 1.25 mm
    0.00150,  # 1.50 mm
    0.00175,  # 1.75 mm
]
# Inlet positions for Object 3 (symmetric near center)
INLET_POSITIONS_OBJ3 = [
    (0.0015, 0.0015),   # +1.5mm, +1.5mm
    (-0.0015, 0.0015),  # -1.5mm, +1.5mm
    (-0.0015, -0.0015), # -1.5mm, -1.5mm
    (0.0015, -0.0015),  # +1.5mm, -1.5mm
]

# --- Object 4 Parameters (Turn-Bifurcate-Merge) ---
INLET_RADIUS_OBJ4_M = 0.001        # 1 mm inlet radius
DOWNWARD_LENGTH_M = 0.001          # 1 mm downward travel before turn
HORIZONTAL_LENGTH_M = 0.001        # 1 mm horizontal travel after turn
NUM_BIFURCATIONS_OBJ4 = 3          # Number of bifurcation levels in lateral plane
MERGE_OVERLAP_M = 0.0005           # 0.5 mm overlap for merge region

# --- Voxelization Parameters ---
VOXEL_PITCH_M = 2.5e-5             # 25 um voxel pitch (for fine resolution)
# Note: 25 um pitch on 10mm x 10mm x 2mm domain = ~12.8M voxels (feasible)

# --- Output Parameters ---
OUTPUT_UNITS = "mm"                # Output STL files in millimeters
OUTPUT_DIR = Path(__file__).parent / "Malaria Venule Inserts"


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def meters_to_mm(value_m: float) -> float:
    """Convert meters to millimeters."""
    return value_m * 1000.0


def create_cylinder_mesh(radius: float, height: float, center: Tuple[float, float, float]) -> trimesh.Trimesh:
    """Create a solid cylinder mesh centered at the given point."""
    cylinder = trimesh.creation.cylinder(
        radius=radius,
        height=height,
        sections=64,
    )
    cylinder.apply_translation([center[0], center[1], center[2]])
    return cylinder


def create_ridge_mesh(
    outer_radius: float,
    inner_radius: float,
    height: float,
    z_base: float,
    center_xy: Tuple[float, float],
) -> trimesh.Trimesh:
    """
    Create an annular ring (ridge) mesh.
    
    Design choice: Ridge is an annular ring on the perimeter of the top face.
    If boolean operations fail, falls back to a solid disk.
    """
    try:
        # Create outer cylinder
        outer_cyl = trimesh.creation.cylinder(
            radius=outer_radius,
            height=height,
            sections=64,
        )
        outer_cyl.apply_translation([center_xy[0], center_xy[1], z_base + height / 2])
        
        # Create inner cylinder (to subtract)
        inner_cyl = trimesh.creation.cylinder(
            radius=inner_radius,
            height=height * 1.1,  # Slightly taller to ensure clean subtraction
            sections=64,
        )
        inner_cyl.apply_translation([center_xy[0], center_xy[1], z_base + height / 2])
        
        # Try boolean difference
        try:
            ring = outer_cyl.difference(inner_cyl, engine='blender')
            if ring is not None and len(ring.vertices) > 0:
                print("  Ridge: Created annular ring using boolean difference")
                return ring
        except Exception as e:
            print(f"  Ridge: Boolean difference failed ({e}), using fallback")
        
        # Fallback: Create ring using path extrusion
        # Generate annular cross-section
        angles = np.linspace(0, 2 * np.pi, 65)
        outer_points = np.column_stack([
            outer_radius * np.cos(angles),
            outer_radius * np.sin(angles),
        ])
        inner_points = np.column_stack([
            inner_radius * np.cos(angles[::-1]),
            inner_radius * np.sin(angles[::-1]),
        ])
        
        # Create top and bottom faces
        n_outer = len(outer_points) - 1
        n_inner = len(inner_points) - 1
        
        # Build vertices for top and bottom rings
        top_z = z_base + height
        bottom_z = z_base
        
        vertices = []
        # Bottom outer ring
        for i in range(n_outer):
            vertices.append([outer_points[i, 0] + center_xy[0], 
                           outer_points[i, 1] + center_xy[1], bottom_z])
        # Bottom inner ring
        for i in range(n_inner):
            vertices.append([inner_points[i, 0] + center_xy[0], 
                           inner_points[i, 1] + center_xy[1], bottom_z])
        # Top outer ring
        for i in range(n_outer):
            vertices.append([outer_points[i, 0] + center_xy[0], 
                           outer_points[i, 1] + center_xy[1], top_z])
        # Top inner ring
        for i in range(n_inner):
            vertices.append([inner_points[i, 0] + center_xy[0], 
                           inner_points[i, 1] + center_xy[1], top_z])
        
        vertices = np.array(vertices)
        
        # Build faces
        faces = []
        # Outer wall faces
        for i in range(n_outer):
            i_next = (i + 1) % n_outer
            # Bottom outer, top outer
            faces.append([i, i_next, i + 2 * n_outer])
            faces.append([i_next, i_next + 2 * n_outer, i + 2 * n_outer])
        
        # Inner wall faces
        for i in range(n_inner):
            i_next = (i + 1) % n_inner
            base = n_outer
            top_base = 3 * n_outer
            # Bottom inner, top inner (reversed winding)
            faces.append([base + i, base + i + 2 * n_outer, base + i_next])
            faces.append([base + i_next, base + i + 2 * n_outer, base + i_next + 2 * n_outer])
        
        # Top and bottom annular faces
        for i in range(n_outer):
            i_next = (i + 1) % n_outer
            # Bottom face
            faces.append([i, n_outer + i, i_next])
            faces.append([i_next, n_outer + i, n_outer + i_next])
            # Top face
            faces.append([2 * n_outer + i, 2 * n_outer + i_next, 3 * n_outer + i])
            faces.append([2 * n_outer + i_next, 3 * n_outer + i_next, 3 * n_outer + i])
        
        ring = trimesh.Trimesh(vertices=vertices, faces=np.array(faces))
        ring.fix_normals()
        print("  Ridge: Created annular ring using manual mesh construction")
        return ring
        
    except Exception as e:
        print(f"  Ridge: Annular ring creation failed ({e}), using solid disk fallback")
        # Fallback: Solid disk
        disk = trimesh.creation.cylinder(
            radius=outer_radius,
            height=height,
            sections=64,
        )
        disk.apply_translation([center_xy[0], center_xy[1], z_base + height / 2])
        print("  Ridge: Created solid disk (fallback)")
        return disk


def create_channel_mesh(
    position_xy: Tuple[float, float],
    z_top: float,
    radius: float,
    depth: float,
) -> trimesh.Trimesh:
    """Create a cylindrical channel mesh extending downward from z_top."""
    channel = trimesh.creation.cylinder(
        radius=radius,
        height=depth,
        sections=32,
    )
    # Position so top of channel is at z_top
    channel.apply_translation([position_xy[0], position_xy[1], z_top - depth / 2])
    return channel


def compute_taper_radius(level: int, total_levels: int, r_start: float, r_end: float) -> float:
    """
    Compute radius at a given bifurcation level using exponential taper.
    
    r_k = r_0 * (r_end/r_0)^(k/total_levels)
    """
    if total_levels == 0:
        return r_start
    ratio = r_end / r_start
    return r_start * (ratio ** (level / total_levels))


def voxel_union_meshes(meshes: List[trimesh.Trimesh], pitch: float) -> trimesh.Trimesh:
    """
    Union multiple meshes using voxelization and marching cubes.
    
    This is the overlap-based merge strategy: overlapping volumes are
    automatically merged during voxelization.
    """
    from skimage.measure import marching_cubes
    
    if not meshes:
        raise ValueError("No meshes to union")
    
    if len(meshes) == 1:
        return meshes[0]
    
    # Concatenate all meshes
    combined = trimesh.util.concatenate(meshes)
    
    # Voxelize
    try:
        voxels = combined.voxelized(pitch)
        voxel_matrix = voxels.matrix
    except (MemoryError, ValueError):
        # Try with coarser pitch
        pitch *= 2
        voxels = combined.voxelized(pitch)
        voxel_matrix = voxels.matrix
    
    # Marching cubes
    verts, faces, _, _ = marching_cubes(
        volume=voxel_matrix.astype(np.uint8),
        level=0.5,
        spacing=(pitch, pitch, pitch),
        allow_degenerate=False,
    )
    
    # Transform back to world coordinates
    verts += voxels.transform[:3, 3]
    
    result = trimesh.Trimesh(
        vertices=verts,
        faces=faces.astype(np.int64),
        process=False,
    )
    
    result.remove_unreferenced_vertices()
    if result.volume < 0:
        result.invert()
    trimesh.repair.fix_normals(result)
    
    return result


def scale_mesh_to_mm(mesh: trimesh.Trimesh) -> trimesh.Trimesh:
    """Scale mesh from meters to millimeters."""
    scaled = mesh.copy()
    scaled.apply_scale(1000.0)  # m to mm
    return scaled


def export_mesh_with_units(mesh: trimesh.Trimesh, output_path: Path, units: str = "mm"):
    """Export mesh to STL with units.json sidecar file."""
    mesh.export(str(output_path))
    
    # Write units sidecar
    sidecar_path = str(output_path) + ".units.json"
    metadata = {
        "units": units,
        "stl_file": str(output_path),
        "description": "Malaria Venule Insert scaffold",
    }
    with open(sidecar_path, 'w') as f:
        json.dump(metadata, f, indent=2)
    
    print(f"  Exported: {output_path}")
    print(f"  Units sidecar: {sidecar_path}")


# =============================================================================
# OBJECT GENERATION FUNCTIONS
# =============================================================================

def generate_object1_control() -> trimesh.Trimesh:
    """
    Generate Object 1: Control cylinder with ridge, no internal voids.
    
    Returns mesh in METERS (will be scaled to mm at export).
    """
    print("\n" + "=" * 60)
    print("Generating Object 1: Control (solid cylinder + ridge)")
    print("=" * 60)
    
    # Create base cylinder
    print("  Creating base cylinder...")
    base_cylinder = create_cylinder_mesh(
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
        center=CYLINDER_CENTER,
    )
    print(f"    Cylinder: radius={meters_to_mm(CYLINDER_RADIUS_M)}mm, "
          f"height={meters_to_mm(CYLINDER_HEIGHT_M)}mm")
    
    # Create ridge on top face
    print("  Creating ridge...")
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2  # Top of cylinder
    ridge = create_ridge_mesh(
        outer_radius=CYLINDER_RADIUS_M,
        inner_radius=CYLINDER_RADIUS_M - RIDGE_THICKNESS_M,
        height=RIDGE_HEIGHT_M,
        z_base=z_top,
        center_xy=(CYLINDER_CENTER[0], CYLINDER_CENTER[1]),
    )
    print(f"    Ridge: outer_r={meters_to_mm(CYLINDER_RADIUS_M)}mm, "
          f"inner_r={meters_to_mm(CYLINDER_RADIUS_M - RIDGE_THICKNESS_M)}mm, "
          f"height={meters_to_mm(RIDGE_HEIGHT_M)}mm")
    
    # Union cylinder and ridge
    print("  Combining cylinder and ridge...")
    combined = voxel_union_meshes([base_cylinder, ridge], pitch=VOXEL_PITCH_M)
    
    print(f"  Object 1 complete: {len(combined.vertices)} vertices, {len(combined.faces)} faces")
    print(f"    Watertight: {combined.is_watertight}")
    
    return combined


def generate_object2_channels() -> trimesh.Trimesh:
    """
    Generate Object 2: Control + straight channels.
    
    Design choice: 4 channels in a square pattern at (+/-1.5mm, +/-1.5mm).
    
    Returns mesh in METERS (will be scaled to mm at export).
    """
    print("\n" + "=" * 60)
    print("Generating Object 2: Control + straight channels")
    print("=" * 60)
    
    # Create base (same as Object 1)
    print("  Creating base cylinder with ridge...")
    base_cylinder = create_cylinder_mesh(
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
        center=CYLINDER_CENTER,
    )
    
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    ridge = create_ridge_mesh(
        outer_radius=CYLINDER_RADIUS_M,
        inner_radius=CYLINDER_RADIUS_M - RIDGE_THICKNESS_M,
        height=RIDGE_HEIGHT_M,
        z_base=z_top,
        center_xy=(CYLINDER_CENTER[0], CYLINDER_CENTER[1]),
    )
    
    base = voxel_union_meshes([base_cylinder, ridge], pitch=VOXEL_PITCH_M)
    
    # Create channels
    print(f"  Creating {NUM_CHANNELS} straight channels...")
    channel_positions = [
        (CHANNEL_OFFSET_M, CHANNEL_OFFSET_M),
        (-CHANNEL_OFFSET_M, CHANNEL_OFFSET_M),
        (-CHANNEL_OFFSET_M, -CHANNEL_OFFSET_M),
        (CHANNEL_OFFSET_M, -CHANNEL_OFFSET_M),
    ]
    
    channels = []
    for i, pos in enumerate(channel_positions[:NUM_CHANNELS]):
        channel = create_channel_mesh(
            position_xy=pos,
            z_top=z_top,
            radius=CHANNEL_RADIUS_M,
            depth=CHANNEL_DEPTH_M,
        )
        channels.append(channel)
        print(f"    Channel {i+1}: position=({meters_to_mm(pos[0]):.1f}, {meters_to_mm(pos[1]):.1f})mm, "
              f"radius={meters_to_mm(CHANNEL_RADIUS_M)}mm, depth={meters_to_mm(CHANNEL_DEPTH_M)}mm")
    
    # Union all channels
    print("  Combining channels...")
    channel_void = voxel_union_meshes(channels, pitch=VOXEL_PITCH_M)
    
    # Subtract channels from base
    print("  Carving channels from base...")
    try:
        result = base.difference(channel_void, engine='blender')
        if result is None or len(result.vertices) == 0:
            raise ValueError("Boolean difference returned empty mesh")
        print("    Used Blender boolean difference")
    except Exception as e:
        print(f"    Blender boolean failed ({e}), using voxel-based subtraction")
        # Voxel-based subtraction
        from skimage.measure import marching_cubes
        
        # Voxelize both meshes
        pitch = VOXEL_PITCH_M
        
        # Get combined bounds
        all_bounds = np.vstack([base.bounds, channel_void.bounds])
        min_bound = all_bounds.min(axis=0) - pitch * 2
        max_bound = all_bounds.max(axis=0) + pitch * 2
        
        grid_shape = np.ceil((max_bound - min_bound) / pitch).astype(int)
        
        # Voxelize base
        base_vox = base.voxelized(pitch)
        base_matrix = np.zeros(grid_shape, dtype=bool)
        base_origin = base_vox.transform[:3, 3]
        base_offset = np.round((base_origin - min_bound) / pitch).astype(int)
        
        bm = base_vox.matrix
        for i in range(3):
            if base_offset[i] < 0:
                bm = bm[-base_offset[i]:]
                base_offset[i] = 0
        
        end_idx = np.minimum(base_offset + np.array(bm.shape), grid_shape)
        copy_size = end_idx - base_offset
        copy_size = np.minimum(copy_size, np.array(bm.shape))
        
        if np.all(copy_size > 0):
            base_matrix[
                base_offset[0]:base_offset[0]+copy_size[0],
                base_offset[1]:base_offset[1]+copy_size[1],
                base_offset[2]:base_offset[2]+copy_size[2]
            ] = bm[:copy_size[0], :copy_size[1], :copy_size[2]]
        
        # Voxelize channels
        chan_vox = channel_void.voxelized(pitch)
        chan_matrix = np.zeros(grid_shape, dtype=bool)
        chan_origin = chan_vox.transform[:3, 3]
        chan_offset = np.round((chan_origin - min_bound) / pitch).astype(int)
        
        cm = chan_vox.matrix
        for i in range(3):
            if chan_offset[i] < 0:
                cm = cm[-chan_offset[i]:]
                chan_offset[i] = 0
        
        end_idx = np.minimum(chan_offset + np.array(cm.shape), grid_shape)
        copy_size = end_idx - chan_offset
        copy_size = np.minimum(copy_size, np.array(cm.shape))
        
        if np.all(copy_size > 0):
            chan_matrix[
                chan_offset[0]:chan_offset[0]+copy_size[0],
                chan_offset[1]:chan_offset[1]+copy_size[1],
                chan_offset[2]:chan_offset[2]+copy_size[2]
            ] = cm[:copy_size[0], :copy_size[1], :copy_size[2]]
        
        # Subtract
        result_matrix = base_matrix & ~chan_matrix
        
        # Marching cubes
        verts, faces, _, _ = marching_cubes(
            volume=result_matrix.astype(np.uint8),
            level=0.5,
            spacing=(pitch, pitch, pitch),
            allow_degenerate=False,
        )
        verts += min_bound
        
        result = trimesh.Trimesh(vertices=verts, faces=faces.astype(np.int64), process=False)
        result.remove_unreferenced_vertices()
        if result.volume < 0:
            result.invert()
        trimesh.repair.fix_normals(result)
    
    print(f"  Object 2 complete: {len(result.vertices)} vertices, {len(result.faces)} faces")
    print(f"    Watertight: {result.is_watertight}")
    
    return result


def generate_bifurcation_tree_mesh(
    inlet_position: Tuple[float, float, float],
    inlet_radius: float,
    terminal_radius: float,
    bifurcation_depths: List[float],
    base_angle_deg: float = 30.0,
) -> trimesh.Trimesh:
    """
    Generate a bifurcating tree mesh from a single inlet.
    
    Uses recursive bifurcation with exponential radius taper.
    Overlapping branches are merged via voxel union.
    
    Parameters
    ----------
    inlet_position : tuple
        (x, y, z) position of inlet in meters
    inlet_radius : float
        Radius at inlet in meters
    terminal_radius : float
        Radius at terminals in meters
    bifurcation_depths : list
        Z-depths (from top) where bifurcations occur, in meters
    base_angle_deg : float
        Base bifurcation angle in degrees
    
    Returns
    -------
    trimesh.Trimesh
        Combined mesh of all branches
    """
    num_levels = len(bifurcation_depths)
    all_segments = []
    
    # Track current branch tips: list of (position, direction, radius, level)
    # Direction is a unit vector
    current_tips = [(
        np.array(inlet_position),
        np.array([0.0, 0.0, -1.0]),  # Downward
        inlet_radius,
        0,
    )]
    
    for level in range(num_levels):
        depth = bifurcation_depths[level]
        target_z = inlet_position[2] - depth
        
        new_tips = []
        
        for tip_pos, tip_dir, tip_radius, tip_level in current_tips:
            if tip_level != level:
                new_tips.append((tip_pos, tip_dir, tip_radius, tip_level))
                continue
            
            # Compute radius for this level
            current_radius = compute_taper_radius(level, num_levels, inlet_radius, terminal_radius)
            next_radius = compute_taper_radius(level + 1, num_levels, inlet_radius, terminal_radius)
            
            # Grow to bifurcation point
            # Distance to target z
            if abs(tip_dir[2]) > 0.1:
                dist_to_target = abs((target_z - tip_pos[2]) / tip_dir[2])
            else:
                dist_to_target = 0.0002  # Small step for horizontal branches
            
            dist_to_target = max(dist_to_target, 0.0001)  # Minimum segment length
            
            bifurc_pos = tip_pos + tip_dir * dist_to_target
            
            # Create segment to bifurcation point
            seg_mesh = _create_tapered_cylinder(
                start=tip_pos,
                end=bifurc_pos,
                radius_start=current_radius,
                radius_end=current_radius,
            )
            all_segments.append(seg_mesh)
            
            # Create two child branches
            # Compute perpendicular directions for bifurcation
            if abs(tip_dir[2]) > 0.9:
                # Mostly vertical, use X and Y for lateral spread
                perp1 = np.array([1.0, 0.0, 0.0])
                perp2 = np.array([0.0, 1.0, 0.0])
            else:
                # Compute perpendicular in XY plane
                perp1 = np.cross(tip_dir, np.array([0.0, 0.0, 1.0]))
                perp1 = perp1 / np.linalg.norm(perp1)
                perp2 = np.cross(tip_dir, perp1)
                perp2 = perp2 / np.linalg.norm(perp2)
            
            # Angle for bifurcation (decreases with level for tighter packing)
            angle_rad = math.radians(base_angle_deg * (1.0 - 0.1 * level))
            
            # Child 1: deflect in perp1 direction
            child1_dir = tip_dir * math.cos(angle_rad) + perp1 * math.sin(angle_rad)
            child1_dir = child1_dir / np.linalg.norm(child1_dir)
            
            # Child 2: deflect in opposite perp1 direction
            child2_dir = tip_dir * math.cos(angle_rad) - perp1 * math.sin(angle_rad)
            child2_dir = child2_dir / np.linalg.norm(child2_dir)
            
            new_tips.append((bifurc_pos.copy(), child1_dir, next_radius, level + 1))
            new_tips.append((bifurc_pos.copy(), child2_dir, next_radius, level + 1))
        
        current_tips = new_tips
    
    # Add final segments for terminal tips
    for tip_pos, tip_dir, tip_radius, tip_level in current_tips:
        # Short terminal segment
        end_pos = tip_pos + tip_dir * 0.0001
        seg_mesh = _create_tapered_cylinder(
            start=tip_pos,
            end=end_pos,
            radius_start=tip_radius,
            radius_end=terminal_radius,
        )
        all_segments.append(seg_mesh)
    
    # Union all segments (overlap-based merge)
    print(f"    Combining {len(all_segments)} branch segments...")
    combined = voxel_union_meshes(all_segments, pitch=VOXEL_PITCH_M * 2)  # Coarser for speed
    
    return combined


def _create_tapered_cylinder(
    start: np.ndarray,
    end: np.ndarray,
    radius_start: float,
    radius_end: float,
    sections: int = 16,
) -> trimesh.Trimesh:
    """Create a tapered cylinder (frustum) between two points."""
    direction = end - start
    length = np.linalg.norm(direction)
    
    if length < 1e-9:
        # Degenerate segment, return small sphere
        sphere = trimesh.creation.icosphere(subdivisions=1, radius=radius_start)
        sphere.apply_translation(start)
        return sphere
    
    direction = direction / length
    
    # Create frustum along Z axis
    if abs(radius_start - radius_end) < 1e-10:
        frustum = trimesh.creation.cylinder(
            radius=radius_start,
            height=length,
            sections=sections,
        )
    else:
        # Manual frustum creation
        angles = np.linspace(0, 2 * np.pi, sections, endpoint=False)
        
        z_bottom = -length / 2
        z_top = length / 2
        
        bottom_verts = np.column_stack([
            radius_start * np.cos(angles),
            radius_start * np.sin(angles),
            np.full(sections, z_bottom),
        ])
        
        top_verts = np.column_stack([
            radius_end * np.cos(angles),
            radius_end * np.sin(angles),
            np.full(sections, z_top),
        ])
        
        # Center vertices for caps
        center_bottom = np.array([[0, 0, z_bottom]])
        center_top = np.array([[0, 0, z_top]])
        
        vertices = np.vstack([bottom_verts, top_verts, center_bottom, center_top])
        
        faces = []
        # Side faces
        for i in range(sections):
            i_next = (i + 1) % sections
            faces.append([i, i_next, i + sections])
            faces.append([i_next, i_next + sections, i + sections])
        
        # Bottom cap
        center_bottom_idx = 2 * sections
        for i in range(sections):
            i_next = (i + 1) % sections
            faces.append([center_bottom_idx, i_next, i])
        
        # Top cap
        center_top_idx = 2 * sections + 1
        for i in range(sections):
            i_next = (i + 1) % sections
            faces.append([center_top_idx, i + sections, i_next + sections])
        
        frustum = trimesh.Trimesh(vertices=vertices, faces=np.array(faces))
    
    # Rotate to align with direction
    z_axis = np.array([0, 0, 1])
    if not np.allclose(direction, z_axis) and not np.allclose(direction, -z_axis):
        rotation_axis = np.cross(z_axis, direction)
        if np.linalg.norm(rotation_axis) > 1e-6:
            rotation_axis = rotation_axis / np.linalg.norm(rotation_axis)
            angle = np.arccos(np.clip(np.dot(z_axis, direction), -1, 1))
            rotation_matrix = trimesh.transformations.rotation_matrix(angle, rotation_axis)
            frustum.apply_transform(rotation_matrix)
    elif np.allclose(direction, -z_axis):
        rotation_matrix = trimesh.transformations.rotation_matrix(np.pi, [1, 0, 0])
        frustum.apply_transform(rotation_matrix)
    
    # Translate to position
    center = (start + end) / 2
    frustum.apply_translation(center)
    
    return frustum


def generate_object3_bifurcate_512() -> trimesh.Trimesh:
    """
    Generate Object 3: Recursive bifurcation to 512 terminals.
    
    Design choices:
    - 4 inlets at symmetric positions near center
    - 7 bifurcation levels per inlet (2^7 = 128 terminals each)
    - Exponential radius taper from 1mm to 100um
    - Bifurcation depths at 0.25, 0.50, 0.75, 1.00, 1.25, 1.50, 1.75 mm
    - Overlapping branches merge via voxel union
    
    Returns mesh in METERS (will be scaled to mm at export).
    """
    print("\n" + "=" * 60)
    print("Generating Object 3: Recursive bifurcation to 512 terminals")
    print("=" * 60)
    
    # Create base (same as Object 1)
    print("  Creating base cylinder with ridge...")
    base_cylinder = create_cylinder_mesh(
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
        center=CYLINDER_CENTER,
    )
    
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    ridge = create_ridge_mesh(
        outer_radius=CYLINDER_RADIUS_M,
        inner_radius=CYLINDER_RADIUS_M - RIDGE_THICKNESS_M,
        height=RIDGE_HEIGHT_M,
        z_base=z_top,
        center_xy=(CYLINDER_CENTER[0], CYLINDER_CENTER[1]),
    )
    
    base = voxel_union_meshes([base_cylinder, ridge], pitch=VOXEL_PITCH_M)
    
    # Generate bifurcating trees from each inlet
    print(f"  Generating {NUM_INLETS_OBJ3} bifurcating trees...")
    all_trees = []
    
    for i, (x, y) in enumerate(INLET_POSITIONS_OBJ3):
        print(f"    Tree {i+1}: inlet at ({meters_to_mm(x):.1f}, {meters_to_mm(y):.1f})mm")
        inlet_pos = (x, y, z_top)
        
        tree_mesh = generate_bifurcation_tree_mesh(
            inlet_position=inlet_pos,
            inlet_radius=INLET_RADIUS_M,
            terminal_radius=TERMINAL_RADIUS_M,
            bifurcation_depths=BIFURCATION_DEPTHS_M,
            base_angle_deg=30.0,
        )
        all_trees.append(tree_mesh)
        print(f"      Generated tree with {len(tree_mesh.vertices)} vertices")
    
    # Union all trees (overlapping branches merge)
    print("  Combining all trees (overlap-based merge)...")
    combined_void = voxel_union_meshes(all_trees, pitch=VOXEL_PITCH_M * 2)
    
    # Subtract from base
    print("  Carving voids from base...")
    try:
        result = base.difference(combined_void, engine='blender')
        if result is None or len(result.vertices) == 0:
            raise ValueError("Boolean difference returned empty mesh")
        print("    Used Blender boolean difference")
    except Exception as e:
        print(f"    Blender boolean failed ({e}), using voxel-based subtraction")
        # Voxel-based subtraction (same as Object 2)
        from skimage.measure import marching_cubes
        
        pitch = VOXEL_PITCH_M * 2  # Coarser for large mesh
        
        all_bounds = np.vstack([base.bounds, combined_void.bounds])
        min_bound = all_bounds.min(axis=0) - pitch * 2
        max_bound = all_bounds.max(axis=0) + pitch * 2
        
        grid_shape = np.ceil((max_bound - min_bound) / pitch).astype(int)
        grid_shape = np.minimum(grid_shape, 500)  # Cap grid size
        
        # Voxelize base
        base_vox = base.voxelized(pitch)
        base_matrix = np.zeros(grid_shape, dtype=bool)
        base_origin = base_vox.transform[:3, 3]
        base_offset = np.round((base_origin - min_bound) / pitch).astype(int)
        base_offset = np.maximum(base_offset, 0)
        
        bm = base_vox.matrix
        end_idx = np.minimum(base_offset + np.array(bm.shape), grid_shape)
        copy_size = end_idx - base_offset
        copy_size = np.minimum(copy_size, np.array(bm.shape))
        copy_size = np.maximum(copy_size, 0)
        
        if np.all(copy_size > 0):
            base_matrix[
                base_offset[0]:base_offset[0]+copy_size[0],
                base_offset[1]:base_offset[1]+copy_size[1],
                base_offset[2]:base_offset[2]+copy_size[2]
            ] = bm[:copy_size[0], :copy_size[1], :copy_size[2]]
        
        # Voxelize void
        void_vox = combined_void.voxelized(pitch)
        void_matrix = np.zeros(grid_shape, dtype=bool)
        void_origin = void_vox.transform[:3, 3]
        void_offset = np.round((void_origin - min_bound) / pitch).astype(int)
        void_offset = np.maximum(void_offset, 0)
        
        vm = void_vox.matrix
        end_idx = np.minimum(void_offset + np.array(vm.shape), grid_shape)
        copy_size = end_idx - void_offset
        copy_size = np.minimum(copy_size, np.array(vm.shape))
        copy_size = np.maximum(copy_size, 0)
        
        if np.all(copy_size > 0):
            void_matrix[
                void_offset[0]:void_offset[0]+copy_size[0],
                void_offset[1]:void_offset[1]+copy_size[1],
                void_offset[2]:void_offset[2]+copy_size[2]
            ] = vm[:copy_size[0], :copy_size[1], :copy_size[2]]
        
        # Subtract
        result_matrix = base_matrix & ~void_matrix
        
        if not result_matrix.any():
            print("    WARNING: Result matrix is empty, using base mesh")
            result = base
        else:
            verts, faces, _, _ = marching_cubes(
                volume=result_matrix.astype(np.uint8),
                level=0.5,
                spacing=(pitch, pitch, pitch),
                allow_degenerate=False,
            )
            verts += min_bound
            
            result = trimesh.Trimesh(vertices=verts, faces=faces.astype(np.int64), process=False)
            result.remove_unreferenced_vertices()
            if result.volume < 0:
                result.invert()
            trimesh.repair.fix_normals(result)
    
    print(f"  Object 3 complete: {len(result.vertices)} vertices, {len(result.faces)} faces")
    print(f"    Watertight: {result.is_watertight}")
    
    return result


def generate_object4_turn_bifurcate_merge() -> trimesh.Trimesh:
    """
    Generate Object 4: Single inlet, 90-degree turn, bifurcate, merge, return.
    
    Design choices:
    - Single inlet at center top face, radius 1mm
    - Travel downward 1mm
    - Turn 90 degrees (along +X direction)
    - Bifurcate in XY plane
    - Branches merge by overlapping in space (voxel union)
    - Single trunk returns upward to exit near top face
    
    Returns mesh in METERS (will be scaled to mm at export).
    """
    print("\n" + "=" * 60)
    print("Generating Object 4: Turn-Bifurcate-Merge loop")
    print("=" * 60)
    
    # Create base (same as Object 1)
    print("  Creating base cylinder with ridge...")
    base_cylinder = create_cylinder_mesh(
        radius=CYLINDER_RADIUS_M,
        height=CYLINDER_HEIGHT_M,
        center=CYLINDER_CENTER,
    )
    
    z_top = CYLINDER_CENTER[2] + CYLINDER_HEIGHT_M / 2
    z_bottom = CYLINDER_CENTER[2] - CYLINDER_HEIGHT_M / 2
    ridge = create_ridge_mesh(
        outer_radius=CYLINDER_RADIUS_M,
        inner_radius=CYLINDER_RADIUS_M - RIDGE_THICKNESS_M,
        height=RIDGE_HEIGHT_M,
        z_base=z_top,
        center_xy=(CYLINDER_CENTER[0], CYLINDER_CENTER[1]),
    )
    
    base = voxel_union_meshes([base_cylinder, ridge], pitch=VOXEL_PITCH_M)
    
    # Build the channel network
    print("  Building channel network...")
    channel_segments = []
    
    # Inlet position (slightly offset from center to allow return path)
    inlet_x = -0.001  # -1mm from center
    inlet_y = 0.0
    inlet_pos = np.array([inlet_x, inlet_y, z_top])
    
    # 1. Downward segment (1mm)
    print("    Segment 1: Downward 1mm")
    down_end = inlet_pos + np.array([0, 0, -DOWNWARD_LENGTH_M])
    seg1 = _create_tapered_cylinder(inlet_pos, down_end, INLET_RADIUS_OBJ4_M, INLET_RADIUS_OBJ4_M)
    channel_segments.append(seg1)
    
    # 2. 90-degree turn (horizontal along +X)
    print("    Segment 2: Horizontal turn (+X direction)")
    turn_end = down_end + np.array([HORIZONTAL_LENGTH_M, 0, 0])
    seg2 = _create_tapered_cylinder(down_end, turn_end, INLET_RADIUS_OBJ4_M, INLET_RADIUS_OBJ4_M * 0.9)
    channel_segments.append(seg2)
    
    # 3. Bifurcate in XY plane
    print(f"    Bifurcating {NUM_BIFURCATIONS_OBJ4} levels in XY plane")
    
    # Create bifurcating branches
    branch_tips = [(turn_end.copy(), np.array([1.0, 0.0, 0.0]), INLET_RADIUS_OBJ4_M * 0.9)]
    
    for level in range(NUM_BIFURCATIONS_OBJ4):
        new_tips = []
        branch_length = 0.0005 * (1.0 - 0.2 * level)  # Decreasing length
        branch_radius = INLET_RADIUS_OBJ4_M * 0.9 * (0.8 ** (level + 1))
        
        for tip_pos, tip_dir, tip_r in branch_tips:
            # Grow forward a bit
            mid_pos = tip_pos + tip_dir * branch_length
            seg = _create_tapered_cylinder(tip_pos, mid_pos, tip_r, branch_radius)
            channel_segments.append(seg)
            
            # Bifurcate: one branch goes +Y, one goes -Y (with some forward component)
            angle = math.radians(45 - 10 * level)
            
            # Branch 1: +Y deflection
            dir1 = tip_dir * math.cos(angle) + np.array([0, 1, 0]) * math.sin(angle)
            dir1 = dir1 / np.linalg.norm(dir1)
            
            # Branch 2: -Y deflection
            dir2 = tip_dir * math.cos(angle) + np.array([0, -1, 0]) * math.sin(angle)
            dir2 = dir2 / np.linalg.norm(dir2)
            
            new_tips.append((mid_pos.copy(), dir1, branch_radius))
            new_tips.append((mid_pos.copy(), dir2, branch_radius))
        
        branch_tips = new_tips
    
    # 4. Merge branches back (overlap-based merge)
    # Route all branch tips toward a common merge point
    print("    Merging branches (overlap-based)")
    merge_point = np.array([0.002, 0.0, down_end[2]])  # Merge point at +2mm X
    
    for tip_pos, tip_dir, tip_r in branch_tips:
        # Create segment toward merge point
        seg = _create_tapered_cylinder(tip_pos, merge_point, tip_r, INLET_RADIUS_OBJ4_M * 0.5)
        channel_segments.append(seg)
    
    # 5. Return upward to top face
    print("    Segment: Return upward to top face")
    outlet_pos = np.array([0.002, 0.0, z_top])  # Outlet at +2mm X from center
    seg_return = _create_tapered_cylinder(merge_point, outlet_pos, INLET_RADIUS_OBJ4_M * 0.5, INLET_RADIUS_OBJ4_M * 0.5)
    channel_segments.append(seg_return)
    
    # Union all channel segments
    print(f"  Combining {len(channel_segments)} channel segments...")
    combined_void = voxel_union_meshes(channel_segments, pitch=VOXEL_PITCH_M)
    
    # Subtract from base
    print("  Carving channels from base...")
    try:
        result = base.difference(combined_void, engine='blender')
        if result is None or len(result.vertices) == 0:
            raise ValueError("Boolean difference returned empty mesh")
        print("    Used Blender boolean difference")
    except Exception as e:
        print(f"    Blender boolean failed ({e}), using voxel-based subtraction")
        # Voxel-based subtraction
        from skimage.measure import marching_cubes
        
        pitch = VOXEL_PITCH_M
        
        all_bounds = np.vstack([base.bounds, combined_void.bounds])
        min_bound = all_bounds.min(axis=0) - pitch * 2
        max_bound = all_bounds.max(axis=0) + pitch * 2
        
        grid_shape = np.ceil((max_bound - min_bound) / pitch).astype(int)
        grid_shape = np.minimum(grid_shape, 500)
        
        # Voxelize base
        base_vox = base.voxelized(pitch)
        base_matrix = np.zeros(grid_shape, dtype=bool)
        base_origin = base_vox.transform[:3, 3]
        base_offset = np.round((base_origin - min_bound) / pitch).astype(int)
        base_offset = np.maximum(base_offset, 0)
        
        bm = base_vox.matrix
        end_idx = np.minimum(base_offset + np.array(bm.shape), grid_shape)
        copy_size = end_idx - base_offset
        copy_size = np.minimum(copy_size, np.array(bm.shape))
        copy_size = np.maximum(copy_size, 0)
        
        if np.all(copy_size > 0):
            base_matrix[
                base_offset[0]:base_offset[0]+copy_size[0],
                base_offset[1]:base_offset[1]+copy_size[1],
                base_offset[2]:base_offset[2]+copy_size[2]
            ] = bm[:copy_size[0], :copy_size[1], :copy_size[2]]
        
        # Voxelize void
        void_vox = combined_void.voxelized(pitch)
        void_matrix = np.zeros(grid_shape, dtype=bool)
        void_origin = void_vox.transform[:3, 3]
        void_offset = np.round((void_origin - min_bound) / pitch).astype(int)
        void_offset = np.maximum(void_offset, 0)
        
        vm = void_vox.matrix
        end_idx = np.minimum(void_offset + np.array(vm.shape), grid_shape)
        copy_size = end_idx - void_offset
        copy_size = np.minimum(copy_size, np.array(vm.shape))
        copy_size = np.maximum(copy_size, 0)
        
        if np.all(copy_size > 0):
            void_matrix[
                void_offset[0]:void_offset[0]+copy_size[0],
                void_offset[1]:void_offset[1]+copy_size[1],
                void_offset[2]:void_offset[2]+copy_size[2]
            ] = vm[:copy_size[0], :copy_size[1], :copy_size[2]]
        
        # Subtract
        result_matrix = base_matrix & ~void_matrix
        
        if not result_matrix.any():
            print("    WARNING: Result matrix is empty, using base mesh")
            result = base
        else:
            verts, faces, _, _ = marching_cubes(
                volume=result_matrix.astype(np.uint8),
                level=0.5,
                spacing=(pitch, pitch, pitch),
                allow_degenerate=False,
            )
            verts += min_bound
            
            result = trimesh.Trimesh(vertices=verts, faces=faces.astype(np.int64), process=False)
            result.remove_unreferenced_vertices()
            if result.volume < 0:
                result.invert()
            trimesh.repair.fix_normals(result)
    
    print(f"  Object 4 complete: {len(result.vertices)} vertices, {len(result.faces)} faces")
    print(f"    Watertight: {result.is_watertight}")
    
    return result


# =============================================================================
# MAIN EXECUTION
# =============================================================================

def main():
    """Generate all four objects and export to STL files."""
    print("=" * 70)
    print("MALARIA VENULE INSERTS GENERATOR")
    print("=" * 70)
    print("\nDesign Choices:")
    print("  - Ridge geometry: Annular ring (outer=5mm, inner=4.9mm, height=0.1mm)")
    print("  - Object 2 channels: 4 channels at (+/-1.5mm, +/-1.5mm)")
    print("  - Object 3 bifurcation: 7 levels, depths 0.25-1.75mm, taper 1mm->100um")
    print("  - Overlap-based merge: Voxel union merges overlapping void volumes")
    print(f"\nVoxel pitch: {meters_to_mm(VOXEL_PITCH_M)*1000:.0f} um")
    print(f"Output units: {OUTPUT_UNITS}")
    
    # Create output directory
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    print(f"\nOutput directory: {OUTPUT_DIR}")
    
    # Generate and export each object
    objects = [
        ("object1_control.stl", generate_object1_control),
        ("object2_channels.stl", generate_object2_channels),
        ("object3_bifurcate_512.stl", generate_object3_bifurcate_512),
        ("object4_turn_bifurcate_merge.stl", generate_object4_turn_bifurcate_merge),
    ]
    
    for filename, generator_func in objects:
        try:
            mesh_m = generator_func()
            
            # Scale to millimeters
            mesh_mm = scale_mesh_to_mm(mesh_m)
            
            # Export
            output_path = OUTPUT_DIR / filename
            export_mesh_with_units(mesh_mm, output_path, units=OUTPUT_UNITS)
            
        except Exception as e:
            print(f"\nERROR generating {filename}: {e}")
            import traceback
            traceback.print_exc()
    
    print("\n" + "=" * 70)
    print("GENERATION COMPLETE")
    print("=" * 70)
    print(f"\nOutput files in: {OUTPUT_DIR}")
    print("  - object1_control.stl")
    print("  - object2_channels.stl")
    print("  - object3_bifurcate_512.stl")
    print("  - object4_turn_bifurcate_merge.stl")


if __name__ == "__main__":
    main()
