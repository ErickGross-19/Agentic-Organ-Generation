"""
Coding & Build Agent (CBA)

The CBA is responsible for:
- Generating three scripts from the specification
- Creating build plans that map spec to code
- Defining expected artifacts
- NOT modifying the spec (proposes changes back to CSA)
"""

import os
import json
from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any, Tuple
from datetime import datetime

from ..models import (
    SpecVersion,
    ScriptManifest,
    ExpectedArtifact,
    AgentType,
    get_timestamp,
)
from ..folder_manager import FolderManager


# Script templates for the three-script contract
GENERATE_SCRIPT_TEMPLATE = '''#!/usr/bin/env python3
"""
01_generate.py - Design / Raw Network & Raw Void Mesh

Auto-generated by MOGS CBA for spec version {version:03d}.
Generated: {timestamp}

This script generates:
- network.json (network graph)
- centerlines.json
- mesh_raw_void.stl (+ units sidecar)
"""

import os
import sys
import json
from pathlib import Path

# Output directory from environment
OUTPUT_DIR = Path(os.environ.get('ORGAN_AGENT_OUTPUT_DIR', os.getcwd()))
GENERATION_DIR = OUTPUT_DIR / "generation"
GENERATION_DIR.mkdir(parents=True, exist_ok=True)

# Import generation library
from generation import design_from_spec
from generation.specs import DesignSpec, BoxSpec, EllipsoidSpec, InletSpec, OutletSpec, TreeSpec, ColonizationSpec
from generation.adapters import export_stl, to_networkx_graph
import networkx as nx


def load_spec():
    """Load the specification."""
    spec_data = {spec_json}
    return spec_data


def build_design_spec(spec_data: dict) -> DesignSpec:
    """Convert spec data to DesignSpec."""
    # Extract domain
    domain_data = spec_data.get("domain", {{}})
    domain_type = domain_data.get("type", "box")
    size_m = domain_data.get("size_m", [0.02, 0.06, 0.03])
    center_m = domain_data.get("center_m", [0.0, 0.0, 0.0])
    
    if domain_type == "ellipsoid":
        domain = EllipsoidSpec(
            center=tuple(center_m),
            semi_axes=tuple(s/2 for s in size_m),
        )
    else:
        domain = BoxSpec(
            center=tuple(center_m),
            size=tuple(size_m),
        )
    
    # Extract ports
    ports_data = spec_data.get("ports", {{}})
    inlets = []
    for inlet_data in ports_data.get("inlets", []):
        inlets.append(InletSpec(
            position=tuple(inlet_data.get("position_m", [0, 0, 0])),
            radius=inlet_data.get("radius_m", 0.001),
            direction=tuple(inlet_data.get("direction_unit", [0, 0, -1])) if inlet_data.get("direction_unit") else None,
        ))
    
    outlets = []
    for outlet_data in ports_data.get("outlets", []):
        outlets.append(OutletSpec(
            position=tuple(outlet_data.get("position_m", [0, 0, 0])),
            radius=outlet_data.get("radius_m", 0.001),
        ))
    
    # Extract topology
    topology_data = spec_data.get("topology", {{}})
    geometry_data = spec_data.get("geometry", {{}})
    
    # Build colonization spec
    colonization = ColonizationSpec(
        target_segments=topology_data.get("target_terminals", 100),
        attraction_distance=geometry_data.get("segment_length_m", {{}}).get("max", 0.005) * 2,
        kill_distance=geometry_data.get("segment_length_m", {{}}).get("min", 0.0005),
        step_size=geometry_data.get("segment_length_m", {{}}).get("min", 0.0005),
    )
    
    # Build tree spec
    trees = []
    if inlets:
        for inlet in inlets:
            trees.append(TreeSpec(
                name="vascular_tree",
                inlet=inlet,
                colonization=colonization,
            ))
    else:
        # Default inlet if none specified
        trees.append(TreeSpec(
            name="vascular_tree",
            inlet=InletSpec(
                position=(0, 0, size_m[2]/2),
                radius=0.001,
            ),
            colonization=colonization,
        ))
    
    return DesignSpec(
        domain=domain,
        trees=trees,
        outlets=outlets if outlets else None,
    )


def main():
    """Main generation function."""
    print("Loading specification...")
    spec_data = load_spec()
    
    print("Building design spec...")
    design_spec = build_design_spec(spec_data)
    
    print("Generating vascular network...")
    network = design_from_spec(design_spec)
    
    print(f"Generated network with {{len(network.nodes)}} nodes and {{len(network.segments)}} segments")
    
    # Save network as JSON
    network_path = GENERATION_DIR / "network.json"
    network_data = {{
        "nodes": [
            {{
                "id": n.id,
                "position": list(n.position),
                "radius": n.radius,
                "node_type": n.node_type,
            }}
            for n in network.nodes.values()
        ],
        "segments": [
            {{
                "id": s.id,
                "start_node": s.start_node_id,
                "end_node": s.end_node_id,
                "radius_start": s.geometry.radius_start,
                "radius_end": s.geometry.radius_end,
            }}
            for s in network.segments.values()
        ],
    }}
    with open(network_path, 'w') as f:
        json.dump(network_data, f, indent=2)
    print(f"Saved network to {{network_path}}")
    
    # Save centerlines
    centerlines_path = GENERATION_DIR / "centerlines.json"
    centerlines = []
    for seg in network.segments.values():
        start_node = network.nodes[seg.start_node_id]
        end_node = network.nodes[seg.end_node_id]
        centerlines.append({{
            "segment_id": seg.id,
            "start": list(start_node.position),
            "end": list(end_node.position),
        }})
    with open(centerlines_path, 'w') as f:
        json.dump(centerlines, f, indent=2)
    print(f"Saved centerlines to {{centerlines_path}}")
    
    # Export raw void mesh
    mesh_path = GENERATION_DIR / "mesh_raw_void.stl"
    result = export_stl(network, str(mesh_path), mesh_type="surface")
    if result.success:
        print(f"Saved raw void mesh to {{mesh_path}}")
    else:
        print(f"Warning: Failed to export mesh: {{result.error}}")
    
    # Save units sidecar
    units_path = GENERATION_DIR / "mesh_raw_void_units.json"
    with open(units_path, 'w') as f:
        json.dump({{"units": "m", "scale_to_mm": 1000}}, f, indent=2)
    
    # Print artifacts JSON for verification
    artifacts = {{
        "files": [
            str(network_path),
            str(centerlines_path),
            str(mesh_path),
            str(units_path),
        ],
        "metrics": {{
            "node_count": len(network.nodes),
            "segment_count": len(network.segments),
        }},
        "status": "success"
    }}
    print(f"ARTIFACTS_JSON: {{json.dumps(artifacts)}}")


if __name__ == "__main__":
    main()
'''

ANALYZE_SCRIPT_TEMPLATE = '''#!/usr/bin/env python3
"""
02_analyze.py - Pre-final Checks + Budget Estimation

Auto-generated by MOGS CBA for spec version {version:03d}.
Generated: {timestamp}

This script performs:
- Geometry checks on raw void mesh
- Voxel budget estimation for finalization
- Metrics computation
- Diagnostic plots (optional)
"""

import os
import sys
import json
from pathlib import Path

# Output directory from environment
OUTPUT_DIR = Path(os.environ.get('ORGAN_AGENT_OUTPUT_DIR', os.getcwd()))
GENERATION_DIR = OUTPUT_DIR / "generation"
ANALYSIS_DIR = OUTPUT_DIR / "analysis"
ANALYSIS_DIR.mkdir(parents=True, exist_ok=True)

# Import validation library (optional - may not be available)
try:
    from validity import run_pre_embedding_validation
    from validity.mesh import compute_mesh_stats
except ImportError:
    run_pre_embedding_validation = None
    compute_mesh_stats = None


def load_network():
    """Load the generated network."""
    network_path = GENERATION_DIR / "network.json"
    with open(network_path, 'r') as f:
        return json.load(f)


def load_raw_mesh():
    """Load the raw void mesh."""
    mesh_path = GENERATION_DIR / "mesh_raw_void.stl"
    try:
        import trimesh
        return trimesh.load(str(mesh_path))
    except Exception as e:
        print(f"Warning: Could not load mesh: {{e}}")
        return None


def compute_metrics(network_data: dict, mesh) -> dict:
    """Compute analysis metrics."""
    metrics = {{
        "network": {{
            "node_count": len(network_data.get("nodes", [])),
            "segment_count": len(network_data.get("segments", [])),
        }},
    }}
    
    if mesh is not None:
        metrics["mesh"] = {{
            "vertex_count": len(mesh.vertices),
            "face_count": len(mesh.faces),
            "is_watertight": mesh.is_watertight,
            "is_volume": mesh.is_volume,
            "bounds": mesh.bounds.tolist() if hasattr(mesh.bounds, 'tolist') else None,
            "volume": float(mesh.volume) if mesh.is_volume else None,
        }}
    
    return metrics


def estimate_voxel_budget(mesh, voxel_pitch_m: float = 0.0001) -> dict:
    """Estimate voxel budget for finalization."""
    if mesh is None:
        return {{"error": "No mesh available"}}
    
    bounds = mesh.bounds
    size = bounds[1] - bounds[0]
    
    voxels_per_dim = [int(s / voxel_pitch_m) + 1 for s in size]
    total_voxels = voxels_per_dim[0] * voxels_per_dim[1] * voxels_per_dim[2]
    
    # Estimate memory (8 bytes per voxel for float64)
    memory_bytes = total_voxels * 8
    memory_mb = memory_bytes / (1024 * 1024)
    
    return {{
        "voxel_pitch_m": voxel_pitch_m,
        "voxels_per_dim": voxels_per_dim,
        "total_voxels": total_voxels,
        "estimated_memory_mb": memory_mb,
        "feasible": memory_mb < 4096,  # 4GB limit
    }}


def run_geometry_checks(mesh) -> dict:
    """Run geometry checks on the mesh."""
    checks = {{}}
    
    if mesh is None:
        checks["mesh_loaded"] = False
        return checks
    
    checks["mesh_loaded"] = True
    checks["is_watertight"] = mesh.is_watertight
    checks["is_volume"] = mesh.is_volume
    checks["has_degenerate_faces"] = len(mesh.faces) > 0 and mesh.area == 0
    
    # Check for self-intersections (expensive, skip if mesh is large)
    if len(mesh.faces) < 100000:
        try:
            checks["self_intersections"] = not mesh.is_watertight
        except Exception:
            checks["self_intersections"] = "unknown"
    else:
        checks["self_intersections"] = "skipped (mesh too large)"
    
    return checks


def main():
    """Main analysis function."""
    print("Loading network...")
    network_data = load_network()
    
    print("Loading mesh...")
    mesh = load_raw_mesh()
    
    print("Computing metrics...")
    metrics = compute_metrics(network_data, mesh)
    
    print("Estimating voxel budget...")
    voxel_budget = estimate_voxel_budget(mesh)
    metrics["voxel_budget"] = voxel_budget
    
    print("Running geometry checks...")
    geometry_checks = run_geometry_checks(mesh)
    metrics["geometry_checks"] = geometry_checks
    
    # Save metrics
    metrics_path = ANALYSIS_DIR / "metrics.json"
    with open(metrics_path, 'w') as f:
        json.dump(metrics, f, indent=2)
    print(f"Saved metrics to {{metrics_path}}")
    
    # Determine overall status
    status = "success"
    warnings = []
    
    if not geometry_checks.get("mesh_loaded", False):
        status = "warning"
        warnings.append("Mesh could not be loaded")
    elif not geometry_checks.get("is_watertight", False):
        status = "warning"
        warnings.append("Mesh is not watertight")
    
    if not voxel_budget.get("feasible", True):
        status = "warning"
        warnings.append("Voxel budget exceeds memory limit")
    
    # Print artifacts JSON for verification
    artifacts = {{
        "files": [str(metrics_path)],
        "metrics": {{
            "node_count": metrics["network"]["node_count"],
            "segment_count": metrics["network"]["segment_count"],
            "voxel_budget_feasible": voxel_budget.get("feasible", False),
        }},
        "warnings": warnings,
        "status": status
    }}
    print(f"ARTIFACTS_JSON: {{json.dumps(artifacts)}}")


if __name__ == "__main__":
    main()
'''

FINALIZE_SCRIPT_TEMPLATE = '''#!/usr/bin/env python3
"""
03_finalize.py - Embedding + BOTH Final STLs

Auto-generated by MOGS CBA for spec version {version:03d}.
Generated: {timestamp}

This script produces:
- void.stl (+ units)
- scaffold.stl (+ units)
- final_manifest.json
"""

import os
import sys
import json
from pathlib import Path

# Output directory from environment
OUTPUT_DIR = Path(os.environ.get('ORGAN_AGENT_OUTPUT_DIR', os.getcwd()))
GENERATION_DIR = OUTPUT_DIR / "generation"
ANALYSIS_DIR = OUTPUT_DIR / "analysis"
FINAL_DIR = OUTPUT_DIR / "final"
FINAL_DIR.mkdir(parents=True, exist_ok=True)

# Import generation library
from generation import embed_tree_as_negative_space
from generation.adapters import export_stl


def load_spec():
    """Load the specification."""
    spec_data = {spec_json}
    return spec_data


def load_network():
    """Load the generated network."""
    network_path = GENERATION_DIR / "network.json"
    with open(network_path, 'r') as f:
        return json.load(f)


def load_metrics():
    """Load analysis metrics."""
    metrics_path = ANALYSIS_DIR / "metrics.json"
    if metrics_path.exists():
        with open(metrics_path, 'r') as f:
            return json.load(f)
    return {{}}


def create_void_mesh(network_data: dict, spec_data: dict):
    """Create the void mesh (vascular channels)."""
    import trimesh
    import numpy as np
    
    # Create tube meshes for each segment
    meshes = []
    nodes = {{n["id"]: n for n in network_data.get("nodes", [])}}
    
    for seg in network_data.get("segments", []):
        start = nodes.get(seg["start_node"])
        end = nodes.get(seg["end_node"])
        
        if start is None or end is None:
            continue
        
        start_pos = np.array(start["position"])
        end_pos = np.array(end["position"])
        
        # Create cylinder for segment
        radius = (seg.get("radius_start", 0.001) + seg.get("radius_end", 0.001)) / 2
        length = np.linalg.norm(end_pos - start_pos)
        
        if length < 1e-10:
            continue
        
        # Create cylinder
        cylinder = trimesh.creation.cylinder(radius=radius, height=length, sections=16)
        
        # Transform to correct position and orientation
        direction = (end_pos - start_pos) / length
        midpoint = (start_pos + end_pos) / 2
        
        # Rotation to align with direction
        z_axis = np.array([0, 0, 1])
        if not np.allclose(direction, z_axis) and not np.allclose(direction, -z_axis):
            rotation_axis = np.cross(z_axis, direction)
            rotation_axis = rotation_axis / np.linalg.norm(rotation_axis)
            angle = np.arccos(np.clip(np.dot(z_axis, direction), -1, 1))
            rotation = trimesh.transformations.rotation_matrix(angle, rotation_axis)
            cylinder.apply_transform(rotation)
        elif np.allclose(direction, -z_axis):
            cylinder.apply_transform(trimesh.transformations.rotation_matrix(np.pi, [1, 0, 0]))
        
        # Translate to midpoint
        cylinder.apply_translation(midpoint)
        meshes.append(cylinder)
    
    if meshes:
        return trimesh.util.concatenate(meshes)
    return None


def create_scaffold_mesh(void_mesh, spec_data: dict):
    """Create the scaffold mesh (domain with void carved out)."""
    import trimesh
    import numpy as np
    
    # Get domain parameters
    domain_data = spec_data.get("domain", {{}})
    domain_type = domain_data.get("type", "box")
    size_m = domain_data.get("size_m", [0.02, 0.06, 0.03])
    center_m = domain_data.get("center_m", [0.0, 0.0, 0.0])
    
    # Create domain mesh
    if domain_type == "ellipsoid":
        domain = trimesh.creation.icosphere(subdivisions=3)
        domain.apply_scale([size_m[0]/2, size_m[1]/2, size_m[2]/2])
    else:
        domain = trimesh.creation.box(extents=size_m)
    
    domain.apply_translation(center_m)
    
    # Subtract void from domain
    if void_mesh is not None:
        try:
            scaffold = domain.difference(void_mesh)
            return scaffold
        except Exception as e:
            print(f"Warning: Boolean difference failed: {{e}}")
            print("Returning domain without void subtraction")
            return domain
    
    return domain


def main():
    """Main finalization function."""
    print("Loading specification...")
    spec_data = load_spec()
    
    print("Loading network...")
    network_data = load_network()
    
    print("Loading metrics...")
    metrics = load_metrics()
    
    print("Creating void mesh...")
    void_mesh = create_void_mesh(network_data, spec_data)
    
    if void_mesh is None:
        print("ERROR: Failed to create void mesh")
        artifacts = {{"files": [], "metrics": {{}}, "status": "failed"}}
        print(f"ARTIFACTS_JSON: {{json.dumps(artifacts)}}")
        sys.exit(1)
    
    # Save void mesh
    void_path = FINAL_DIR / "void.stl"
    void_mesh.export(str(void_path))
    print(f"Saved void mesh to {{void_path}}")
    
    # Save void units
    void_units_path = FINAL_DIR / "void_units.json"
    with open(void_units_path, 'w') as f:
        json.dump({{"units": "m", "scale_to_mm": 1000}}, f, indent=2)
    
    print("Creating scaffold mesh...")
    scaffold_mesh = create_scaffold_mesh(void_mesh, spec_data)
    
    # Save scaffold mesh
    scaffold_path = FINAL_DIR / "scaffold.stl"
    scaffold_mesh.export(str(scaffold_path))
    print(f"Saved scaffold mesh to {{scaffold_path}}")
    
    # Save scaffold units
    scaffold_units_path = FINAL_DIR / "scaffold_units.json"
    with open(scaffold_units_path, 'w') as f:
        json.dump({{"units": "m", "scale_to_mm": 1000}}, f, indent=2)
    
    # Create final manifest
    manifest = {{
        "spec_version": {version},
        "void_stl_path": str(void_path),
        "scaffold_stl_path": str(scaffold_path),
        "units": "m",
        "created_at": "{timestamp}",
        "generation_metrics": metrics.get("network", {{}}),
        "mesh_metrics": {{
            "void": {{
                "vertices": len(void_mesh.vertices),
                "faces": len(void_mesh.faces),
            }},
            "scaffold": {{
                "vertices": len(scaffold_mesh.vertices),
                "faces": len(scaffold_mesh.faces),
            }},
        }},
    }}
    
    manifest_path = FINAL_DIR / "final_manifest.json"
    with open(manifest_path, 'w') as f:
        json.dump(manifest, f, indent=2)
    print(f"Saved final manifest to {{manifest_path}}")
    
    # Print artifacts JSON for verification
    artifacts = {{
        "files": [
            str(void_path),
            str(scaffold_path),
            str(manifest_path),
        ],
        "metrics": {{
            "void_vertices": len(void_mesh.vertices),
            "void_faces": len(void_mesh.faces),
            "scaffold_vertices": len(scaffold_mesh.vertices),
            "scaffold_faces": len(scaffold_mesh.faces),
        }},
        "status": "success"
    }}
    print(f"ARTIFACTS_JSON: {{json.dumps(artifacts)}}")


if __name__ == "__main__":
    main()
'''


@dataclass
class CBABuildPlan:
    """
    Build plan created by CBA.
    
    Maps specification to code and documents the approach.
    """
    spec_version: int
    approach: str
    spec_to_code_mapping: List[Dict[str, str]]
    dependencies: List[str]
    estimated_runtime_seconds: float
    notes: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "spec_version": self.spec_version,
            "approach": self.approach,
            "spec_to_code_mapping": self.spec_to_code_mapping,
            "dependencies": self.dependencies,
            "estimated_runtime_seconds": self.estimated_runtime_seconds,
            "notes": self.notes,
        }
    
    @classmethod
    def from_dict(cls, d: Dict[str, Any]) -> "CBABuildPlan":
        return cls(**d)


@dataclass
class CBAOutput:
    """
    Output from a CBA session.
    
    Contains all the files that CBA must produce.
    """
    spec_version: int
    scripts: Dict[str, str]  # script name -> content
    expected_artifacts: List[ExpectedArtifact]
    build_plan: CBABuildPlan
    script_manifest: ScriptManifest


class CodingBuildAgent:
    """
    Coding & Build Agent (CBA)
    
    Responsible for:
    - Generating three scripts from the specification
    - Creating build plans that map spec to code
    - Defining expected artifacts
    - NOT modifying the spec (proposes changes back to CSA)
    
    Required outputs per session:
    - 04_scripts/scripts_v###/01_generate.py
    - 04_scripts/scripts_v###/02_analyze.py
    - 04_scripts/scripts_v###/03_finalize.py
    - expected_artifacts.json
    - run_manifest.json
    - CBA_buildplan_v###.md
    """
    
    def __init__(self, folder_manager: FolderManager, llm_client: Optional[Any] = None):
        """
        Initialize the CBA.
        
        Parameters
        ----------
        folder_manager : FolderManager
            Folder manager for the object
        llm_client : Any, optional
            LLM client for generating scripts (if None, uses templates)
        """
        self.folder_manager = folder_manager
        self.llm_client = llm_client
    
    def generate_scripts(self, spec_version: SpecVersion) -> CBAOutput:
        """
        Generate scripts from a specification.
        
        Parameters
        ----------
        spec_version : SpecVersion
            The specification to generate scripts from
            
        Returns
        -------
        CBAOutput
            The complete CBA output
        """
        version = spec_version.version
        timestamp = get_timestamp()
        spec_json = json.dumps(spec_version.spec_data, indent=2)
        
        # Generate scripts from templates
        scripts = {
            "01_generate.py": GENERATE_SCRIPT_TEMPLATE.format(
                version=version,
                timestamp=timestamp,
                spec_json=spec_json,
            ),
            "02_analyze.py": ANALYZE_SCRIPT_TEMPLATE.format(
                version=version,
                timestamp=timestamp,
            ),
            "03_finalize.py": FINALIZE_SCRIPT_TEMPLATE.format(
                version=version,
                timestamp=timestamp,
                spec_json=spec_json,
            ),
        }
        
        # Define expected artifacts
        expected_artifacts = self._define_expected_artifacts()
        
        # Create build plan
        build_plan = self._create_build_plan(spec_version)
        
        # Create script manifest
        script_manifest = ScriptManifest(
            spec_version=version,
            scripts=list(scripts.keys()),
            expected_artifacts=expected_artifacts,
            build_plan_path=f"CBA_buildplan_v{version:03d}.md",
        )
        
        return CBAOutput(
            spec_version=version,
            scripts=scripts,
            expected_artifacts=expected_artifacts,
            build_plan=build_plan,
            script_manifest=script_manifest,
        )
    
    def save_output(self, output: CBAOutput) -> Dict[str, str]:
        """
        Save all CBA output files.
        
        Parameters
        ----------
        output : CBAOutput
            The CBA output to save
            
        Returns
        -------
        Dict[str, str]
            Dictionary of file types to paths
        """
        version = output.spec_version
        paths = {}
        
        # Create scripts directory
        scripts_dir = self.folder_manager.get_scripts_version_dir(version)
        os.makedirs(scripts_dir, exist_ok=True)
        
        # Save scripts
        for script_name, script_content in output.scripts.items():
            script_path = os.path.join(scripts_dir, script_name)
            with open(script_path, 'w') as f:
                f.write(script_content)
            os.chmod(script_path, 0o755)
            paths[script_name] = script_path
        
        # Save expected artifacts JSON
        artifacts_path = os.path.join(scripts_dir, "expected_artifacts.json")
        with open(artifacts_path, 'w') as f:
            json.dump([ea.to_dict() for ea in output.expected_artifacts], f, indent=2)
        paths["expected_artifacts"] = artifacts_path
        
        # Save run manifest
        manifest_path = os.path.join(scripts_dir, "run_manifest.json")
        with open(manifest_path, 'w') as f:
            json.dump(output.script_manifest.to_dict(), f, indent=2)
        paths["run_manifest"] = manifest_path
        
        # Save build plan MD
        cba_docs_dir = self.folder_manager.get_agent_docs_dir("CBA")
        os.makedirs(cba_docs_dir, exist_ok=True)
        
        buildplan_path = os.path.join(cba_docs_dir, f"CBA_buildplan_v{version:03d}.md")
        with open(buildplan_path, 'w') as f:
            f.write(self._format_buildplan_md(output.build_plan))
        paths["buildplan"] = buildplan_path
        
        # Save script notes
        notes_path = os.path.join(cba_docs_dir, f"CBA_script_notes_v{version:03d}.md")
        with open(notes_path, 'w') as f:
            f.write(self._format_script_notes_md(output))
        paths["script_notes"] = notes_path
        
        self.folder_manager.log_event(f"CBA output saved for version {version}")
        
        return paths
    
    def _define_expected_artifacts(self) -> List[ExpectedArtifact]:
        """Define the expected artifacts from script execution."""
        return [
            # Generation stage
            ExpectedArtifact(
                filename="generation/network.json",
                description="Network graph with nodes and segments",
                required=True,
                validation_type="json",
            ),
            ExpectedArtifact(
                filename="generation/centerlines.json",
                description="Centerline data for visualization",
                required=True,
                validation_type="json",
            ),
            ExpectedArtifact(
                filename="generation/mesh_raw_void.stl",
                description="Raw void mesh before embedding",
                required=True,
                validation_type="stl",
            ),
            # Analysis stage
            ExpectedArtifact(
                filename="analysis/metrics.json",
                description="Analysis metrics and checks",
                required=True,
                validation_type="json",
            ),
            # Final stage
            ExpectedArtifact(
                filename="final/void.stl",
                description="Final void mesh (vascular channels)",
                required=True,
                validation_type="stl",
            ),
            ExpectedArtifact(
                filename="final/scaffold.stl",
                description="Final scaffold mesh (domain with void)",
                required=True,
                validation_type="stl",
            ),
            ExpectedArtifact(
                filename="final/final_manifest.json",
                description="Final manifest with all references",
                required=True,
                validation_type="json",
            ),
        ]
    
    def _create_build_plan(self, spec_version: SpecVersion) -> CBABuildPlan:
        """Create a build plan from the specification."""
        spec_data = spec_version.spec_data
        
        # Determine approach based on spec
        topology = spec_data.get("topology", {})
        topology_kind = topology.get("kind", "tree")
        
        if topology_kind == "path":
            approach = "Direct path generation with optional branching"
        elif topology_kind == "tree":
            approach = "Space colonization algorithm for tree growth"
        elif topology_kind == "backbone":
            approach = "Backbone with parallel legs generation"
        else:
            approach = "Standard tree generation"
        
        # Create spec-to-code mapping
        mapping = []
        
        if "domain" in spec_data:
            mapping.append({
                "spec_field": "domain",
                "code_location": "01_generate.py:build_design_spec()",
                "description": "Domain converted to BoxSpec or EllipsoidSpec",
            })
        
        if "topology" in spec_data:
            mapping.append({
                "spec_field": "topology",
                "code_location": "01_generate.py:build_design_spec()",
                "description": "Topology parameters used for ColonizationSpec",
            })
        
        if "ports" in spec_data:
            mapping.append({
                "spec_field": "ports",
                "code_location": "01_generate.py:build_design_spec()",
                "description": "Ports converted to InletSpec and OutletSpec",
            })
        
        # Estimate runtime
        terminals = topology.get("target_terminals", 100)
        estimated_runtime = 30 + (terminals * 0.1)  # Base + per-terminal
        
        return CBABuildPlan(
            spec_version=spec_version.version,
            approach=approach,
            spec_to_code_mapping=mapping,
            dependencies=["generation", "validity", "trimesh", "numpy"],
            estimated_runtime_seconds=estimated_runtime,
            notes="Scripts generated from templates. Review before execution.",
        )
    
    def _format_buildplan_md(self, plan: CBABuildPlan) -> str:
        """Format the build plan as markdown."""
        md = f"""# CBA Build Plan - Version {plan.spec_version:03d}

## Approach

{plan.approach}

## Spec-to-Code Mapping

| Spec Field | Code Location | Description |
|------------|---------------|-------------|
"""
        for mapping in plan.spec_to_code_mapping:
            md += f"| {mapping['spec_field']} | {mapping['code_location']} | {mapping['description']} |\n"
        
        md += f"""

## Dependencies

"""
        for dep in plan.dependencies:
            md += f"- {dep}\n"
        
        md += f"""

## Estimated Runtime

{plan.estimated_runtime_seconds:.1f} seconds

## Notes

{plan.notes}
"""
        return md
    
    def _format_script_notes_md(self, output: CBAOutput) -> str:
        """Format script notes as markdown."""
        md = f"""# CBA Script Notes - Version {output.spec_version:03d}

## Scripts Generated

"""
        for script_name in output.scripts.keys():
            md += f"- `{script_name}`\n"
        
        md += """

## Expected Artifacts

| Filename | Description | Required | Validation |
|----------|-------------|----------|------------|
"""
        for artifact in output.expected_artifacts:
            md += f"| {artifact.filename} | {artifact.description} | {'Yes' if artifact.required else 'No'} | {artifact.validation_type} |\n"
        
        md += """

## Execution Order

1. `01_generate.py` - Creates network and raw void mesh
2. `02_analyze.py` - Validates and computes metrics
3. `03_finalize.py` - Creates final void and scaffold meshes

## Environment Requirements

- `ORGAN_AGENT_OUTPUT_DIR` must be set to the output directory
- Python 3.8+ with generation and validity modules available
"""
        return md
    
    def propose_spec_change(
        self,
        spec_version: int,
        issue: str,
        proposed_change: Dict[str, Any],
    ) -> Dict[str, Any]:
        """
        Propose a change to the specification.
        
        CBA cannot modify specs directly - it must propose changes
        that go back to CSA for approval.
        
        Parameters
        ----------
        spec_version : int
            Version of the spec with the issue
        issue : str
            Description of the issue found
        proposed_change : Dict[str, Any]
            Proposed changes to the spec
            
        Returns
        -------
        Dict[str, Any]
            Structured change proposal
        """
        proposal = {
            "from_agent": "CBA",
            "to_agent": "CSA",
            "spec_version": spec_version,
            "timestamp": get_timestamp(),
            "issue": issue,
            "proposed_change": proposed_change,
            "status": "pending",
        }
        
        # Save proposal to CBA docs
        cba_docs_dir = self.folder_manager.get_agent_docs_dir("CBA")
        os.makedirs(cba_docs_dir, exist_ok=True)
        
        proposal_path = os.path.join(
            cba_docs_dir,
            f"CBA_change_proposal_v{spec_version:03d}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.json"
        )
        with open(proposal_path, 'w') as f:
            json.dump(proposal, f, indent=2)
        
        self.folder_manager.log_event(f"CBA proposed spec change for version {spec_version}")
        
        return proposal
