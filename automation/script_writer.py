"""
Script Writer

Extracts Python code blocks from LLM responses and writes them to disk
with proper headers and structure for safe subprocess execution.
"""

import os
import re
import time
from dataclasses import dataclass
from typing import Optional, List, Tuple
from pathlib import Path


SCRIPT_HEADER_TEMPLATE = '''#!/usr/bin/env python3
"""
Auto-generated script by Agentic Organ Generation workflow.

Generated: {timestamp}
Version: {version}
Object: {object_name}

This script was generated by an LLM and should be reviewed before execution.
It will be run via subprocess with the following environment:
  - ORGAN_AGENT_OUTPUT_DIR: Set to the object folder
  - Working directory: Object folder

IMPORTANT: All file writes should use OUTPUT_DIR as the base path.
"""

import os
import sys
import json

# Output directory from environment (set by subprocess runner)
OUTPUT_DIR = os.environ.get('ORGAN_AGENT_OUTPUT_DIR', os.getcwd())

# Ensure output directory exists
os.makedirs(OUTPUT_DIR, exist_ok=True)

'''

SCRIPT_FOOTER_TEMPLATE = '''

def _print_artifacts_json(files: list, metrics: dict = None, status: str = "success"):
    """Print the ARTIFACTS_JSON footer for verification."""
    import json
    artifacts = {
        "files": files,
        "metrics": metrics or {},
        "status": status
    }
    print(f"ARTIFACTS_JSON: {json.dumps(artifacts)}")


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        import traceback
        print(f"ERROR: {e}", file=sys.stderr)
        traceback.print_exc()
        _print_artifacts_json([], {}, "failed")
        sys.exit(1)
'''


@dataclass
class ScriptWriteResult:
    """
    Result of writing a script to disk.
    
    Attributes
    ----------
    success : bool
        Whether the script was written successfully
    script_path : str
        Path to the written script file
    response_path : str
        Path to the raw LLM response file
    code_block : str
        The extracted code block
    error : str or None
        Error message if writing failed
    warnings : List[str]
        List of warnings about the code
    """
    success: bool
    script_path: str
    response_path: str
    code_block: str
    error: Optional[str] = None
    warnings: List[str] = None
    
    def __post_init__(self):
        if self.warnings is None:
            self.warnings = []


def extract_code_block(text: str) -> Tuple[Optional[str], List[str]]:
    """
    Extract the first Python code block from LLM response text.
    
    Parameters
    ----------
    text : str
        LLM response text containing code blocks
        
    Returns
    -------
    Tuple[str or None, List[str]]
        The extracted code block (or None if not found) and list of warnings
    """
    warnings = []
    
    # Match ```python, ```py, ```python3, or plain ``` blocks
    pattern = r"```(?:python3?|py)?\s*\n(.*?)```"
    matches = re.findall(pattern, text, re.DOTALL | re.IGNORECASE)
    
    if matches:
        # Return the first (and ideally only) code block
        if len(matches) > 1:
            warnings.append(
                f"Found {len(matches)} code blocks, using the first one. "
                "Consider consolidating into a single block."
            )
        return matches[0].strip(), warnings
    
    # Try to find indented code after markers
    lines = text.split('\n')
    in_code_block = False
    current_block = []
    
    for line in lines:
        stripped = line.strip().lower()
        if stripped in ('code:', 'python:', 'script:', 'here is the code:'):
            in_code_block = True
            continue
        
        if in_code_block:
            if line.startswith('    ') or line.startswith('\t') or not line.strip():
                current_block.append(line)
            elif current_block:
                break
    
    if current_block:
        code = '\n'.join(current_block)
        warnings.append("Extracted code from indented block (no markdown fence found)")
        return code.strip(), warnings
    
    return None, ["No Python code block found in LLM response"]


def scan_for_suspicious_patterns(code: str) -> List[str]:
    """
    Scan code for suspicious patterns that might be dangerous.
    
    Parameters
    ----------
    code : str
        Python code to scan
        
    Returns
    -------
    List[str]
        List of warnings about suspicious patterns found
    """
    warnings = []
    
    suspicious_patterns = [
        (r'\bsubprocess\b', "Uses subprocess module - may execute arbitrary commands"),
        (r'\bos\.system\s*\(', "Uses os.system() - may execute arbitrary commands"),
        (r'\bos\.popen\s*\(', "Uses os.popen() - may execute arbitrary commands"),
        (r'\beval\s*\(', "Uses eval() - may execute arbitrary code"),
        (r'\bexec\s*\(', "Uses exec() - may execute arbitrary code"),
        (r'\bpip\s+install\b', "Contains pip install - may modify environment"),
        (r'\bshutil\.rmtree\s*\(', "Uses shutil.rmtree() - may delete directories"),
        (r'\bos\.remove\s*\(', "Uses os.remove() - may delete files"),
        (r'\bos\.unlink\s*\(', "Uses os.unlink() - may delete files"),
        (r'\bos\.rmdir\s*\(', "Uses os.rmdir() - may delete directories"),
        (r'__import__\s*\(', "Uses __import__() - may import arbitrary modules"),
        (r'\bopen\s*\([^)]*["\'][wa]["\']', "Opens files in write/append mode outside OUTPUT_DIR check"),
    ]
    
    for pattern, message in suspicious_patterns:
        if re.search(pattern, code, re.IGNORECASE):
            warnings.append(f"WARNING: {message}")
    
    # Check if main() function is defined
    if not re.search(r'\bdef\s+main\s*\(', code):
        warnings.append("No main() function defined - script may not execute properly")
    
    # Check if OUTPUT_DIR is used for file operations
    if re.search(r'\bopen\s*\(', code) and 'OUTPUT_DIR' not in code:
        warnings.append(
            "File operations detected but OUTPUT_DIR not referenced - "
            "files may be written outside the object folder"
        )
    
    return warnings


def ensure_main_function(code: str) -> str:
    """
    Ensure the code has a main() function wrapper if it doesn't already.
    
    Parameters
    ----------
    code : str
        Python code to check/modify
        
    Returns
    -------
    str
        Code with main() function ensured
    """
    if re.search(r'\bdef\s+main\s*\(', code):
        return code
    
    # Wrap the code in a main function
    lines = code.split('\n')
    
    # Separate imports from the rest
    import_lines = []
    other_lines = []
    in_imports = True
    
    for line in lines:
        stripped = line.strip()
        if in_imports and (
            stripped.startswith('import ') or 
            stripped.startswith('from ') or
            stripped == '' or
            stripped.startswith('#')
        ):
            import_lines.append(line)
        else:
            in_imports = False
            other_lines.append(line)
    
    # Build the wrapped code
    wrapped = '\n'.join(import_lines)
    wrapped += '\n\ndef main():\n'
    for line in other_lines:
        if line.strip():
            wrapped += '    ' + line + '\n'
        else:
            wrapped += '\n'
    
    return wrapped


def write_script(
    llm_response: str,
    output_dir: str,
    version: int,
    object_name: str = "object",
    add_header: bool = True,
    add_footer: bool = True,
    ensure_main: bool = True,
) -> ScriptWriteResult:
    """
    Extract code from LLM response and write to disk.
    
    Parameters
    ----------
    llm_response : str
        Full LLM response text containing code block
    output_dir : str
        Directory to write the script to (typically object's code_dir)
    version : int
        Version number for the script filename
    object_name : str
        Name of the object being generated
    add_header : bool
        Whether to prepend the standard header template
    add_footer : bool
        Whether to append the standard footer template
    ensure_main : bool
        Whether to ensure a main() function exists
        
    Returns
    -------
    ScriptWriteResult
        Result containing paths and any warnings
    """
    # Ensure output directory exists
    os.makedirs(output_dir, exist_ok=True)
    
    # Define output paths
    script_filename = f"generate_v{version:03d}.py"
    response_filename = f"llm_response_v{version:03d}.txt"
    
    script_path = os.path.join(output_dir, script_filename)
    response_path = os.path.join(output_dir, response_filename)
    
    all_warnings = []
    
    # Extract code block
    code_block, extract_warnings = extract_code_block(llm_response)
    all_warnings.extend(extract_warnings)
    
    if code_block is None:
        return ScriptWriteResult(
            success=False,
            script_path=script_path,
            response_path=response_path,
            code_block="",
            error="No Python code block found in LLM response",
            warnings=all_warnings,
        )
    
    # Scan for suspicious patterns
    scan_warnings = scan_for_suspicious_patterns(code_block)
    all_warnings.extend(scan_warnings)
    
    # Ensure main function if requested
    if ensure_main:
        code_block = ensure_main_function(code_block)
    
    # Build the final script
    script_content = ""
    
    if add_header:
        script_content += SCRIPT_HEADER_TEMPLATE.format(
            timestamp=time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime()),
            version=version,
            object_name=object_name,
        )
    
    script_content += code_block
    
    if add_footer:
        script_content += SCRIPT_FOOTER_TEMPLATE
    
    # Write the script
    try:
        with open(script_path, 'w') as f:
            f.write(script_content)
        
        # Make executable
        os.chmod(script_path, 0o755)
        
    except Exception as e:
        return ScriptWriteResult(
            success=False,
            script_path=script_path,
            response_path=response_path,
            code_block=code_block,
            error=f"Failed to write script: {e}",
            warnings=all_warnings,
        )
    
    # Write the raw LLM response
    try:
        with open(response_path, 'w') as f:
            f.write(llm_response)
    except Exception as e:
        all_warnings.append(f"Failed to write LLM response file: {e}")
    
    return ScriptWriteResult(
        success=True,
        script_path=script_path,
        response_path=response_path,
        code_block=code_block,
        warnings=all_warnings,
    )


def get_run_command(script_path: str, python_executable: str = "python") -> str:
    """
    Get the command to run a generated script.
    
    Parameters
    ----------
    script_path : str
        Path to the script file
    python_executable : str
        Python executable to use (default: "python")
        
    Returns
    -------
    str
        Command string to run the script
    """
    abs_path = os.path.abspath(script_path)
    return f"{python_executable} \"{abs_path}\""
